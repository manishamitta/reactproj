{"ast":null,"code":"/*!\n * OpenUI5\n * (c) Copyright 2009-2024 SAP SE or an SAP affiliate company.\n * Licensed under the Apache License, Version 2.0 - see LICENSE.txt.\n */\n// Provides class sap.ui.core.format.DateFormat\nimport Log from \"../../../base/Log.js\";\nimport formatMessage from \"../../../base/strings/formatMessage.js\";\nimport deepEqual from \"../../../base/util/deepEqual.js\";\nimport extend from \"../../../base/util/extend.js\";\nimport CalendarType from \"../CalendarType.js\";\nimport Configuration from \"../Configuration.js\";\nimport Core from \"../Core.js\";\nimport Locale from \"../Locale.js\";\nimport LocaleData from \"../LocaleData.js\";\nimport Supportability from \"../Supportability.js\";\nimport CalendarUtils from \"../date/CalendarUtils.js\";\nimport CalendarWeekNumbering from \"../date/CalendarWeekNumbering.js\";\nimport UI5Date from \"../date/UI5Date.js\";\nimport UniversalDate from \"../date/UniversalDate.js\";\nimport TimezoneUtil from \"./TimezoneUtil.js\";\n/**\n * Constructor for DateFormat - must not be used:\n * <ul>\n *   <li>To get a {@link sap.ui.core.format.DateFormat} instance, please use {@link sap.ui.core.format.DateFormat.getDateInstance}, {@link sap.ui.core.format.DateFormat.getDateTimeInstance} or {@link sap.ui.core.format.DateFormat.getTimeInstance}</li>\n *   <li>To get a {@link sap.ui.core.format.DateFormat.DateTimeWithTimezone} instance, please use {@link sap.ui.core.format.DateFormat.getDateTimeWithTimezoneInstance}</li>\n * </ul>\n *\n * @class\n * The DateFormat is a static class for formatting and parsing single date and time values or date and time intervals according\n * to a set of format options.\n *\n * Important:\n * Every Date is converted with the timezone taken from {@link sap.ui.core.Configuration#getTimezone}.\n * The timezone falls back to the browser's local timezone.\n *\n * Supported format options are pattern based on Unicode LDML Date Format notation. Please note that only a subset of the LDML date symbols\n * is supported.\n * If no pattern is specified a default pattern according to the locale settings is used.\n *\n * Documentation links:\n * <ul>\n *   <li>{@link topic:91f2eba36f4d1014b6dd926db0e91070 Date Format}</li>\n *   <li>{@link http://unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table}</li>\n * </ul>\n *\n * @public\n * @hideconstructor\n * @alias sap.ui.core.format.DateFormat\n */\nvar DateFormat = function () {\n  // Do not use the constructor\n  throw new Error();\n};\n\n/**\n * Internal enumeration to differentiate DateFormat types\n */\nvar mDateFormatTypes = {\n  DATE: \"date\",\n  TIME: \"time\",\n  DATETIME: \"datetime\",\n  DATETIME_WITH_TIMEZONE: \"datetimeWithTimezone\"\n};\n\n// Cache for parsed CLDR DatePattern\nvar mCldrDatePattern = {};\n\n/**\n * Timezone parameter type check\n *\n * @param {string} sTimezone The timezone to check\n * @throws {TypeError} Thrown if the parameter <code>sTimezone</code> is provided and has the wrong type.\n */\nvar checkTimezoneParameterType = function (sTimezone) {\n  if (typeof sTimezone !== \"string\" && !(sTimezone instanceof String) && sTimezone != null) {\n    throw new TypeError(\"The given timezone must be a string.\");\n  }\n};\nDateFormat.oDateInfo = {\n  type: mDateFormatTypes.DATE,\n  oDefaultFormatOptions: {\n    style: \"medium\",\n    relativeScale: \"day\",\n    relativeStyle: \"wide\"\n  },\n  aFallbackFormatOptions: [{\n    style: \"short\"\n  }, {\n    style: \"medium\"\n  }, {\n    pattern: \"yyyy-MM-dd\"\n  }, {\n    pattern: \"yyyyMMdd\",\n    strictParsing: true\n  }],\n  bShortFallbackFormatOptions: true,\n  bPatternFallbackWithoutDelimiter: true,\n  getPattern: function (oLocaleData, sStyle, sCalendarType) {\n    return oLocaleData.getDatePattern(sStyle, sCalendarType);\n  },\n  oRequiredParts: {\n    \"text\": true,\n    \"year\": true,\n    \"weekYear\": true,\n    \"month\": true,\n    \"day\": true\n  },\n  aRelativeScales: [\"year\", \"month\", \"week\", \"day\"],\n  aRelativeParseScales: [\"year\", \"quarter\", \"month\", \"week\", \"day\", \"hour\", \"minute\", \"second\"],\n  aIntervalCompareFields: [\"Era\", \"FullYear\", \"Quarter\", \"Month\", \"Week\", \"Date\"]\n};\nDateFormat.oDateTimeInfo = {\n  type: mDateFormatTypes.DATETIME,\n  oDefaultFormatOptions: {\n    style: \"medium\",\n    relativeScale: \"auto\",\n    relativeStyle: \"wide\"\n  },\n  aFallbackFormatOptions: [{\n    style: \"short\"\n  }, {\n    style: \"medium\"\n  }, {\n    pattern: \"yyyy-MM-dd'T'HH:mm:ss\"\n  }, {\n    pattern: \"yyyyMMdd HHmmss\"\n  }],\n  getPattern: function (oLocaleData, sStyle, sCalendarType) {\n    // If style is mixed (\"medium/short\") split it and pass both parts separately\n    var iSlashIndex = sStyle.indexOf(\"/\");\n    if (iSlashIndex > 0) {\n      return oLocaleData.getCombinedDateTimePattern(sStyle.substr(0, iSlashIndex), sStyle.substr(iSlashIndex + 1), sCalendarType);\n    } else {\n      return oLocaleData.getCombinedDateTimePattern(sStyle, sStyle, sCalendarType);\n    }\n  },\n  oRequiredParts: {\n    \"text\": true,\n    \"year\": true,\n    \"weekYear\": true,\n    \"month\": true,\n    \"day\": true,\n    \"hour0_23\": true,\n    \"hour1_24\": true,\n    \"hour0_11\": true,\n    \"hour1_12\": true\n  },\n  aRelativeScales: [\"year\", \"month\", \"week\", \"day\", \"hour\", \"minute\", \"second\"],\n  aRelativeParseScales: [\"year\", \"quarter\", \"month\", \"week\", \"day\", \"hour\", \"minute\", \"second\"],\n  aIntervalCompareFields: [\"Era\", \"FullYear\", \"Quarter\", \"Month\", \"Week\", \"Date\", \"DayPeriod\", \"Hours\", \"Minutes\", \"Seconds\"]\n};\n\n/**\n * Retrieves info object for timezone instance\n *\n * @param {object} oFormatOptions the format options, relevant are: showDate, showTime and showTimezone\n * @returns {object} info object\n * @private\n */\nDateFormat._getDateTimeWithTimezoneInfo = function (oFormatOptions) {\n  var bShowDate = oFormatOptions.showDate === undefined || oFormatOptions.showDate;\n  var bShowTime = oFormatOptions.showTime === undefined || oFormatOptions.showTime;\n  var bShowTimezone = oFormatOptions.showTimezone === undefined || oFormatOptions.showTimezone;\n  var oBaselineType = DateFormat.oDateTimeInfo;\n  if (bShowDate && !bShowTime) {\n    oBaselineType = DateFormat.oDateInfo;\n  } else if (!bShowDate && bShowTime) {\n    oBaselineType = DateFormat.oTimeInfo;\n  }\n  return Object.assign({}, oBaselineType, {\n    type: mDateFormatTypes.DATETIME_WITH_TIMEZONE,\n    // This function is used to transform the pattern of the fallbackFormatOptions to a timezone pattern.\n    getTimezonePattern: function (sPattern) {\n      if (!bShowDate && !bShowTime && bShowTimezone) {\n        return \"VV\";\n      } else if (!bShowTimezone) {\n        return sPattern;\n      } else {\n        return sPattern + \" VV\";\n      }\n    },\n    getPattern: function (oLocaleData, sStyle, sCalendarType) {\n      if (!bShowDate && !bShowTime && bShowTimezone) {\n        return \"VV\";\n      }\n      if (!bShowTimezone) {\n        return oBaselineType.getPattern(oLocaleData, sStyle, sCalendarType);\n      }\n      var sPattern = oBaselineType.getPattern(oLocaleData, sStyle, sCalendarType);\n      return oLocaleData.applyTimezonePattern(sPattern);\n    }\n  });\n};\nDateFormat.oTimeInfo = {\n  type: mDateFormatTypes.TIME,\n  oDefaultFormatOptions: {\n    style: \"medium\",\n    relativeScale: \"auto\",\n    relativeStyle: \"wide\"\n  },\n  aFallbackFormatOptions: [{\n    style: \"short\"\n  }, {\n    style: \"medium\"\n  }, {\n    pattern: \"HH:mm:ss\"\n  }, {\n    pattern: \"HHmmss\"\n  }],\n  getPattern: function (oLocaleData, sStyle, sCalendarType) {\n    return oLocaleData.getTimePattern(sStyle, sCalendarType);\n  },\n  oRequiredParts: {\n    \"text\": true,\n    \"hour0_23\": true,\n    \"hour1_24\": true,\n    \"hour0_11\": true,\n    \"hour1_12\": true\n  },\n  aRelativeScales: [\"hour\", \"minute\", \"second\"],\n  aRelativeParseScales: [\"year\", \"quarter\", \"month\", \"week\", \"day\", \"hour\", \"minute\", \"second\"],\n  aIntervalCompareFields: [\"DayPeriod\", \"Hours\", \"Minutes\", \"Seconds\"]\n};\n\n/**\n * @see sap.ui.core.format.DateFormat.getDateInstance\n */\nDateFormat.getInstance = function (oFormatOptions, oLocale) {\n  return this.getDateInstance(oFormatOptions, oLocale);\n};\n\n/**\n * Get a date instance of the DateFormat, which can be used for formatting.\n *\n * @param {object} [oFormatOptions] Object which defines the format options\n * @param {sap.ui.core.date.CalendarWeekNumbering} [oFormatOptions.calendarWeekNumbering] since 1.108.0 specifies the calendar week numbering.\n *   If specified, this overwrites <code>oFormatOptions.firstDayOfWeek</code> and <code>oFormatOptions.minimalDaysInFirstWeek</code>.\n * @param {int} [oFormatOptions.firstDayOfWeek] since 1.105.0 specifies the first day of the week starting with <code>0</code> (which is Sunday); if not defined, the value taken from the locale is used\n * @param {int} [oFormatOptions.minimalDaysInFirstWeek] since 1.105.0 minimal days at the beginning of the year which define the first calendar week; if not defined, the value taken from the locale is used\n * @param {string} [oFormatOptions.format] since 1.34.0 contains pattern symbols (e.g. \"yMMMd\" or \"Hms\") which will be converted into the pattern in the used locale, which matches the wanted symbols best.\n *  The symbols must be in canonical order, that is: Era (G), Year (y/Y), Quarter (q/Q), Month (M/L), Week (w), Day-Of-Week (E/e/c), Day (d), Hour (h/H/k/K/j/J), Minute (m), Second (s), Timezone (z/Z/v/V/O/X/x)\n *  See {@link http://unicode.org/reports/tr35/tr35-dates.html#availableFormats_appendItems}\n * @param {string} [oFormatOptions.pattern] a data pattern in LDML format. It is not verified whether the pattern represents only a date.\n * @param {string} [oFormatOptions.style] can be either 'short, 'medium', 'long' or 'full'. If no pattern is given, a locale dependent default date pattern of that style is used from the LocaleData class.\n * @param {boolean} [oFormatOptions.strictParsing] if true, by parsing it is checked if the value is a valid date\n * @param {boolean} [oFormatOptions.relative] if true, the date is formatted relatively to todays date if it is within the given day range, e.g. \"today\", \"1 day ago\", \"in 5 days\"\n * @param {int[]} [oFormatOptions.relativeRange] the day range used for relative formatting. If <code>oFormatOptions.relativeScale</code> is set to default value 'day', the relativeRange is by default [-6, 6], which means only the last 6 days, today and the next 6 days are formatted relatively. Otherwise when <code>oFormatOptions.relativeScale</code> is set to 'auto', all dates are formatted relatively.\n * @param {string} [oFormatOptions.relativeScale=\"day\"] if 'auto' is set, new relative time format is switched on for all Date/Time Instances. The relative scale is chosen depending on the difference between the given date and now.\n * @param {string} [oFormatOptions.relativeStyle=\"wide\"] since 1.32.10, 1.34.4 the style of the relative format. The valid values are \"wide\", \"short\", \"narrow\"\n * @param {boolean} [oFormatOptions.interval=false] since 1.48.0 if true, the {@link sap.ui.core.format.DateFormat#format format} method expects an array with two dates as the first argument and formats them as interval. Further interval \"Jan 10, 2008 - Jan 12, 2008\" will be formatted as \"Jan 10-12, 2008\" if the 'format' option is set with necessary symbols.\n *   Otherwise the two given dates are formatted separately and concatenated with local dependent pattern.\n * @param {string} [oFormatOptions.intervalDelimiter]\n *   Since 1.113.0, a delimiter for intervals. With a given interval delimiter a specific interval format is\n *   created. <b>Example:</b> If <code>oFormatOptions.intervalDelimiter</code> is set to \"...\", an interval would be\n *   given as \"Jan 10, 2008...Feb 12, 2008\".\n *   <b>Note:</b> If this format option is set, the locale-specific interval notation is overruled, for example\n *   \"Jan 10 – Feb 12, 2008\" becomes \"Jan 10, 2008...Feb 12, 2008\".\n * @param {boolean} [oFormatOptions.singleIntervalValue=false] Only relevant if oFormatOptions.interval is set to 'true'. This allows to pass an array with only one date object to the {@link sap.ui.core.format.DateFormat#format format} method.\n * @param {boolean} [oFormatOptions.UTC] if true, the date is formatted and parsed as UTC instead of the local timezone\n * @param {sap.ui.core.CalendarType} [oFormatOptions.calendarType] The calender type which is used to format and parse the date. This value is by default either set in configuration or calculated based on current locale.\n * @param {sap.ui.core.Locale} [oLocale] Locale to ask for locale specific texts/settings\n * @ui5-omissible-params oFormatOptions\n * @return {sap.ui.core.format.DateFormat} date instance of the DateFormat\n * @static\n * @public\n * @throws {TypeError} If:\n * <ul>\n *   <li>The <code>calendarWeekNumbering</code> format option has an unsupported value, or</li>\n *   <li>only one of the <code>firstDayOfWeek</code> and <code>minimalDaysInFirstWeek</code> parameters was provided.</li>\n * </ul>\n */\nDateFormat.getDateInstance = function (oFormatOptions, oLocale) {\n  return this.createInstance(oFormatOptions, oLocale, this.oDateInfo);\n};\n\n/**\n * Get a datetime instance of the DateFormat, which can be used for formatting.\n *\n * @param {object} [oFormatOptions] Object which defines the format options\n * @param {sap.ui.core.date.CalendarWeekNumbering} [oFormatOptions.calendarWeekNumbering] since 1.108.0 specifies the calendar week numbering.\n *   If specified, this overwrites <code>oFormatOptions.firstDayOfWeek</code> and <code>oFormatOptions.minimalDaysInFirstWeek</code>.\n * @param {int} [oFormatOptions.firstDayOfWeek] since 1.105.0 specifies the first day of the week starting with <code>0</code> (which is Sunday); if not defined, the value taken from the locale is used\n * @param {int} [oFormatOptions.minimalDaysInFirstWeek] since 1.105.0 minimal days at the beginning of the year which define the first calendar week; if not defined, the value taken from the locale is used\n * @param {string} [oFormatOptions.format] since 1.34.0 contains pattern symbols (e.g. \"yMMMd\" or \"Hms\") which will be converted into the pattern in the used locale, which matches the wanted symbols best.\n *  The symbols must be in canonical order, that is: Era (G), Year (y/Y), Quarter (q/Q), Month (M/L), Week (w), Day-Of-Week (E/e/c), Day (d), Hour (h/H/k/K/j/J), Minute (m), Second (s), Timezone (z/Z/v/V/O/X/x)\n *  See http://unicode.org/reports/tr35/tr35-dates.html#availableFormats_appendItems\n * @param {string} [oFormatOptions.pattern] a datetime pattern in LDML format. It is not verified whether the pattern represents a full datetime.\n * @param {string} [oFormatOptions.style] can be either 'short, 'medium', 'long' or 'full'. For datetime you can also define mixed styles, separated with a slash, where the first part is the date style and the second part is the time style (e.g. \"medium/short\"). If no pattern is given, a locale dependent default datetime pattern of that style is used from the LocaleData class.\n * @param {boolean} [oFormatOptions.strictParsing] if true, by parsing it is checked if the value is a valid datetime\n * @param {boolean} [oFormatOptions.relative] if true, the date is formatted relatively to today's date if it is within the given day range, e.g. \"today\", \"1 day ago\", \"in 5 days\"\n * @param {int[]} [oFormatOptions.relativeRange] the day range used for relative formatting. If <code>oFormatOptions.relativeScale</code> is set to default value 'day', the relativeRange is by default [-6, 6], which means only the last 6 days, today and the next 6 days are formatted relatively. Otherwise when <code>oFormatOptions.relativeScale</code> is set to 'auto', all dates are formatted relatively.\n * @param {string} [oFormatOptions.relativeScale=\"day\"] if 'auto' is set, new relative time format is switched on for all Date/Time Instances. The relative scale is chosen depending on the difference between the given date and now.\n * @param {string} [oFormatOptions.relativeStyle=\"wide\"] since 1.32.10, 1.34.4 the style of the relative format. The valid values are \"wide\", \"short\", \"narrow\"\n * @param {boolean} [oFormatOptions.interval=false] since 1.48.0 if true, the {@link sap.ui.core.format.DateFormat#format format} method expects an array with two dates as the first argument and formats them as interval. Further interval \"Jan 10, 2008 - Jan 12, 2008\" will be formatted as \"Jan 10-12, 2008\" if the 'format' option is set with necessary symbols.\n *   Otherwise the two given dates are formatted separately and concatenated with local dependent pattern.\n * @param {string} [oFormatOptions.intervalDelimiter]\n *   Since 1.113.0, a delimiter for intervals. With a given interval delimiter a specific interval format is\n *   created. <b>Example:</b> If <code>oFormatOptions.intervalDelimiter</code> is set to \"...\", an interval would be\n *   given as \"Jan 10, 2008, 9:15:00 AM...Jan 10, 2008, 11:45:00 AM\".\n *   <b>Note:</b> If this format option is set, the locale-specific interval notation is overruled, for example\n *   \"Jan 10, 2008, 9:15 – 11:45 AM\" becomes \"Jan 10, 2008, 9:15 AM...Jan 10, 2008, 11:45 AM\".\n * @param {boolean} [oFormatOptions.singleIntervalValue=false] Only relevant if oFormatOptions.interval is set to 'true'. This allows to pass an array with only one date object to the {@link sap.ui.core.format.DateFormat#format format} method.\n * @param {boolean} [oFormatOptions.UTC] if true, the date is formatted and parsed as UTC instead of the local timezone\n * @param {sap.ui.core.CalendarType} [oFormatOptions.calendarType] The calender type which is used to format and parse the date. This value is by default either set in configuration or calculated based on current locale.\n * @param {sap.ui.core.Locale} [oLocale] Locale to ask for locale specific texts/settings\n * @ui5-omissible-params oFormatOptions\n * @return {sap.ui.core.format.DateFormat} datetime instance of the DateFormat\n * @static\n * @public\n * @throws {TypeError} If:\n * <ul>\n *   <li>The <code>calendarWeekNumbering</code> format option has an unsupported value, or</li>\n *   <li>only one of the <code>firstDayOfWeek</code> and <code>minimalDaysInFirstWeek</code> parameters was provided.</li>\n * </ul>\n */\nDateFormat.getDateTimeInstance = function (oFormatOptions, oLocale) {\n  return this.createInstance(oFormatOptions, oLocale, this.oDateTimeInfo);\n};\n\n/**\n * Interface for a timezone-specific DateFormat, which is able to format and parse a date\n * based on a given timezone. The timezone is used to convert the given date, and also for\n * timezone-related pattern symbols. The timezone is an IANA timezone ID, e.g. \"America/New_York\".\n *\n * @see sap.ui.core.format.DateFormat\n *\n * @author SAP SE\n * @since 1.99\n * @interface\n * @name sap.ui.core.format.DateFormat.DateTimeWithTimezone\n * @public\n */\n\n/**\n * Format a date object to a string according to the given timezone and format options.\n *\n * @example <caption>Format option showTimezone: true (default)</caption>\n * var oDate = UI5Date.getInstance(\"2021-12-24T13:37:00Z\");\n *\n * DateFormat.getDateTimeWithTimezoneInstance().format(oDate, \"Europe/Berlin\");\n * // output: \"Dec 24, 2021, 2:37:00 PM Europe, Berlin\"\n *\n * DateFormat.getDateTimeWithTimezoneInstance().format(oDate, \"America/New_York\");\n * // output: \"Dec 24, 2021, 8:37:00 AM Americas, New York\"\n *\n * @example <caption>Format option showTimezone: false</caption>\n * var oDate = UI5Date.getInstance(\"2021-12-24T13:37:00Z\");\n * DateFormat.getDateTimeWithTimezoneInstance({showTimezone: false}).format(oDate, \"America/New_York\");\n * // output: \"Dec 24, 2021, 8:37:00 AM\"\n *\n * @example <caption>Format option showDate: false and showTime:false</caption>\n * var oDate = UI5Date.getInstance(\"2021-12-24T13:37:00Z\");\n * DateFormat.getDateTimeWithTimezoneInstance({showDate: false, showTime: false}).format(oDate, \"America/New_York\");\n * // output: \"Americas, New York\"\n *\n * @param {Date} oJSDate The date to format\n * @param {string} [sTimezone] The IANA timezone ID in which the date will be calculated and\n *   formatted e.g. \"America/New_York\". If the parameter is omitted, <code>null</code> or an empty string, the timezone\n *   will be taken from {@link sap.ui.core.Configuration#getTimezone}. For an invalid IANA timezone ID, an empty string will be returned.\n * @throws {TypeError} Thrown if the parameter <code>sTimezone</code> is provided and has the wrong type.\n * @return {string} the formatted output value. If an invalid date or timezone is given, an empty string is returned.\n * @name sap.ui.core.format.DateFormat.DateTimeWithTimezone.format\n * @function\n * @public\n * @since 1.99\n */\n\n/**\n * Parse a string which is formatted according to the given format options to an array\n * containing a date object and the timezone.\n *\n * @example <caption>Format option showTimezone: true (default)</caption>\n * var oDate = UI5Date.getInstance(\"2021-12-24T13:37:00Z\");\n *\n * DateFormat.getDateTimeWithTimezoneInstance().parse(\"Dec 24, 2021, 2:37:00 PM Europe, Berlin\", \"Europe/Berlin\");\n * // output: [oDate, \"Europe/Berlin\"]\n *\n * DateFormat.getDateTimeWithTimezoneInstance().parse(\"Dec 24, 2021, 8:37:00 AM Americas, New York\", \"America/New_York\");\n * // output: [oDate, \"America/New_York\"]\n *\n * @example <caption>Format option showTimezone: false</caption>\n * var oDate = UI5Date.getInstance(\"2021-12-24T13:37:00Z\");\n * DateFormat.getDateTimeWithTimezoneInstance({showTimezone: false}).parse(\"Dec 24, 2021, 8:37:00 AM\", \"America/New_York\");\n * // output: [oDate, undefined]\n *\n * @example <caption>Format option showDate: false and showTime: false</caption>\n * DateFormat.getDateTimeWithTimezoneInstance({showDate: false, showTime: false}).parse(\"Americas, New York\", \"America/New_York\");\n * // output: [undefined, \"America/New_York\"]\n *\n * @param {string} sValue the string containing a formatted date/time value\n * @param {string} [sTimezone] The IANA timezone ID which should be used to convert the date\n *   e.g. \"America/New_York\". If the parameter is omitted, <code>null</code> or an empty string, the timezone will be taken\n *   from {@link sap.ui.core.Configuration#getTimezone}. For an invalid IANA timezone ID, <code>null</code> will be returned.\n * @param {boolean} [bStrict] Whether to be strict with regards to the value ranges of date fields,\n * e.g. for a month pattern of <code>MM</code> and a value range of [1-12]\n * <code>strict</code> ensures that the value is within the range;\n * if it is larger than <code>12</code> it cannot be parsed and <code>null</code> is returned\n * @throws {TypeError} Thrown if one of the following applies:\n *   <ul>\n *       <li>the <code>sTimezone</code> parameter is provided and has the wrong type</li>\n *       <li>only the time is shown (<code>showDate</code> is <code>false</code>), or only the\n *       date is shown (<code>showTime</code> is <code>false</code>)</li>\n *   </ul>\n * @return {Array} the parsed values\n * <ul>\n *   <li>An array containing datetime and timezone depending on the showDate, showTime and showTimezone options\n *     <ul>\n *         <li>(Default): [Date, string], e.g.\n *           [UI5Date.getInstance(\"2021-11-13T13:22:33Z\"), \"America/New_York\"]</li>\n *         <li><code>showTimezone: false</code>: [Date, undefined], e.g.\n *           [UI5Date.getInstance(\"2021-11-13T13:22:33Z\"), undefined]</li>\n *         <li><code>showDate: false, showTime: false</code>: [undefined, string], e.g.\n *           [undefined, \"America/New_York\"]</li>\n *     </ul>\n *   </li>\n * </ul>\n *\n * @public\n * @name sap.ui.core.format.DateFormat.DateTimeWithTimezone.parse\n * @function\n * @since 1.99\n */\n// This method has a TypeScript specific overlay for a better return value documentation,\n// see 'src/sap.ui.core/.dtsgenrc'\n\n/**\n * Get a datetimeWithTimezone instance of the DateFormat, which can be used for formatting.\n *\n * @param {object} [oFormatOptions] An object which defines the format options\n * @param {sap.ui.core.date.CalendarWeekNumbering} [oFormatOptions.calendarWeekNumbering] since 1.108.0 specifies the calendar week numbering.\n *   If specified, this overwrites <code>oFormatOptions.firstDayOfWeek</code> and <code>oFormatOptions.minimalDaysInFirstWeek</code>.\n * @param {int} [oFormatOptions.firstDayOfWeek] since 1.105.0 specifies the first day of the week starting with <code>0</code> (which is Sunday); if not defined, the value taken from the locale is used\n * @param {int} [oFormatOptions.minimalDaysInFirstWeek] since 1.105.0 minimal days at the beginning of the year which define the first calendar week; if not defined, the value taken from the locale is used\n * @param {string} [oFormatOptions.format] A string containing pattern symbols (e.g. \"yMMMd\" or \"Hms\") which will be converted into a pattern for the used locale that matches the wanted symbols best.\n *  The symbols must be in canonical order, that is: Era (G), Year (y/Y), Quarter (q/Q), Month (M/L), Week (w), Day-Of-Week (E/e/c), Day (d), Hour (h/H/k/K/j/J), Minute (m), Second (s), Timezone (z/Z/v/V/O/X/x)\n *  See http://unicode.org/reports/tr35/tr35-dates.html#availableFormats_appendItems\n * @param {string} [oFormatOptions.pattern] a datetime pattern in LDML format. It is not verified whether the pattern represents a full datetime.\n * @param {boolean} [oFormatOptions.showDate=true] Specifies if the date should be displayed.\n *   It is ignored for formatting when an options pattern or a format are supplied.\n * @param {boolean} [oFormatOptions.showTime=true] Specifies if the time should be displayed.\n *   It is ignored for formatting when an options pattern or a format are supplied.\n * @param {boolean} [oFormatOptions.showTimezone=true] Specifies if the timezone should be displayed.\n *   It is ignored for formatting when an options pattern or a format are supplied.\n * @param {string} [oFormatOptions.style] Can be either 'short, 'medium', 'long' or 'full'. For datetime you can also define mixed styles, separated with a slash, where the first part is the date style and the second part is the time style (e.g. \"medium/short\"). If no pattern is given, a locale-dependent default datetime pattern of that style from the LocaleData class is used.\n * @param {boolean} [oFormatOptions.strictParsing] Whether to check by parsing if the value is a valid datetime\n * @param {boolean} [oFormatOptions.relative] Whether the date is formatted relatively to today's date if it is within the given day range, e.g. \"today\", \"1 day ago\", \"in 5 days\"\n * @param {int[]} [oFormatOptions.relativeRange] The day range used for relative formatting. If <code>oFormatOptions.relativeScale</code> is set to the default value 'day', the <code>relativeRange<code> is by default [-6, 6], which means that only the previous 6 and the following 6 days are formatted relatively. If <code>oFormatOptions.relativeScale</code> is set to 'auto', all dates are formatted relatively.\n * @param {string} [oFormatOptions.relativeScale] If 'auto' is set, a new relative time format is switched on for all Date/Time instances. The default value depends on <code>showDate</code> and <code>showTime</code> options.\n * @param {string} [oFormatOptions.relativeStyle=\"wide\"] The style of the relative format. The valid values are \"wide\", \"short\", \"narrow\"\n * @param {sap.ui.core.CalendarType} [oFormatOptions.calendarType] The calendar type which is used to format and parse the date. This value is by default either set in the configuration or calculated based on the current locale.\n * @param {sap.ui.core.Locale} [oLocale] Locale to ask for locale-specific texts/settings\n * @ui5-omissible-params oFormatOptions\n * @throws {TypeError} If an invalid configuration was supplied, i.e. when the\n *   <code>showDate</code>, <code>showTime</code>, and <code>showTimezone</code> format options\n *   are all <code>false</code>\n * @return {sap.ui.core.format.DateFormat.DateTimeWithTimezone} dateTimeWithTimezone instance of the DateFormat\n * @static\n * @public\n * @since 1.99.0\n * @throws {TypeError} If:\n * <ul>\n *   <li>The <code>calendarWeekNumbering</code> format option has an unsupported value, or</li>\n *   <li>only one of the <code>firstDayOfWeek</code> and <code>minimalDaysInFirstWeek</code> parameters was provided.</li>\n * </ul>\n */\nDateFormat.getDateTimeWithTimezoneInstance = function (oFormatOptions, oLocale) {\n  if (oFormatOptions && !(oFormatOptions instanceof Locale)) {\n    /** @deprecated As of version 1.101.0 */\n    (function () {\n      // do not modify the input format options\n      oFormatOptions = Object.assign({}, oFormatOptions);\n      // translate old showTimezone values (backward compatibility)\n      if (typeof oFormatOptions.showTimezone === \"string\") {\n        var sShowTimezone = oFormatOptions.showTimezone;\n        if (oFormatOptions.showDate === undefined && oFormatOptions.showTime === undefined) {\n          if (sShowTimezone === \"Hide\") {\n            oFormatOptions.showTimezone = false;\n          } else if (sShowTimezone === \"Only\") {\n            oFormatOptions.showDate = false;\n            oFormatOptions.showTime = false;\n          }\n        }\n        oFormatOptions.showTimezone = sShowTimezone !== \"Hide\";\n      }\n    })();\n    if (oFormatOptions.showDate === false && oFormatOptions.showTime === false && oFormatOptions.showTimezone === false) {\n      throw new TypeError(\"Invalid Configuration. One of the following format options must be true: \" + \"showDate, showTime or showTimezone.\");\n    }\n  }\n  return this.createInstance(oFormatOptions, oLocale, DateFormat._getDateTimeWithTimezoneInfo(oFormatOptions || {}));\n};\n\n/**\n * Get a time instance of the DateFormat, which can be used for formatting.\n *\n * @param {object} [oFormatOptions] Object which defines the format options\n * @param {sap.ui.core.date.CalendarWeekNumbering} [oFormatOptions.calendarWeekNumbering] since 1.108.0 specifies the calendar week numbering.\n *   If specified, this overwrites <code>oFormatOptions.firstDayOfWeek</code> and <code>oFormatOptions.minimalDaysInFirstWeek</code>.\n * @param {int} [oFormatOptions.firstDayOfWeek] since 1.105.0 specifies the first day of the week starting with <code>0</code> (which is Sunday); if not defined, the value taken from the locale is used\n * @param {int} [oFormatOptions.minimalDaysInFirstWeek] since 1.105.0 minimal days at the beginning of the year which define the first calendar week; if not defined, the value taken from the locale is used\n * @param {string} [oFormatOptions.format] since 1.34.0 contains pattern symbols (e.g. \"yMMMd\" or \"Hms\") which will be converted into the pattern in the used locale, which matches the wanted symbols best.\n *  The symbols must be in canonical order, that is: Era (G), Year (y/Y), Quarter (q/Q), Month (M/L), Week (w), Day-Of-Week (E/e/c), Day (d), Hour (h/H/k/K/j/J), Minute (m), Second (s), Timezone (z/Z/v/V/O/X/x)\n *  See http://unicode.org/reports/tr35/tr35-dates.html#availableFormats_appendItems\n * @param {string} [oFormatOptions.pattern] a time pattern in LDML format. It is not verified whether the pattern only represents a time.\n * @param {string} [oFormatOptions.style] can be either 'short, 'medium', 'long' or 'full'. If no pattern is given, a locale dependent default time pattern of that style is used from the LocaleData class.\n * @param {boolean} [oFormatOptions.strictParsing] if true, by parsing it is checked if the value is a valid time\n * @param {boolean} [oFormatOptions.relative] if true, the date is formatted relatively to todays date if it is within the given day range, e.g. \"today\", \"1 day ago\", \"in 5 days\"\n * @param {int[]} [oFormatOptions.relativeRange] the day range used for relative formatting. If <code>oFormatOptions.relativeScale</code> is set to default value 'day', the relativeRange is by default [-6, 6], which means only the last 6 days, today and the next 6 days are formatted relatively. Otherwise when <code>oFormatOptions.relativeScale</code> is set to 'auto', all dates are formatted relatively.\n * @param {string} [oFormatOptions.relativeScale=\"day\"] if 'auto' is set, new relative time format is switched on for all Date/Time Instances. The relative scale is chosen depending on the difference between the given date and now.\n * @param {string} [oFormatOptions.relativeStyle=\"wide\"] since 1.32.10, 1.34.4 the style of the relative format. The valid values are \"wide\", \"short\", \"narrow\"\n * @param {boolean} [oFormatOptions.interval=false] since 1.48.0 if true, the {@link sap.ui.core.format.DateFormat#format format} method expects an array with two dates as the first argument and formats them as interval. Further interval \"Jan 10, 2008 - Jan 12, 2008\" will be formatted as \"Jan 10-12, 2008\" if the 'format' option is set with necessary symbols.\n *   Otherwise the two given dates are formatted separately and concatenated with local dependent pattern.\n * @param {string} [oFormatOptions.intervalDelimiter]\n *   Since 1.113.0, a delimiter for intervals. With a given interval delimiter a specific interval format is\n *   created. <b>Example:</b> If <code>oFormatOptions.intervalDelimiter</code> is set to \"...\", an interval would be\n *   given as \"09:15 AM...11:45 AM\".\n *   <b>Note:</b> If this format option is set, the locale-specific interval notation is overruled, for example\n *   \"09:15 – 11:45 AM\" becomes \"9:15 AM...11:45 AM\".\n * @param {boolean} [oFormatOptions.singleIntervalValue=false] Only relevant if oFormatOptions.interval is set to 'true'. This allows to pass an array with only one date object to the {@link sap.ui.core.format.DateFormat#format format} method.\n * @param {boolean} [oFormatOptions.UTC] if true, the time is formatted and parsed as UTC instead of the local timezone\n * @param {sap.ui.core.CalendarType} [oFormatOptions.calendarType] The calender type which is used to format and parse the date. This value is by default either set in configuration or calculated based on current locale.\n * @param {sap.ui.core.Locale} [oLocale] Locale to ask for locale specific texts/settings\n * @ui5-omissible-params oFormatOptions\n * @return {sap.ui.core.format.DateFormat} time instance of the DateFormat\n * @static\n * @public\n * @throws {TypeError} If:\n * <ul>\n *   <li>The <code>calendarWeekNumbering</code> format option has an unsupported value, or</li>\n *   <li>only one of the <code>firstDayOfWeek</code> and <code>minimalDaysInFirstWeek</code> parameters was provided.</li>\n * </ul>\n */\nDateFormat.getTimeInstance = function (oFormatOptions, oLocale) {\n  return this.createInstance(oFormatOptions, oLocale, this.oTimeInfo);\n};\n\n/**\n * Create instance of the DateFormat.\n *\n * @param {object} [oFormatOptions] Object which defines the format options\n * @param {sap.ui.core.Locale} [oLocale] Locale to ask for locale specific texts/settings\n * @param {object} [oInfo] Info information common to all instances of the created \"type\",\n *   e.g. default format options\n * @param {boolean} [bIsFallback=false] Whether this is a fallback format instance\n * @return {sap.ui.core.format.DateFormat} time instance of the DateFormat\n * @static\n * @private\n * @throws {TypeError} If:\n * <ul>\n *   <li>The <code>calendarWeekNumbering</code> format option has an unsupported value, or</li>\n *   <li>only one of the <code>firstDayOfWeek</code> and <code>minimalDaysInFirstWeek</code> parameters was provided.</li>\n * </ul>\n */\nDateFormat.createInstance = function (oFormatOptions, oLocale, oInfo, bIsFallback) {\n  var aFallbackFormatOptions, oFormat, sPattern;\n\n  // Create an instance of the DateFormat\n  oFormat = Object.create(this.prototype);\n\n  // Handle optional parameters\n  if (oFormatOptions instanceof Locale) {\n    oLocale = oFormatOptions;\n    oFormatOptions = undefined;\n  }\n\n  // Get Locale and LocaleData to use\n  if (!oLocale) {\n    oLocale = Configuration.getFormatSettings().getFormatLocale();\n  }\n  oFormat.oLocale = oLocale;\n  oFormat.oLocaleData = LocaleData.getInstance(oLocale);\n\n  // Extend the default format options with custom format options and retrieve the pattern\n  // from the LocaleData, in case it is not defined yet\n  oFormat.oFormatOptions = extend({}, oInfo.oDefaultFormatOptions, oFormatOptions);\n\n  // set unsupported properties to false/undefined\n  if (oInfo.type === mDateFormatTypes.DATETIME_WITH_TIMEZONE) {\n    oFormat.oFormatOptions.interval = false;\n    oFormat.oFormatOptions.singleIntervalValue = false;\n    oFormat.oFormatOptions.UTC = false;\n  } else {\n    oFormat.oFormatOptions.showTimezone = undefined;\n    oFormat.oFormatOptions.showDate = undefined;\n    oFormat.oFormatOptions.showTime = undefined;\n  }\n\n  // type cannot be changed and should be an instance property instead of a format option\n  oFormat.type = oInfo.type;\n  if (!oFormat.oFormatOptions.calendarType) {\n    oFormat.oFormatOptions.calendarType = Configuration.getCalendarType();\n  }\n  if (oFormat.oFormatOptions.firstDayOfWeek === undefined && oFormat.oFormatOptions.minimalDaysInFirstWeek !== undefined || oFormat.oFormatOptions.firstDayOfWeek !== undefined && oFormat.oFormatOptions.minimalDaysInFirstWeek === undefined) {\n    throw new TypeError(\"Format options firstDayOfWeek and minimalDaysInFirstWeek need both to be set, but only one was provided.\");\n  }\n  if (oFormat.oFormatOptions.calendarWeekNumbering && !Object.values(CalendarWeekNumbering).includes(oFormat.oFormatOptions.calendarWeekNumbering)) {\n    throw new TypeError(\"Illegal format option calendarWeekNumbering: '\" + oFormat.oFormatOptions.calendarWeekNumbering + \"'\");\n  }\n  if (!oFormat.oFormatOptions.pattern) {\n    if (oFormat.oFormatOptions.format) {\n      oFormat.oFormatOptions.pattern = oFormat.oLocaleData.getCustomDateTimePattern(oFormat.oFormatOptions.format, oFormat.oFormatOptions.calendarType);\n    } else {\n      oFormat.oFormatOptions.pattern = oInfo.getPattern(oFormat.oLocaleData, oFormat.oFormatOptions.style, oFormat.oFormatOptions.calendarType);\n    }\n  }\n  if (oFormat.oFormatOptions.interval) {\n    var sSinglePattern,\n      sDelimiter = oFormat.oFormatOptions.intervalDelimiter;\n    if (oFormat.oFormatOptions.format) {\n      // when 'format' option is set, generate the pattern based on the greatest difference\n      oFormat.intervalPatterns = oFormat.oLocaleData.getCustomIntervalPattern(oFormat.oFormatOptions.format, null /*=no diff*/, oFormat.oFormatOptions.calendarType);\n\n      // In case oFormat.intervalPatterns is a string, put the single string into array\n      if (typeof oFormat.intervalPatterns === \"string\") {\n        oFormat.intervalPatterns = [oFormat.intervalPatterns];\n      }\n      sSinglePattern = oFormat.oLocaleData.getCustomDateTimePattern(oFormat.oFormatOptions.format, oFormat.oFormatOptions.calendarType);\n      // Put the single date pattern, which is generated based on the oFormatOptions.format, into the array in\n      // case the date interval is formatted as a single date\n      oFormat.intervalPatterns.push(sSinglePattern);\n    } else {\n      sSinglePattern = oFormat.oFormatOptions.pattern;\n      oFormat.intervalPatterns = [\n      // when 'format' option is not set, generate the combined interval pattern\n      oFormat.oLocaleData.getCombinedIntervalPattern(oFormat.oFormatOptions.pattern, oFormat.oFormatOptions.calendarType),\n      // Put the single date pattern into the array in case the date interval is formatted as a single date\n      oFormat.oFormatOptions.pattern];\n    }\n    oFormat.intervalPatterns.push(oFormat.oFormatOptions.pattern + \" - \" + oFormat.oFormatOptions.pattern);\n    if (sDelimiter) {\n      // use delimiter pattern as first choice\n      sDelimiter = sDelimiter.replace(/'/g, \"''\");\n      sDelimiter = \"'\" + sDelimiter + \"'\";\n      oFormat.intervalPatterns.unshift(sSinglePattern + sDelimiter + sSinglePattern);\n    }\n    oFormat.intervalPatterns = Array.from(new Set(oFormat.intervalPatterns));\n  }\n\n  // if the current format isn't a fallback format, create its fallback formats\n  if (!bIsFallback) {\n    aFallbackFormatOptions = oInfo.aFallbackFormatOptions;\n    // Add two fallback patterns for locale-dependent short format without delimiters\n    if (oInfo.bShortFallbackFormatOptions) {\n      sPattern = oInfo.getPattern(oFormat.oLocaleData, \"short\");\n      // add the options of fallback formats without delimiters to the fallback options array\n      aFallbackFormatOptions = aFallbackFormatOptions.concat(DateFormat._createFallbackOptionsWithoutDelimiter(sPattern));\n    }\n    if (oFormat.oFormatOptions.pattern && oInfo.bPatternFallbackWithoutDelimiter) {\n      // create options of fallback formats by removing delimiters from the given pattern\n      // insert the new fallback format options to the front of the array\n      aFallbackFormatOptions = DateFormat._createFallbackOptionsWithoutDelimiter(oFormat.oFormatOptions.pattern).concat(aFallbackFormatOptions);\n    }\n\n    // remove duplicate format options (e.g. fallback format with same pattern is not needed twice)\n    aFallbackFormatOptions = aFallbackFormatOptions.reduce(function (aFallbacks, oOptions) {\n      var aKeys = Object.keys(oOptions),\n        bDuplicate = aFallbacks.some(function (oOptions0) {\n          return Object.keys(oOptions0).length === aKeys.length && aKeys.every(function (sKey) {\n            return oOptions0[sKey] === oOptions[sKey];\n          });\n        });\n      if (!bDuplicate) {\n        aFallbacks.push(oOptions);\n      }\n      return aFallbacks;\n    }, []);\n    oFormat.aFallbackFormats = DateFormat._createFallbackFormat(aFallbackFormatOptions, oFormat.oFormatOptions.calendarType, oLocale, oInfo, oFormat.oFormatOptions);\n  }\n  oFormat.oRequiredParts = oInfo.oRequiredParts;\n  oFormat.aRelativeScales = oInfo.aRelativeScales;\n  oFormat.aRelativeParseScales = oInfo.aRelativeParseScales;\n  oFormat.aIntervalCompareFields = oInfo.aIntervalCompareFields;\n  oFormat.init();\n  return oFormat;\n};\n\n/**\n * Initialize date format\n */\nDateFormat.prototype.init = function () {\n  var sCalendarType = this.oFormatOptions.calendarType;\n  this.aMonthsAbbrev = this.oLocaleData._getMonthsWithAlternatives(\"abbreviated\", sCalendarType);\n  this.aMonthsWide = this.oLocaleData.getMonths(\"wide\", sCalendarType);\n  this.aMonthsNarrow = this.oLocaleData.getMonths(\"narrow\", sCalendarType);\n  this.aMonthsAbbrevSt = this.oLocaleData._getMonthsStandAloneWithAlternatives(\"abbreviated\", sCalendarType);\n  this.aMonthsWideSt = this.oLocaleData.getMonthsStandAlone(\"wide\", sCalendarType);\n  this.aMonthsNarrowSt = this.oLocaleData.getMonthsStandAlone(\"narrow\", sCalendarType);\n  this.aDaysAbbrev = this.oLocaleData.getDays(\"abbreviated\", sCalendarType);\n  this.aDaysWide = this.oLocaleData.getDays(\"wide\", sCalendarType);\n  this.aDaysNarrow = this.oLocaleData.getDays(\"narrow\", sCalendarType);\n  this.aDaysShort = this.oLocaleData.getDays(\"short\", sCalendarType);\n  this.aDaysAbbrevSt = this.oLocaleData.getDaysStandAlone(\"abbreviated\", sCalendarType);\n  this.aDaysWideSt = this.oLocaleData.getDaysStandAlone(\"wide\", sCalendarType);\n  this.aDaysNarrowSt = this.oLocaleData.getDaysStandAlone(\"narrow\", sCalendarType);\n  this.aDaysShortSt = this.oLocaleData.getDaysStandAlone(\"short\", sCalendarType);\n  this.aQuartersAbbrev = this.oLocaleData.getQuarters(\"abbreviated\", sCalendarType);\n  this.aQuartersWide = this.oLocaleData.getQuarters(\"wide\", sCalendarType);\n  this.aQuartersNarrow = this.oLocaleData.getQuarters(\"narrow\", sCalendarType);\n  this.aQuartersAbbrevSt = this.oLocaleData.getQuartersStandAlone(\"abbreviated\", sCalendarType);\n  this.aQuartersWideSt = this.oLocaleData.getQuartersStandAlone(\"wide\", sCalendarType);\n  this.aQuartersNarrowSt = this.oLocaleData.getQuartersStandAlone(\"narrow\", sCalendarType);\n  this.aErasNarrow = this.oLocaleData.getEras(\"narrow\", sCalendarType);\n  this.aErasAbbrev = this.oLocaleData.getEras(\"abbreviated\", sCalendarType);\n  this.aErasWide = this.oLocaleData.getEras(\"wide\", sCalendarType);\n  this.aDayPeriodsAbbrev = this.oLocaleData.getDayPeriods(\"abbreviated\", sCalendarType);\n  this.aDayPeriodsNarrow = this.oLocaleData.getDayPeriods(\"narrow\", sCalendarType);\n  this.aDayPeriodsWide = this.oLocaleData.getDayPeriods(\"wide\", sCalendarType);\n  this.oFlexibleDayPeriodsAbbrev = this.oLocaleData.getFlexibleDayPeriods(\"abbreviated\", sCalendarType);\n  this.oFlexibleDayPeriodsNarrow = this.oLocaleData.getFlexibleDayPeriods(\"narrow\", sCalendarType);\n  this.oFlexibleDayPeriodsWide = this.oLocaleData.getFlexibleDayPeriods(\"wide\", sCalendarType);\n  this.oFlexibleDayPeriodsAbbrevSt = this.oLocaleData.getFlexibleDayPeriodsStandAlone(\"abbreviated\", sCalendarType);\n  this.oFlexibleDayPeriodsNarrowSt = this.oLocaleData.getFlexibleDayPeriodsStandAlone(\"narrow\", sCalendarType);\n  this.oFlexibleDayPeriodsWideSt = this.oLocaleData.getFlexibleDayPeriodsStandAlone(\"wide\", sCalendarType);\n  this.aFormatArray = this.parseCldrDatePattern(this.oFormatOptions.pattern);\n  this.sAllowedCharacters = this.getAllowedCharacters(this.aFormatArray);\n};\n\n/**\n * Creates DateFormat instances based on the given format options. The created\n * instances are used as fallback formats of another DateFormat instances.\n *\n * @param {Object[]} aFallbackFormatOptions the options for creating the fallback DateFormat\n * @param {sap.ui.core.CalendarType} sCalendarType the type of the current calendarType\n * @param {sap.ui.core.Locale} oLocale Locale to ask for locale specific texts/settings\n * @param {Object} oInfo The default info object of the current date type\n * @param {object} oParentFormatOptions the format options, relevant are: interval, showDate, showTime and showTimezone\n * @return {sap.ui.core.DateFormat[]} an array of fallback DateFormat instances\n * @private\n */\nDateFormat._createFallbackFormat = function (aFallbackFormatOptions, sCalendarType, oLocale, oInfo, oParentFormatOptions) {\n  return aFallbackFormatOptions.map(function (oOptions) {\n    // The format options within the aFallbackFormatOptions array are static\n    // and shouldn't be manipulated. Hence, cloning each format option is required.\n    var oFormatOptions = Object.assign({}, oOptions);\n\n    // Pass the showDate, showTime and showTimezone format options to the fallback instance.\n    oFormatOptions.showDate = oParentFormatOptions.showDate;\n    oFormatOptions.showTime = oParentFormatOptions.showTime;\n    oFormatOptions.showTimezone = oParentFormatOptions.showTimezone;\n\n    // the timezone instance's fallback patterns depend on the showDate, showTime and\n    // showTimezone format option which means they cannot be static,\n    // therefore they are generated using the getTimezonePattern function\n    if (typeof oInfo.getTimezonePattern === \"function\" && oFormatOptions.pattern) {\n      oFormatOptions.pattern = oInfo.getTimezonePattern(oFormatOptions.pattern);\n    }\n    if (oParentFormatOptions.interval) {\n      oFormatOptions.interval = true;\n    }\n    oFormatOptions.calendarType = sCalendarType;\n    return DateFormat.createInstance(oFormatOptions, oLocale, oInfo, true);\n  });\n};\n\n/**\n * Creates options for fallback DateFormat instance by removing all delimiters\n * from the given base pattern.\n *\n * @param {string} sBasePattern The pattern where the result pattern will be\n * generated by removing the delimiters\n * @return {Object} Format option object which contains the new pattern\n */\nDateFormat._createFallbackOptionsWithoutDelimiter = function (sBasePattern) {\n  var rNonDateFields = /[^dMyGU]/g,\n    oDayReplace = {\n      regex: /d+/g,\n      replace: \"dd\"\n    },\n    oMonthReplace = {\n      regex: /M+/g,\n      replace: \"MM\"\n    },\n    oYearReplace = {\n      regex: /[yU]+/g,\n      replace: [\"yyyy\", \"yy\"]\n    };\n  sBasePattern = sBasePattern.replace(rNonDateFields, \"\"); //remove all delimiters\n  sBasePattern = sBasePattern.replace(oDayReplace.regex, oDayReplace.replace); // replace day entries with 2 digits\n  sBasePattern = sBasePattern.replace(oMonthReplace.regex, oMonthReplace.replace); // replace month entries with 2 digits\n\n  return oYearReplace.replace.map(function (sReplace) {\n    return {\n      pattern: sBasePattern.replace(oYearReplace.regex, sReplace),\n      strictParsing: true\n    };\n  });\n};\nvar oParseHelper = {\n  isNumber: function (iCharCode) {\n    return iCharCode >= 48 && iCharCode <= 57;\n  },\n  findNumbers: function (sValue, iMaxLength) {\n    var iLength = 0;\n    while (iLength < iMaxLength && this.isNumber(sValue.charCodeAt(iLength))) {\n      iLength++;\n    }\n    return sValue.substr(0, iLength);\n  },\n  /**\n   * Returns if the given string starts with another given string ignoring the case.\n   *\n   * Takes the locale into account to ensure the characters are interpreted the right way.\n   *\n   * First, an exact case check is performed to remain backward compatible, then a case-insensitive check\n   * based on the locale is done.\n   *\n   * When during the case conversion the length of the string changes we cannot safely match\n   * it and return <code>false</code>.\n   *\n   * @param {string} sValue the value to check, e.g. \"März 2013\"\n   * @param {string} sSubstring the string to compare it with, e.g. \"MÄRZ\"\n   * @param {string} sLocale the locale, e.g. \"de-DE\"\n   * @returns {boolean} true if the given string <code>sValue</code> starts with <code>sSubstring</code>\n   * @private\n   */\n  startsWithIgnoreCase: function (sValue, sSubstring, sLocale) {\n    // exact case comparison (backward compatible)\n    if (sValue.startsWith(sSubstring)) {\n      return true;\n    }\n    try {\n      // Use String#toLocaleUpperCase instead of String#toLocaleLowerCase because there\n      // are known cases where an upper case letter has 2 lower case variants, e.g. Greek sigma.\n      var sSubToLocaleUpperCase = sSubstring.toLocaleUpperCase(sLocale);\n      var sValueUpperCase = sValue.toLocaleUpperCase(sLocale);\n\n      // During the upper-case conversion there are cases where length changes, e.g. ß -> SS.\n      // This cannot be properly determined without probing therefore we do not support this case.\n      if (sSubToLocaleUpperCase.length !== sSubstring.length || sValueUpperCase.length !== sValue.length) {\n        return false;\n      }\n      return sValueUpperCase.startsWith(sSubToLocaleUpperCase);\n    } catch (e) {\n      // Can fail for String#toLocaleUpperCase with an invalid locale\n      // the API fails in the case with: Incorrect locale information provided\n      return false;\n    }\n  },\n  /**\n   * Finds the longest matching entry for which the following applies:\n   * * <code>sValue</code> starts with the found entry\n   *\n   * The index of the finding in <code>aList</code> and the length of the match is returned.\n   * The case is ignored and the given locale is used for the string comparison.\n   *\n   * @example\n   * findEntry(\"MÄRZ 2013\", [\"Januar\", \"Februar\", \"März\", \"April\", ...], \"de-DE\");\n   * // {length: 4, index: 2}\n   * @example\n   * findEntry(\"Sep 2013\", [..., \"Aug\", [\"Sept\", \"Sep\"], \"Oct\", ...], \"en-GB\");\n   * // {length: 3, index: 8}\n   *\n   * @param {string} sValue the input value, e.g. \"MÄRZ 2013\"\n   * @param {string[]|Array<string[]>} aList\n   *   The list of values to check, e.g. [\"Januar\", \"Februar\", \"März\", \"April\", ...]; the list may contain also\n   *   arrays of strings containing alternatives, e.g. [..., \"Aug\", [\"Sept\", \"Sep\"], \"Oct\", ...]\n   * @param {string} sLocale the locale which is used for the string comparison, e.g. \"de-DE\"\n   * @returns {{length: number, index: number}} the length of the match in sValue, the index in the list of values\n   *   e.g. length: 4, index: 2 (\"MÄRZ\")\n   * @private\n   */\n  findEntry: function (sValue, aList, sLocale) {\n    let iFoundIndex = -1;\n    let iMatchedLength = 0;\n    aList.forEach((vEntry, j) => {\n      (Array.isArray(vEntry) ? vEntry : [vEntry]).forEach(sEntry => {\n        if (sEntry.length > iMatchedLength && this.startsWithIgnoreCase(sValue, sEntry, sLocale)) {\n          iFoundIndex = j;\n          iMatchedLength = sEntry.length;\n        }\n      });\n    });\n    return {\n      index: iFoundIndex,\n      length: iMatchedLength\n    };\n  },\n  /**\n   * Parses a given timezone\n   *\n   * @param {string} sValue String to parse, e.g. \"-0800\", \"-08:00\", \"-08\"\n   * @param {boolean} bColonSeparated Whether or not the values are colon separated, e.g. \"-08:00\"\n   * @returns {{tzDiff: number, length: number}} Object containing the timezone difference in seconds and the length of the parsed segment\n   */\n  parseTZ: function (sValue, bColonSeparated) {\n    var iLength = 0;\n    var iTZFactor = sValue.charAt(0) === \"+\" ? -1 : 1;\n    var sPart;\n    if (sValue[0] === \"Z\") {\n      return {\n        length: 1,\n        tzDiff: 0\n      };\n    }\n    iLength++; //\"+\" or \"-\"\n    sPart = this.findNumbers(sValue.substr(iLength), 2);\n    var iTZDiffHour = parseInt(sPart);\n    iLength += 2; //hh: 2 digits for hours\n\n    if (bColonSeparated) {\n      iLength++; //\":\"\n    }\n    sPart = this.findNumbers(sValue.substr(iLength), 2);\n    var iTZDiff = 0;\n    // timezone pattern \"X\": will produce only 2 digits: \"-08\"\n    if (sPart) {\n      iLength += 2; //mm: 2 digits for minutes\n      iTZDiff = parseInt(sPart);\n    }\n    return {\n      length: iLength,\n      tzDiff: (iTZDiff + 60 * iTZDiffHour) * 60 * iTZFactor\n    };\n  },\n  /**\n   * Returns <code>false</code> if the given pattern symbol name is required and the value for that part is\n   * invalid, otherwise <code>true</code> is returned.\n   *\n   * @param {string} sSymbolName\n   *   A unique pattern symbol name\n   * @param {boolean} bPartInvalid\n   *   Whether the value for the given pattern symbol name is invalid\n   * @param {sap.ui.core.format.DateFormat} oFormat\n   *   The <code>DateFormat</code> instance\n   * @returns {boolean}\n   *   <code>false</code> if the given pattern symbol name is required and the value for that part is invalid,\n   *   otherwise <code>true</code>\n   */\n  checkValid: function (sSymbolName, bPartInvalid, oFormat) {\n    if (sSymbolName in oFormat.oRequiredParts && bPartInvalid) {\n      return false;\n    }\n    return true;\n  }\n};\nDateFormat._oParseHelper = oParseHelper; // make parse helper a private static member for testing\n\n/**\n * Creates a pattern symbol object containing all needed functions to be used for formatting and parsing.\n * Functions which are not given in <code>mParameters</code> are provided with a default implementation.\n *\n * @param {Object<string,any>} mParameters\n *   A parameters map for creating a pattern symbol\n * @param {string} mParameters.name\n *   An internal unique name describing this symbol\n * @param {function(Object<string, any>, sap.ui.core.date.UniversalDate, boolean, sap.ui.core.format.DateFormat,\n *     string): string} [mParameters.format]\n *   A function to format the symbol part based on a given date object\n * @param {function(string, Object<string, any>, sap.ui.core.format.DateFormat, object, string): object}\n *     [mParameters.parse]\n *   A function to parse the symbol part based on a given date string\n * @param {boolean|function(int): boolean} [mParameters.isNumeric]\n *   A boolean to describe, or a function to evaluate, whether the pattern symbol expects a\n *   numeric representation. For example pattern \"MM\" results in \"02\" and is therefore numeric,\n *   but \"MMM\" results in \"Feb\" which is not numeric.\n * @returns {{name: string, format: function, parse: function, isNumeric: function}}\n *   A pattern symbol object\n *\n * @private\n */\nDateFormat._createPatternSymbol = function (mParameters) {\n  var fnIsNumeric = typeof mParameters.isNumeric === \"function\" && mParameters.isNumeric\n  // Default: false\n  || function () {\n    return mParameters.isNumeric || false;\n  };\n  return {\n    name: mParameters.name,\n    /**\n     * Formatter for a pattern symbol.\n     *\n     * @param {Object<string, any>} oField\n     *   The date pattern field as parsed by {@link DateFormat#parseCldrDatePattern}\n     * @param {sap.ui.core.date.UniversalDate} oDate\n     *   The date object to format\n     * @param {boolean} bUTC\n     *   Whether the UTC option is set\n     * @param {sap.ui.core.format.DateFormat} oFormat\n     *   The <code>DateFormat</code> instance\n     * @returns {string}\n     *   The formatted date information for this date pattern part\n     */\n    format: mParameters.format\n    // not supported, but reserved\n    || function () {\n      return \"\";\n    },\n    /**\n     * Parser for a pattern symbol.\n     *\n     * @param {string} sValue\n     *   The given input\n     * @param {Object<string, any>} oPart\n     *   The date pattern field as parsed by {@link DateFormat#parseCldrDatePattern}\n     * @param {sap.ui.core.format.DateFormat} oFormat\n     *   The <code>DateFormat</code> instance\n     * @param {object} oConfig\n     *   The configuration object for parsing the value\n     * @param {object} oConfig.dateValue\n     *   The already parsed date fields\n     * @param {boolean} oConfig.exactLength\n     *   Whether parsing with the exact length specified by {@link DateFormat#parseCldrDatePattern} is needed\n     * @param {object[]} oConfig.formatArray\n     *   The complete format array as parsed by {@link DateFormat#parseCldrDatePattern}\n     * @param {int} oConfig.index\n     *   The current index in the format array\n     * @param {boolean} oConfig.strict\n     *   Whether to disallow overflows for component values of a date (see\n     *   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/Date).\n     *   Note that the corresponding checks are just for number ranges which are possible <em>at max</em>\n     *   without overflow; the check for day does not consider the month and year to compute the maximum\n     *   number of days allowed.\n     * @param {string} sTimezone\n     *   The IANA timezone ID\n     * @returns {object}\n     *   The parsed date information for this date pattern part; could contain the property <code>valid</code>\n     *   set to <code>false</code> if parsing was not successful\n     */\n    parse: mParameters.parse\n    // not supported, but reserved\n    || function () {\n      return {};\n    },\n    /**\n     * Evaluates whether this symbol has a numeric representation.\n     *\n     * @param {int} [iDigits] The number of repetitions of the pattern symbol, e.g. <code>3</code> for \"aaa\"\n     * @returns {boolean} Whether this symbol has a numeric representation\n     */\n    isNumeric: fnIsNumeric\n  };\n};\n\n/**\n * Provides functionality to format and parse a given pattern symbol.\n * @see https://unicode.org/reports/tr35/tr35-dates.html#table-date-field-symbol-table\n */\nDateFormat.prototype.oSymbols = {\n  \"\": DateFormat._createPatternSymbol({\n    name: \"text\",\n    format: function (oField, oDate) {\n      return oField.value;\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var sChar;\n      var bValid = true;\n      var iValueIndex = 0;\n      var iPatternIndex = 0;\n      // https://www.compart.com/en/unicode/category/Pd\n      var sDelimiter = \"\\u002d\\u007E\\u2010\\u2011\\u2012\\u2013\\u2014\\ufe58\\ufe63\\uff0d\\uFF5E\";\n\n      // Compare the letters in oPart.value (the pattern) and sValue (the given string to parse)\n      // one by one.\n      // If the current letter in the pattern is \" \", sValue is allowed to have no match, exact match\n      // or multiple \" \". This makes the parsing more tolerant. Special spaces or RTL characters have\n      // to be normalized before comparison.\n      const sPartValue = DateFormat._normalize(oPart.value);\n      for (; iPatternIndex < sPartValue.length; iPatternIndex++) {\n        sChar = sPartValue.charAt(iPatternIndex);\n        if (sChar === \" \") {\n          // allows to have multiple spaces\n          while (sValue.charAt(iValueIndex) === \" \") {\n            iValueIndex++;\n          }\n        } else if (sDelimiter.includes(sChar)) {\n          if (!sDelimiter.includes(sValue.charAt(iValueIndex))) {\n            bValid = false;\n          }\n          iValueIndex++;\n        } else {\n          if (sValue.charAt(iValueIndex) !== sChar) {\n            // if it's not a space, there must be an exact match\n            bValid = false;\n          }\n          iValueIndex++;\n        }\n        if (!bValid) {\n          break;\n        }\n      }\n      if (bValid) {\n        return {\n          length: iValueIndex\n        };\n      } else {\n        var bPartInvalid = false;\n\n        // only require text, if next part is also required\n        if (oConfig.index < oConfig.formatArray.length - 1) {\n          bPartInvalid = oConfig.formatArray[oConfig.index + 1].type in oFormat.oRequiredParts;\n        }\n        return {\n          valid: oParseHelper.checkValid(oPart.type, bPartInvalid, oFormat)\n        };\n      }\n    }\n  }),\n  \"G\": DateFormat._createPatternSymbol({\n    name: \"era\",\n    format: function (oField, oDate, bUTC, oFormat) {\n      var iEra = oDate.getUTCEra();\n      if (oField.digits <= 3) {\n        return oFormat.aErasAbbrev[iEra];\n      } else if (oField.digits === 4) {\n        return oFormat.aErasWide[iEra];\n      } else {\n        return oFormat.aErasNarrow[iEra];\n      }\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var aErasVariants = [oFormat.aErasWide, oFormat.aErasAbbrev, oFormat.aErasNarrow];\n      for (var i = 0; i < aErasVariants.length; i++) {\n        var aVariants = aErasVariants[i];\n        var oFound = oParseHelper.findEntry(sValue, aVariants, oFormat.oLocaleData.sCLDRLocaleId);\n        if (oFound.index !== -1) {\n          return {\n            era: oFound.index,\n            length: oFound.length\n          };\n        }\n      }\n      return {\n        era: oFormat.aErasWide.length - 1,\n        valid: oParseHelper.checkValid(oPart.type, true, oFormat)\n      };\n    }\n  }),\n  \"y\": DateFormat._createPatternSymbol({\n    name: \"year\",\n    format: function (oField, oDate, bUTC, oFormat) {\n      var iYear = oDate.getUTCFullYear();\n      var sYear = String(iYear);\n      var sCalendarType = oFormat.oFormatOptions.calendarType;\n      if (oField.digits === 2 && sYear.length > 2) {\n        sYear = sYear.substr(sYear.length - 2);\n      }\n      // When parsing we assume dates less than 100 to be in the current/last century,\n      // so when formatting we have to make sure they are differentiable by prefixing with zeros\n      if (sCalendarType !== CalendarType.Japanese && oField.digits === 1 && iYear < 100) {\n        sYear = sYear.padStart(4, \"0\");\n      }\n      return sYear.padStart(oField.digits, \"0\");\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var iExpectedDigits,\n        sPart,\n        bPartInvalid,\n        sCalendarType = oFormat.oFormatOptions.calendarType;\n      if (oPart.digits === 1) {\n        iExpectedDigits = 4;\n      } else if (oPart.digits === 2) {\n        iExpectedDigits = 2;\n      } else {\n        iExpectedDigits = oPart.digits;\n      }\n      sPart = oParseHelper.findNumbers(sValue, iExpectedDigits);\n      bPartInvalid = sPart === \"\" || oConfig.exactLength && sPart.length !== iExpectedDigits;\n      var iYear = parseInt(sPart);\n      // Find the right century for two-digit years\n      // https://tc39.es/ecma262/#sec-date.parse\n      // \"The function first attempts to parse the String according to the format\n      // described in Date Time String Format (https://tc39.es/ecma262/#sec-date-time-string-format),\n      // including expanded years.\n      // If the String does not conform to that format the function may fall back to\n      // any implementation-specific heuristics or implementation-specific date formats.\"\n      //\n      // Since a two-digit year is not format conform, each JS implementations might differ.\n      // Therefore we provide an own implementation:\n\n      // current year: 1978\n      // 1978: 08 = 1908 (diff: -70)\n      // 1978: 07 = 2007 (diff: -71)\n\n      // current year: 2018\n      // 2018: 48 = 1948 (diff: 30)\n      // 2018: 47 = 2047 (diff: 29)\n      if (sCalendarType !== CalendarType.Japanese && sPart.length <= 2) {\n        var oCurrentDate = UniversalDate.getInstance(UI5Date.getInstance(), sCalendarType),\n          iCurrentYear = oCurrentDate.getUTCFullYear(),\n          iCurrentCentury = Math.floor(iCurrentYear / 100),\n          iYearDiff = iCurrentCentury * 100 + iYear - iCurrentYear;\n        if (iYearDiff < -70) {\n          iYear += (iCurrentCentury + 1) * 100;\n        } else if (iYearDiff < 30) {\n          iYear += iCurrentCentury * 100;\n        } else {\n          iYear += (iCurrentCentury - 1) * 100;\n        }\n      }\n      return {\n        length: sPart.length,\n        valid: oParseHelper.checkValid(oPart.type, bPartInvalid, oFormat),\n        year: iYear\n      };\n    },\n    isNumeric: true\n  }),\n  \"Y\": DateFormat._createPatternSymbol({\n    name: \"weekYear\",\n    format: function (oField, oDate, bUTC, oFormat) {\n      var oWeek = oDate.getUTCWeek(oFormat.oLocale, getCalendarWeekParameter(oFormat.oFormatOptions));\n      var iWeekYear = oWeek.year;\n      var sWeekYear = String(iWeekYear);\n      var sCalendarType = oFormat.oFormatOptions.calendarType;\n      if (oField.digits === 2 && sWeekYear.length > 2) {\n        sWeekYear = sWeekYear.substr(sWeekYear.length - 2);\n      }\n      // When parsing we assume dates less than 100 to be in the current/last century,\n      // so when formatting we have to make sure they are differentiable by prefixing with zeros\n      if (sCalendarType !== CalendarType.Japanese && oField.digits === 1 && iWeekYear < 100) {\n        sWeekYear = sWeekYear.padStart(4, \"0\");\n      }\n      return sWeekYear.padStart(oField.digits, \"0\");\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var iExpectedDigits,\n        sPart,\n        bPartInvalid,\n        sCalendarType = oFormat.oFormatOptions.calendarType;\n      if (oPart.digits === 1) {\n        iExpectedDigits = 4;\n      } else if (oPart.digits === 2) {\n        iExpectedDigits = 2;\n      } else {\n        iExpectedDigits = oPart.digits;\n      }\n      sPart = oParseHelper.findNumbers(sValue, iExpectedDigits);\n      bPartInvalid = sPart === \"\" || oConfig.exactLength && sPart.length !== iExpectedDigits;\n      var iYear = parseInt(sPart);\n      var iWeekYear = iYear;\n      // Find the right century for two-digit years\n      if (sCalendarType !== CalendarType.Japanese && sPart.length <= 2) {\n        var oCurrentDate = UniversalDate.getInstance(UI5Date.getInstance(), sCalendarType),\n          iCurrentYear = oCurrentDate.getUTCFullYear(),\n          iCurrentCentury = Math.floor(iCurrentYear / 100),\n          iYearDiff = iCurrentCentury * 100 + iWeekYear - iCurrentYear;\n        if (iYearDiff < -70) {\n          iWeekYear += (iCurrentCentury + 1) * 100;\n        } else if (iYearDiff < 30) {\n          iWeekYear += iCurrentCentury * 100;\n        } else {\n          iWeekYear += (iCurrentCentury - 1) * 100;\n        }\n      }\n      return {\n        length: sPart.length,\n        valid: oParseHelper.checkValid(oPart.type, bPartInvalid, oFormat),\n        year: iYear,\n        weekYear: iWeekYear\n      };\n    },\n    isNumeric: true\n  }),\n  \"M\": DateFormat._createPatternSymbol({\n    name: \"month\",\n    format: function (oField, oDate, bUTC, oFormat) {\n      var iMonth = oDate.getUTCMonth();\n      if (oField.digits === 3) {\n        const vName = oFormat.aMonthsAbbrev[iMonth]; // vName may be an array if there are alternatives\n        return Array.isArray(vName) ? vName[0] : vName;\n      } else if (oField.digits === 4) {\n        return oFormat.aMonthsWide[iMonth];\n      } else if (oField.digits > 4) {\n        return oFormat.aMonthsNarrow[iMonth];\n      } else {\n        return String(iMonth + 1).padStart(oField.digits, \"0\");\n      }\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var iMonth,\n        sPart,\n        bPartInvalid,\n        bValid,\n        aMonthsVariants = [oFormat.aMonthsWide, oFormat.aMonthsWideSt, oFormat.aMonthsAbbrev, oFormat.aMonthsAbbrevSt, oFormat.aMonthsNarrow, oFormat.aMonthsNarrowSt];\n      if (oPart.digits < 3) {\n        sPart = oParseHelper.findNumbers(sValue, Math.max(oPart.digits, 2));\n        bPartInvalid = sPart === \"\" || oConfig.exactLength && sPart.length < 2;\n        bValid = oParseHelper.checkValid(oPart.type, bPartInvalid, oFormat);\n        iMonth = parseInt(sPart) - 1;\n        if (oConfig.strict && (iMonth > 11 || iMonth < 0)) {\n          bValid = false;\n        }\n      } else {\n        for (var i = 0; i < aMonthsVariants.length; i++) {\n          var aVariants = aMonthsVariants[i];\n          var oFound = oParseHelper.findEntry(sValue, aVariants, oFormat.oLocaleData.sCLDRLocaleId);\n          if (oFound.index !== -1) {\n            return {\n              month: oFound.index,\n              length: oFound.length\n            };\n          }\n        }\n        bValid = oParseHelper.checkValid(oPart.type, true, oFormat);\n      }\n      return {\n        month: iMonth,\n        length: sPart ? sPart.length : 0,\n        valid: bValid\n      };\n    },\n    isNumeric: function (iDigits) {\n      return iDigits < 3;\n    }\n  }),\n  \"L\": DateFormat._createPatternSymbol({\n    name: \"monthStandalone\",\n    format: function (oField, oDate, bUTC, oFormat) {\n      var iMonth = oDate.getUTCMonth();\n      if (oField.digits === 3) {\n        const vName = oFormat.aMonthsAbbrevSt[iMonth]; // vName may be an array if there are alternatives\n        return Array.isArray(vName) ? vName[0] : vName;\n      } else if (oField.digits === 4) {\n        return oFormat.aMonthsWideSt[iMonth];\n      } else if (oField.digits > 4) {\n        return oFormat.aMonthsNarrowSt[iMonth];\n      } else {\n        return String(iMonth + 1).padStart(oField.digits, \"0\");\n      }\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var iMonth,\n        sPart,\n        bPartInvalid,\n        bValid,\n        aMonthsVariants = [oFormat.aMonthsWide, oFormat.aMonthsWideSt, oFormat.aMonthsAbbrev, oFormat.aMonthsAbbrevSt, oFormat.aMonthsNarrow, oFormat.aMonthsNarrowSt];\n      if (oPart.digits < 3) {\n        sPart = oParseHelper.findNumbers(sValue, Math.max(oPart.digits, 2));\n        bPartInvalid = sPart === \"\" || oConfig.exactLength && sPart.length < 2;\n        bValid = oParseHelper.checkValid(oPart.type, bPartInvalid, oFormat);\n        iMonth = parseInt(sPart) - 1;\n        if (oConfig.strict && (iMonth > 11 || iMonth < 0)) {\n          bValid = false;\n        }\n      } else {\n        for (var i = 0; i < aMonthsVariants.length; i++) {\n          var aVariants = aMonthsVariants[i];\n          var oFound = oParseHelper.findEntry(sValue, aVariants, oFormat.oLocaleData.sCLDRLocaleId);\n          if (oFound.index !== -1) {\n            return {\n              month: oFound.index,\n              length: oFound.length\n            };\n          }\n        }\n        bValid = oParseHelper.checkValid(oPart.type, true, oFormat);\n      }\n      return {\n        month: iMonth,\n        length: sPart ? sPart.length : 0,\n        valid: bValid\n      };\n    },\n    isNumeric: function (iDigits) {\n      return iDigits < 3;\n    }\n  }),\n  \"w\": DateFormat._createPatternSymbol({\n    name: \"weekInYear\",\n    format: function (oField, oDate, bUTC, oFormat) {\n      var oWeek = oDate.getUTCWeek(oFormat.oLocale, getCalendarWeekParameter(oFormat.oFormatOptions));\n      var iWeek = oWeek.week;\n      var sWeek = String(iWeek + 1);\n      if (oField.digits < 3) {\n        sWeek = sWeek.padStart(oField.digits, \"0\");\n      } else {\n        sWeek = oFormat.oLocaleData.getCalendarWeek(oField.digits === 3 ? \"narrow\" : \"wide\", sWeek.padStart(2, \"0\"));\n      }\n      return sWeek;\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var sPart,\n        bPartInvalid,\n        bValid,\n        iWeek,\n        iLength = 0;\n      if (oPart.digits < 3) {\n        sPart = oParseHelper.findNumbers(sValue, 2);\n        iLength = sPart.length;\n        iWeek = parseInt(sPart) - 1;\n        bPartInvalid = !sPart || oConfig.exactLength && iLength < 2;\n        bValid = oParseHelper.checkValid(oPart.type, bPartInvalid, oFormat);\n      } else {\n        sPart = oFormat.oLocaleData.getCalendarWeek(oPart.digits === 3 ? \"narrow\" : \"wide\");\n        sPart = sPart.replace(\"{0}\", \"([0-9]+)\");\n        var rWeekNumber = new RegExp(sPart),\n          oResult = rWeekNumber.exec(sValue);\n        if (oResult) {\n          // e.g. for input \"CW 01\" create pattern \"CW ([0-9]+)\"\n          // and extract number from \"01\" part of the input\n          iLength = oResult[0].length;\n          iWeek = parseInt(oResult[oResult.length - 1]) - 1;\n        } else {\n          bValid = oParseHelper.checkValid(oPart.type, true, oFormat);\n        }\n      }\n      return {\n        length: iLength,\n        valid: bValid,\n        week: iWeek\n      };\n    },\n    isNumeric: function (iDigits) {\n      return iDigits < 3;\n    }\n  }),\n  \"W\": DateFormat._createPatternSymbol({\n    name: \"weekInMonth\"\n  }),\n  \"D\": DateFormat._createPatternSymbol({\n    name: \"dayInYear\"\n  }),\n  \"d\": DateFormat._createPatternSymbol({\n    name: \"day\",\n    format: function (oField, oDate) {\n      var iDate = oDate.getUTCDate();\n      return String(iDate).padStart(oField.digits, \"0\");\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var sPart = oParseHelper.findNumbers(sValue, Math.max(oPart.digits, 2)),\n        bPartInvalid = sPart === \"\" || oConfig.exactLength && sPart.length < 2,\n        bValid = oParseHelper.checkValid(oPart.type, bPartInvalid, oFormat),\n        iDay = parseInt(sPart);\n      if (oConfig.strict && (iDay > 31 || iDay < 1)) {\n        bValid = false;\n      }\n      return {\n        day: iDay,\n        length: sPart.length,\n        valid: bValid\n      };\n    },\n    isNumeric: true\n  }),\n  \"Q\": DateFormat._createPatternSymbol({\n    name: \"quarter\",\n    format: function (oField, oDate, bUTC, oFormat) {\n      var iQuarter = oDate.getUTCQuarter();\n      if (oField.digits === 3) {\n        return oFormat.aQuartersAbbrev[iQuarter];\n      } else if (oField.digits === 4) {\n        return oFormat.aQuartersWide[iQuarter];\n      } else if (oField.digits > 4) {\n        return oFormat.aQuartersNarrow[iQuarter];\n      } else {\n        return String(iQuarter + 1).padStart(oField.digits, \"0\");\n      }\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var sPart, bPartInvalid, iQuarter, bValid;\n      var aQuartersVariants = [oFormat.aQuartersWide, oFormat.aQuartersWideSt, oFormat.aQuartersAbbrev, oFormat.aQuartersAbbrevSt, oFormat.aQuartersNarrow, oFormat.aQuartersNarrowSt];\n      if (oPart.digits < 3) {\n        sPart = oParseHelper.findNumbers(sValue, Math.max(oPart.digits, 2));\n        bPartInvalid = sPart === \"\" || oConfig.exactLength && sPart.length < 2;\n        bValid = oParseHelper.checkValid(oPart.type, bPartInvalid, oFormat);\n        iQuarter = parseInt(sPart) - 1;\n        if (oConfig.strict && iQuarter > 3) {\n          bValid = false;\n        }\n      } else {\n        for (var i = 0; i < aQuartersVariants.length; i++) {\n          var aVariants = aQuartersVariants[i];\n          var oFound = oParseHelper.findEntry(sValue, aVariants, oFormat.oLocaleData.sCLDRLocaleId);\n          if (oFound.index !== -1) {\n            return {\n              quarter: oFound.index,\n              length: oFound.length\n            };\n          }\n        }\n        bValid = oParseHelper.checkValid(oPart.type, true, oFormat);\n      }\n      return {\n        length: sPart ? sPart.length : 0,\n        quarter: iQuarter,\n        valid: bValid\n      };\n    },\n    isNumeric: function (iDigits) {\n      return iDigits < 3;\n    }\n  }),\n  \"q\": DateFormat._createPatternSymbol({\n    name: \"quarterStandalone\",\n    format: function (oField, oDate, bUTC, oFormat) {\n      var iQuarter = oDate.getUTCQuarter();\n      if (oField.digits === 3) {\n        return oFormat.aQuartersAbbrevSt[iQuarter];\n      } else if (oField.digits === 4) {\n        return oFormat.aQuartersWideSt[iQuarter];\n      } else if (oField.digits > 4) {\n        return oFormat.aQuartersNarrowSt[iQuarter];\n      } else {\n        return String(iQuarter + 1).padStart(oField.digits, \"0\");\n      }\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var sPart, bPartInvalid, iQuarter, bValid;\n      var aQuartersVariants = [oFormat.aQuartersWide, oFormat.aQuartersWideSt, oFormat.aQuartersAbbrev, oFormat.aQuartersAbbrevSt, oFormat.aQuartersNarrow, oFormat.aQuartersNarrowSt];\n      if (oPart.digits < 3) {\n        sPart = oParseHelper.findNumbers(sValue, Math.max(oPart.digits, 2));\n        bPartInvalid = sPart === \"\" || oConfig.exactLength && sPart.length < 2;\n        bValid = oParseHelper.checkValid(oPart.type, bPartInvalid, oFormat);\n        iQuarter = parseInt(sPart) - 1;\n        if (oConfig.strict && iQuarter > 3) {\n          bValid = false;\n        }\n      } else {\n        for (var i = 0; i < aQuartersVariants.length; i++) {\n          var aVariants = aQuartersVariants[i];\n          var oFound = oParseHelper.findEntry(sValue, aVariants, oFormat.oLocaleData.sCLDRLocaleId);\n          if (oFound.index !== -1) {\n            return {\n              quarter: oFound.index,\n              length: oFound.length\n            };\n          }\n        }\n        bValid = oParseHelper.checkValid(oPart.type, true, oFormat);\n      }\n      return {\n        length: sPart ? sPart.length : 0,\n        quarter: iQuarter,\n        valid: bValid\n      };\n    },\n    isNumeric: function (iDigits) {\n      return iDigits < 3;\n    }\n  }),\n  \"F\": DateFormat._createPatternSymbol({\n    name: \"dayOfWeekInMonth\"\n  }),\n  \"E\": DateFormat._createPatternSymbol({\n    name: \"dayNameInWeek\",\n    //Day of week name, format style.\n    format: function (oField, oDate, bUTC, oFormat) {\n      var iDay = oDate.getUTCDay();\n      if (oField.digits < 4) {\n        return oFormat.aDaysAbbrev[iDay];\n      } else if (oField.digits === 4) {\n        return oFormat.aDaysWide[iDay];\n      } else if (oField.digits === 5) {\n        return oFormat.aDaysNarrow[iDay];\n      } else {\n        return oFormat.aDaysShort[iDay];\n      }\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var aDaysVariants = [oFormat.aDaysWide, oFormat.aDaysWideSt, oFormat.aDaysAbbrev, oFormat.aDaysAbbrevSt, oFormat.aDaysShort, oFormat.aDaysShortSt, oFormat.aDaysNarrow, oFormat.aDaysNarrowSt];\n      for (var i = 0; i < aDaysVariants.length; i++) {\n        var aVariants = aDaysVariants[i];\n        var oFound = oParseHelper.findEntry(sValue, aVariants, oFormat.oLocaleData.sCLDRLocaleId);\n        if (oFound.index !== -1) {\n          return {\n            // gets translated to dayOfWeek where the day of week is relative to the week\n            dayOfWeek: oFound.index,\n            length: oFound.length\n          };\n        }\n      }\n    }\n  }),\n  \"c\": DateFormat._createPatternSymbol({\n    name: \"dayNameInWeekStandalone\",\n    format: function (oField, oDate, bUTC, oFormat) {\n      var iDay = oDate.getUTCDay();\n      if (oField.digits < 4) {\n        return oFormat.aDaysAbbrevSt[iDay];\n      } else if (oField.digits === 4) {\n        return oFormat.aDaysWideSt[iDay];\n      } else if (oField.digits === 5) {\n        return oFormat.aDaysNarrowSt[iDay];\n      } else {\n        return oFormat.aDaysShortSt[iDay];\n      }\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var aDaysVariants = [oFormat.aDaysWide, oFormat.aDaysWideSt, oFormat.aDaysAbbrev, oFormat.aDaysAbbrevSt, oFormat.aDaysShort, oFormat.aDaysShortSt, oFormat.aDaysNarrow, oFormat.aDaysNarrowSt];\n      for (var i = 0; i < aDaysVariants.length; i++) {\n        var aVariants = aDaysVariants[i];\n        var oFound = oParseHelper.findEntry(sValue, aVariants, oFormat.oLocaleData.sCLDRLocaleId);\n        if (oFound.index !== -1) {\n          return {\n            day: oFound.index,\n            length: oFound.length\n          };\n        }\n      }\n    }\n  }),\n  // day number of week (depends on locale's first day of week)\n  // e.g. Thursday\n  // \"de\": 4 (firstDay: 1)\n  // \"en\": 5 (firstDay: 0)\n  // \"ar\": 6 (firstDay: 6)\n  \"u\": DateFormat._createPatternSymbol({\n    name: \"dayNumberOfWeek\",\n    format: function (oField, oDate, bUTC, oFormat) {\n      var iDay = oDate.getUTCDay();\n      return oFormat._adaptDayOfWeek(iDay);\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var sPart = oParseHelper.findNumbers(sValue, oPart.digits),\n        bPartInvalid = oConfig.exactLength && sPart.length !== oPart.digits;\n      return {\n        dayNumberOfWeek: parseInt(sPart),\n        length: sPart.length,\n        valid: oParseHelper.checkValid(oPart.type, bPartInvalid, oFormat)\n      };\n    },\n    isNumeric: true\n  }),\n  \"a\": DateFormat._createPatternSymbol({\n    name: \"amPmMarker\",\n    /**\n     * Formats the day period.\n     *\n     * @param {Object<string, any>} oField\n     *   The date pattern field as parsed by {@link DateFormat#parseCldrDatePattern}\n     * @param {number} oField.digits\n     *   The number of repetitions of the pattern symbol, e.g. <code>3</code> for \"aaa\"\n     * @param {string} oField.symbol\n     *   The pattern symbol \"a\"\n     * @param {string} oField.type\n     *   The symbol name \"amPmMarker\"\n     * @param {sap.ui.core.date.UniversalDate} oDate\n     *   The date to format\n     * @param {boolean} [bUTC]\n     *   Whether the UTC option is set; not used\n     * @param {sap.ui.core.format.DateFormat} oFormat\n     *   The <code>DateFormat</code> instance\n     * @returns {string}\n     *   The formatted day period, e.g. \"AM\" for symbol \"a\"\n     */\n    format: function (oField, oDate, bUTC, oFormat) {\n      var iDayPeriod = oDate.getUTCDayPeriod();\n      if (oField.digits <= 3) {\n        return oFormat.aDayPeriodsAbbrev[iDayPeriod];\n      } else if (oField.digits === 4) {\n        return oFormat.aDayPeriodsWide[iDayPeriod];\n      } else {\n        return oFormat.aDayPeriodsNarrow[iDayPeriod];\n      }\n    },\n    /**\n     * Parses the day period from a given input string.\n     *\n     * @param {string} sValue\n     *   The given input, e.g. \"am 13:37\"\n     * @param {Object<string, any>} oPart\n     *   The date pattern field as parsed by {@link DateFormat#parseCldrDatePattern}\n     * @param {number} oPart.digits\n     *   The number of repetitions of the pattern symbol, e.g. <code>3</code> for \"aaa\"\n     * @param {string} oPart.symbol\n     *   The pattern symbol \"a\"\n     * @param {string} oPart.type\n     *   The symbol name \"amPmMarker\"\n     * @param {sap.ui.core.format.DateFormat} oFormat\n     *   The <code>DateFormat</code> instance\n     * @param {Object<string, any>} [oConfig]\n     *   The configuration object for parsing the value\n     * @param {object[]} [oConfig.formatArray]\n     *   The complete format array as parsed by {@link DateFormat#parseCldrDatePattern}\n     * @param {object} [oConfig.dateValue]\n     *   The already parsed date fields\n     * @param {number} [oConfig.index]\n     *   The index in the format array\n     * @param {boolean} [oConfig.strict]\n     *   Whether to use the strict option\n     * @param {string} [sTimezone]\n     *   The IANA timezone ID\n     * @returns {{length : number, pm : boolean}|{}}\n     *   An object with the <code>length</code> of the match and the parsed <code>pm</code>\n     *   value; or an object with property valid <code>false</code> if it could not be\n     *   parsed correctly\n     */\n    parse: function (sValue, oPart, oFormat, oConfig, sTimezone) {\n      // process longer patterns first to find the longest match\n      // wide > abbreviated > narrow\n      var rAMPM,\n        bAMPMAlternativeCase,\n        oEntry,\n        i,\n        aMatch,\n        aVariants,\n        aDayPeriodsVariants = [oFormat.aDayPeriodsWide, oFormat.aDayPeriodsAbbrev, oFormat.aDayPeriodsNarrow];\n\n      // Support ASCII alternative writings for AM/PM (when the locale has am/pm in its\n      // patterns), e.g. \"am\", \"a.m.\", \"am.\", \"a. m.\" (and their case alternatives)\n      // see: https://unicode.org/reports/tr35/tr35-dates.html#Parsing_Dates_Times\n      rAMPM = /[aApP](?:\\.)?[\\x20\\xA0]?[mM](?:\\.)?/;\n      aMatch = sValue.match(rAMPM);\n      bAMPMAlternativeCase = aMatch && aMatch.index === 0;\n      function removeSpacesAndDots(sValue) {\n        // Remove normal and non-breaking spaces and remove dots\n        return sValue.replace(/[\\x20\\xA0]/g, \"\").replace(/\\./g, \"\");\n      }\n      if (bAMPMAlternativeCase) {\n        sValue = removeSpacesAndDots(sValue);\n      }\n      for (i = 0; i < aDayPeriodsVariants.length; i += 1) {\n        aVariants = aDayPeriodsVariants[i].map(sDayPeriod => {\n          return DateFormat._normalize(sDayPeriod);\n        });\n        if (bAMPMAlternativeCase) {\n          // check normalized match for alternative case of am/pm\n          aVariants = aVariants.map(removeSpacesAndDots);\n        }\n        // check exact and case-insensitive match\n        oEntry = oParseHelper.findEntry(sValue, aVariants, oFormat.oLocaleData.sCLDRLocaleId);\n        if (oEntry.index !== -1) {\n          return {\n            pm: oEntry.index === 1,\n            // am/pm alternative may include an additional dot, e.g. \"am.\"\n            // therefore the length for the am/pm alternative is the length of the\n            // match\n            length: bAMPMAlternativeCase ? aMatch[0].length : oEntry.length\n          };\n        }\n      }\n      return {\n        valid: false\n      };\n    }\n  }),\n  \"B\": DateFormat._createPatternSymbol({\n    name: \"flexibleDayPeriod\",\n    /**\n     * Formats the flexible day period.\n     *\n     * @param {Object<string, any>} oField\n     *   The date pattern field as parsed by {@link DateFormat#parseCldrDatePattern}\n     * @param {int} oField.digits\n     *   The number of repetitions of the pattern symbol, e.g. <code>3</code> for \"BBB\"\n     * @param {sap.ui.core.date.UniversalDate} oDate\n     *   The date object to format\n     * @param {boolean} bUTC\n     *   Whether the UTC option is set; not used\n     * @param {sap.ui.core.format.DateFormat} oFormat\n     *   The <code>DateFormat</code> instance\n     * @returns {string}\n     *   The selected day period e.g. \"in the afternoon\" for the according style width\n     *   \"abbreviated\", \"narrow\" or \"wide\"\n     */\n    format: function (oField, oDate, bUTC, oFormat) {\n      // If no hours symbol is contained in the pattern, the stand-alone format must be\n      // used. Only non-input skeleton symbols are used. The pattern symbols for hour can\n      // be found under:\n      // https://unicode.org/reports/tr35/tr35-dates.html#dfst-hour\n      var bContainsHour = oFormat.aFormatArray.some(function (oFormatElement) {\n          return \"hHKk\".includes(oFormatElement.symbol);\n        }),\n        sFlexibleDayPeriod = oFormat.oLocaleData.getFlexibleDayPeriodOfTime(oDate.getUTCHours(), oDate.getUTCMinutes());\n      if (bContainsHour) {\n        if (oField.digits <= 3) {\n          return oFormat.oFlexibleDayPeriodsAbbrev[sFlexibleDayPeriod];\n        }\n        if (oField.digits === 4) {\n          return oFormat.oFlexibleDayPeriodsWide[sFlexibleDayPeriod];\n        }\n        return oFormat.oFlexibleDayPeriodsNarrow[sFlexibleDayPeriod];\n      }\n      if (oField.digits <= 3) {\n        return oFormat.oFlexibleDayPeriodsAbbrevSt[sFlexibleDayPeriod];\n      }\n      if (oField.digits === 4) {\n        return oFormat.oFlexibleDayPeriodsWideSt[sFlexibleDayPeriod];\n      }\n      return oFormat.oFlexibleDayPeriodsNarrowSt[sFlexibleDayPeriod];\n    },\n    /**\n     * Parses the flexible day period from a given input string.\n     *\n     * @param {string} sValue\n     *   The given input, e.g. \"in the afternoon 01:37\"\n     * @param {Object<string, any>} oPart\n     *   The date pattern field as parsed by {@link DateFormat#parseCldrDatePattern}\n     * @param {sap.ui.core.format.DateFormat} oFormat\n     *   The <code>DateFormat</code> instance\n     * @param {object} oConfig\n     *   The configuration object for parsing the value\n     * @returns {{flexDayPeriod: string, length: number}|{valid: boolean}}\n     *   An object with the parsed <code>flexDayPeriod</code> and the <code>length</code>\n     *   value of the match; otherwise, an object with property <code>valid</code>\n     *   <code>false</code> if it could not be parsed correctly or in case it is attempted\n     *   to parse a string with a stand-alone format\n     */\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var i,\n        oFound,\n        oVariant,\n        bContainsHour = oFormat.aFormatArray.some(function (oFormatElement) {\n          return \"hHKk\".includes(oFormatElement.symbol);\n        }),\n        // \"aFlexibleDayPeriodVariants\" is ordered from \"wide\" to \"narrow\" to find the\n        // longest match\n        aFlexibleDayPeriodVariants = [oFormat.oFlexibleDayPeriodsWide, oFormat.oFlexibleDayPeriodsAbbrev, oFormat.oFlexibleDayPeriodsNarrow];\n      if (bContainsHour) {\n        for (i = 0; i < aFlexibleDayPeriodVariants.length; i++) {\n          oVariant = aFlexibleDayPeriodVariants[i];\n          oFound = oParseHelper.findEntry(sValue, Object.values(oVariant), oFormat.oLocaleData.sCLDRLocaleId);\n          if (oFound.index !== -1) {\n            return {\n              flexDayPeriod: Object.keys(oVariant)[oFound.index],\n              length: oFound.length\n            };\n          }\n        }\n      }\n      return {\n        valid: false\n      };\n    }\n  }),\n  \"H\": DateFormat._createPatternSymbol({\n    name: \"hour0_23\",\n    format: function (oField, oDate) {\n      var iHours = oDate.getUTCHours();\n      return String(iHours).padStart(oField.digits, \"0\");\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var sPart = oParseHelper.findNumbers(sValue, Math.max(oPart.digits, 2)),\n        iHours = parseInt(sPart),\n        bPartInvalid = sPart === \"\" || oConfig.exactLength && sPart.length < 2,\n        bValid = oParseHelper.checkValid(oPart.type, bPartInvalid, oFormat);\n      if (oConfig.strict && iHours > 23) {\n        bValid = false;\n      }\n      return {\n        hour: iHours,\n        length: sPart.length,\n        valid: bValid\n      };\n    },\n    isNumeric: true\n  }),\n  \"k\": DateFormat._createPatternSymbol({\n    name: \"hour1_24\",\n    format: function (oField, oDate) {\n      var iHours = oDate.getUTCHours();\n      var sHours = iHours === 0 ? \"24\" : String(iHours);\n      return sHours.padStart(oField.digits, \"0\");\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var sPart = oParseHelper.findNumbers(sValue, Math.max(oPart.digits, 2)),\n        iHours = parseInt(sPart),\n        bPartInvalid = sPart === \"\" || oConfig.exactLength && sPart.length < 2,\n        bValid = oParseHelper.checkValid(oPart.type, bPartInvalid, oFormat);\n      if (iHours === 24) {\n        iHours = 0;\n      }\n      if (oConfig.strict && iHours > 23) {\n        bValid = false;\n      }\n      return {\n        hour: iHours,\n        length: sPart.length,\n        valid: bValid\n      };\n    },\n    isNumeric: true\n  }),\n  \"K\": DateFormat._createPatternSymbol({\n    name: \"hour0_11\",\n    format: function (oField, oDate) {\n      var iHours = oDate.getUTCHours();\n      var sHours = String(iHours > 11 ? iHours - 12 : iHours);\n      return sHours.padStart(oField.digits, \"0\");\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var sPart = oParseHelper.findNumbers(sValue, Math.max(oPart.digits, 2)),\n        iHours = parseInt(sPart),\n        bPartInvalid = sPart === \"\" || oConfig.exactLength && sPart.length < 2,\n        bValid = oParseHelper.checkValid(oPart.type, bPartInvalid, oFormat);\n      if (oConfig.strict && iHours > 11) {\n        bValid = false;\n      }\n      return {\n        hour: iHours,\n        length: sPart.length,\n        valid: bValid\n      };\n    },\n    isNumeric: true\n  }),\n  \"h\": DateFormat._createPatternSymbol({\n    name: \"hour1_12\",\n    format: function (oField, oDate) {\n      var iHours = oDate.getUTCHours();\n      var sHours;\n      if (iHours > 12) {\n        sHours = String(iHours - 12);\n      } else if (iHours === 0) {\n        sHours = \"12\";\n      } else {\n        sHours = String(iHours);\n      }\n      return sHours.padStart(oField.digits, \"0\");\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var bPM = oConfig.dateValue.pm,\n        sPart = oParseHelper.findNumbers(sValue, Math.max(oPart.digits, 2)),\n        iHours = parseInt(sPart),\n        bPartInvalid = sPart === \"\" || oConfig.exactLength && sPart.length < 2,\n        bValid = oParseHelper.checkValid(oPart.type, bPartInvalid, oFormat);\n      if (iHours === 12) {\n        iHours = 0;\n        // change the PM only when it's not yet parsed\n        // 12:00 defaults to 12:00 PM\n        bPM = bPM === undefined ? true : bPM;\n      }\n      if (oConfig.strict && iHours > 11) {\n        bValid = false;\n      }\n      return {\n        hour: iHours,\n        length: sPart.length,\n        pm: bPM,\n        valid: bValid\n      };\n    },\n    isNumeric: true\n  }),\n  \"m\": DateFormat._createPatternSymbol({\n    name: \"minute\",\n    format: function (oField, oDate) {\n      var iMinutes = oDate.getUTCMinutes();\n      return String(iMinutes).padStart(oField.digits, \"0\");\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var sPart = oParseHelper.findNumbers(sValue, Math.max(oPart.digits, 2)),\n        iMinutes = parseInt(sPart),\n        bPartInvalid = sPart === \"\" || oConfig.exactLength && sPart.length < 2,\n        bValid = oParseHelper.checkValid(oPart.type, bPartInvalid, oFormat);\n      if (oConfig.strict && iMinutes > 59) {\n        bValid = false;\n      }\n      return {\n        length: sPart.length,\n        minute: iMinutes,\n        valid: bValid\n      };\n    },\n    isNumeric: true\n  }),\n  \"s\": DateFormat._createPatternSymbol({\n    name: \"second\",\n    format: function (oField, oDate) {\n      var iSeconds = oDate.getUTCSeconds();\n      return String(iSeconds).padStart(oField.digits, \"0\");\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var iExpectedDigits = Math.max(oPart.digits, 2),\n        sPart = oParseHelper.findNumbers(sValue, iExpectedDigits),\n        bPartInvalid = sPart === \"\" || oConfig.exactLength && sPart.length < iExpectedDigits,\n        iSeconds = parseInt(sPart),\n        bValid = oParseHelper.checkValid(oPart.type, bPartInvalid, oFormat);\n      if (oConfig.strict && iSeconds > 59) {\n        bValid = false;\n      }\n      return {\n        length: sPart.length,\n        second: iSeconds,\n        valid: bValid\n      };\n    },\n    isNumeric: true\n  }),\n  \"S\": DateFormat._createPatternSymbol({\n    name: \"fractionalsecond\",\n    format: function (oField, oDate) {\n      var iMilliseconds = oDate.getUTCMilliseconds();\n      var sMilliseconds = String(iMilliseconds);\n      var sFractionalseconds = sMilliseconds.padStart(3, \"0\");\n      sFractionalseconds = sFractionalseconds.substr(0, oField.digits);\n      sFractionalseconds = sFractionalseconds.padEnd(oField.digits, \"0\");\n      return sFractionalseconds;\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var sPart = oParseHelper.findNumbers(sValue, oPart.digits),\n        iLength = sPart.length,\n        bPartInvalid = oConfig.exactLength && iLength < oPart.digits;\n      sPart = sPart.substr(0, 3);\n      sPart = sPart.padEnd(3, \"0\");\n      var iMilliseconds = parseInt(sPart);\n      return {\n        length: iLength,\n        millisecond: iMilliseconds,\n        valid: oParseHelper.checkValid(oPart.type, bPartInvalid, oFormat)\n      };\n    },\n    isNumeric: true\n  }),\n  \"z\": DateFormat._createPatternSymbol({\n    name: \"timezoneGeneral\",\n    format: function (oField, oDate, bUTC, oFormat, sTimezone) {\n      //TODO getTimezoneLong and getTimezoneShort does not exist on Date object\n      //-> this is a preparation for a future full timezone support (only used by unit test so far)\n      if (oField.digits > 3 && oDate.getTimezoneLong && oDate.getTimezoneLong()) {\n        return oDate.getTimezoneLong();\n      } else if (oDate.getTimezoneShort && oDate.getTimezoneShort()) {\n        return oDate.getTimezoneShort();\n      }\n\n      // valid for zzzz (fallback to OOOO)\n      var iTimezoneOffset = TimezoneUtil.calculateOffset(oDate, sTimezone);\n      var sTimeZone = \"GMT\";\n      var iTZOffset = Math.abs(iTimezoneOffset / 60);\n      var bPositiveOffset = iTimezoneOffset > 0;\n      var iHourOffset = Math.floor(iTZOffset / 60);\n      var iMinuteOffset = Math.floor(iTZOffset % 60);\n      if (!bUTC && iTZOffset !== 0) {\n        sTimeZone += bPositiveOffset ? \"-\" : \"+\";\n        sTimeZone += String(iHourOffset).padStart(2, \"0\");\n        sTimeZone += \":\";\n        sTimeZone += String(iMinuteOffset).padStart(2, \"0\");\n      } else {\n        sTimeZone += \"Z\";\n      }\n      return sTimeZone;\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var iLength = 0;\n      var iTZDiff;\n      var oTZ = sValue.substring(0, 3);\n      if (oTZ === \"GMT\" || oTZ === \"UTC\") {\n        iLength = 3;\n      } else if (sValue.substring(0, 2) === \"UT\") {\n        iLength = 2;\n      } else if (sValue.charAt(0) === \"Z\") {\n        iLength = 1;\n        iTZDiff = 0;\n      } else {\n        return {\n          error: \"cannot be parsed correctly by sap.ui.core.format.DateFormat: The given timezone is not supported!\"\n        };\n      }\n      if (sValue.charAt(0) !== \"Z\") {\n        var oParsedTZ = oParseHelper.parseTZ(sValue.substr(iLength), true);\n        iLength += oParsedTZ.length;\n        iTZDiff = oParsedTZ.tzDiff;\n      }\n      return {\n        length: iLength,\n        tzDiff: iTZDiff\n      };\n    }\n  }),\n  \"Z\": DateFormat._createPatternSymbol({\n    name: \"timezoneRFC822\",\n    format: function (oField, oDate, bUTC, oFormat, sTimezone) {\n      var iTimezoneOffset = TimezoneUtil.calculateOffset(oDate, sTimezone);\n      var iTZOffset = Math.abs(iTimezoneOffset / 60);\n      var bPositiveOffset = iTimezoneOffset > 0;\n      var iHourOffset = Math.floor(iTZOffset / 60);\n      var iMinuteOffset = Math.floor(iTZOffset % 60);\n      var sTimeZone = \"\";\n\n      // valid for Z-ZZZ\n      // per RFC822 a timezone always has 4 digits\n      // UTC+0: \"+0000\"\n      // UTC-7: \"-0700\"\n      // UTC+2: \"+0200\"\n      // https://tools.ietf.org/html/rfc822 paragraph 5.1\n      if (!bUTC) {\n        sTimeZone += bPositiveOffset ? \"-\" : \"+\";\n        sTimeZone += String(iHourOffset).padStart(2, \"0\");\n        sTimeZone += String(iMinuteOffset).padStart(2, \"0\");\n      }\n      return sTimeZone;\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      return oParseHelper.parseTZ(sValue, false);\n    }\n  }),\n  \"X\": DateFormat._createPatternSymbol({\n    name: \"timezoneISO8601\",\n    format: function (oField, oDate, bUTC, oFormat, sTimezone) {\n      /*\n       * Mountain Standard Time (MST, UTC-7)\n       * X:           \"-07\"\n       * XX, XXXX:    \"-0700\"\n       * XXX, XXXXX:  \"-07:00\"\n       */\n\n      /*\n       * Central European Summer Time (CEST, UTC+2)\n       * X:           \"+02\"\n       * XX, XXXX:    \"+0200\"\n       * XXX, XXXXX:  \"+02:00\"\n       */\n\n      /*\n       * Indian Standard Time (IST, UTC+5:30)\n       * X:           \"+0530\"\n       * XX, XXXX:    \"+0530\"\n       * XXX, XXXXX:  \"+05:30\"\n       */\n\n      /*\n       * Greenwich Mean Time (GMT, UTC+0)\n       * X:           \"Z\"\n       * XX, XXXX:    \"Z\"\n       * XXX, XXXXX:  \"Z\"\n       */\n\n      // @see http://www.unicode.org/reports/tr35/tr35-dates.html#Time_Zone_Goals\n      var iTimezoneOffset = TimezoneUtil.calculateOffset(oDate, sTimezone);\n      var iTZOffset = Math.abs(iTimezoneOffset / 60);\n      var bPositiveOffset = iTimezoneOffset > 0;\n      var iHourOffset = Math.floor(iTZOffset / 60);\n      var iMinuteOffset = Math.floor(iTZOffset % 60);\n      var sTimeZone = \"\";\n      if (!bUTC && iTZOffset !== 0) {\n        sTimeZone += bPositiveOffset ? \"-\" : \"+\";\n        sTimeZone += String(iHourOffset).padStart(2, \"0\");\n        if (oField.digits > 1 || iMinuteOffset > 0) {\n          if (oField.digits === 3 || oField.digits === 5) {\n            sTimeZone += \":\";\n          }\n          sTimeZone += String(iMinuteOffset).padStart(2, \"0\");\n        }\n      } else {\n        sTimeZone += \"Z\";\n      }\n      return sTimeZone;\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      if (sValue.charAt(0) === \"Z\") {\n        return {\n          length: 1,\n          tzDiff: 0\n        };\n      } else {\n        return oParseHelper.parseTZ(sValue, oPart.digits === 3 || oPart.digits === 5);\n      }\n    }\n  }),\n  \"V\": DateFormat._createPatternSymbol({\n    name: \"timezoneID\",\n    format: function (oField, oDate, bUTC, oFormat, sTimezone) {\n      // Only VV is supported\n      // The IANA time zone ID\n      // e.g. America/New_York\n      // @see http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns\n      if (!bUTC && oField.digits === 2) {\n        // fallback for unknown but valid IANA time zone IDs (IANA is a living standard and the browser\n        // might support more, while the CLDR data is fixed) such that the user can see, that there is no\n        // translation\n        return oFormat.oLocaleData.getTimezoneTranslations()[sTimezone] || sTimezone;\n      }\n      return \"\";\n    },\n    parse: function (sValue, oPart, oFormat, oConfig, sTimezone) {\n      var oTimezoneParsed = {\n        timezone: \"\",\n        length: 0\n      };\n\n      // VV - The long IANA time zone ID\n      if (oPart.digits === 2) {\n        var mTimezoneTranslations = oFormat.oLocaleData.getTimezoneTranslations();\n\n        // shortcut, first try the time zone parameter\n        if (sValue === mTimezoneTranslations[sTimezone]) {\n          return {\n            timezone: sTimezone,\n            length: sValue.length\n          };\n        }\n        var aTimezoneTranslations = Object.values(mTimezoneTranslations);\n        var oTimezoneResult = oParseHelper.findEntry(sValue, aTimezoneTranslations, oFormat.oLocaleData.sCLDRLocaleId);\n        if (oTimezoneResult.index !== -1) {\n          return {\n            timezone: Object.keys(mTimezoneTranslations)[oTimezoneResult.index],\n            length: oTimezoneResult.length\n          };\n        }\n\n        // fallback for IANA time zone IDs\n        var sCurrentValue = \"\";\n        // find the longest valid time zone ID at the beginning of sValue\n        for (var i = sValue.length; i > 0; i -= 1) {\n          sCurrentValue = sValue.slice(0, i);\n          if (TimezoneUtil.isValidTimezone(sCurrentValue)) {\n            oTimezoneParsed.timezone = sCurrentValue;\n            oTimezoneParsed.length = sCurrentValue.length;\n            break;\n          }\n        }\n      }\n      return oTimezoneParsed;\n    }\n  })\n};\nDateFormat.prototype._format = function (oJSDate, bUTC, sTimezone) {\n  if (this.oFormatOptions.relative) {\n    var sRes = this.formatRelative(oJSDate, bUTC, this.oFormatOptions.relativeRange, sTimezone);\n    if (sRes) {\n      //Stop when relative formatting possible, else go on with standard formatting\n      return sRes;\n    }\n  }\n  var sCalendarType = this.oFormatOptions.calendarType;\n  var oDate = UniversalDate.getInstance(oJSDate, sCalendarType);\n  var aBuffer = [],\n    oPart,\n    sResult,\n    sSymbol;\n  for (var i = 0; i < this.aFormatArray.length; i++) {\n    oPart = this.aFormatArray[i];\n    sSymbol = oPart.symbol || \"\";\n    aBuffer.push(this.oSymbols[sSymbol].format(oPart, oDate, bUTC, this, sTimezone));\n  }\n  sResult = aBuffer.join(\"\");\n  if (Supportability.collectOriginInfo()) {\n    // String object is created on purpose and must not be a string literal\n    // eslint-disable-next-line no-new-wrappers\n    sResult = new String(sResult);\n    sResult.originInfo = {\n      source: \"Common Locale Data Repository\",\n      locale: this.oLocale.toString(),\n      style: this.oFormatOptions.style,\n      pattern: this.oFormatOptions.pattern\n    };\n  }\n  return sResult;\n};\n\n/**\n * Format a date according to the given format options.\n *\n * Uses the timezone from {@link sap.ui.core.Configuration#getTimezone}, which falls back to the\n * browser's local timezone to convert the given date.\n *\n * When using instances from getDateTimeWithTimezoneInstance, please see the corresponding documentation:\n * {@link sap.ui.core.format.DateFormat.DateTimeWithTimezone#format}.\n *\n * @example <caption>DateTime (assuming timezone \"Europe/Berlin\")</caption>\n * var oDate = UI5Date.getInstance(\"2021-12-24T13:37:00Z\");\n * DateFormat.getDateTimeInstance().format(oDate);\n * // output: \"Dec 24, 2021, 2:37:00 PM\"\n *\n * @param {Date|Date[]} vJSDate the value to format\n * @param {boolean} [bUTC=false] whether to use UTC\n * @return {string} the formatted output value. If an invalid date is given, an empty string is returned.\n * @public\n */\nDateFormat.prototype.format = function (vJSDate, bUTC) {\n  var sTimezone;\n  if (this.type === mDateFormatTypes.DATETIME_WITH_TIMEZONE) {\n    // UTC and timezone are not supported at the same time, therefore set bUTC to false\n    sTimezone = bUTC;\n    bUTC = false;\n    checkTimezoneParameterType(sTimezone);\n    if (sTimezone && !TimezoneUtil.isValidTimezone(sTimezone)) {\n      Log.error(\"The given timezone isn't valid.\");\n      return \"\";\n    }\n  }\n  var sCalendarType = this.oFormatOptions.calendarType,\n    sResult;\n  if (bUTC === undefined) {\n    bUTC = this.oFormatOptions.UTC;\n  }\n\n  // default the timezone to the local timezone to always enforce the conversion\n  sTimezone = sTimezone || Configuration.getTimezone();\n  if (Array.isArray(vJSDate)) {\n    if (!this.oFormatOptions.interval) {\n      Log.error(\"Non-interval DateFormat can't format more than one date instance.\");\n      return \"\";\n    }\n    if (vJSDate.length !== 2) {\n      Log.error(\"Interval DateFormat can only format with 2 date instances but \" + vJSDate.length + \" is given.\");\n      return \"\";\n    }\n    vJSDate = vJSDate.map(function (oJSDate) {\n      return convertToTimezone(oJSDate, sTimezone, bUTC);\n    });\n    if (this.oFormatOptions.singleIntervalValue) {\n      if (vJSDate[0] === null) {\n        Log.error(\"First date instance which is passed to the interval DateFormat shouldn't be null.\");\n        return \"\";\n      }\n      if (vJSDate[1] === null) {\n        sResult = this._format(vJSDate[0], bUTC, sTimezone);\n      }\n    }\n    if (sResult === undefined) {\n      if (!vJSDate.every(isValidDateObject)) {\n        Log.error(\"At least one date instance which is passed to the interval DateFormat isn't valid.\");\n        return \"\";\n      }\n      sResult = this._formatInterval(vJSDate, bUTC);\n    }\n  } else {\n    if (!isValidDateObject(vJSDate)) {\n      // Although an invalid date was given, the DATETIME_WITH_TIMEZONE instance might\n      // have a pattern with the timezone (VV) inside then the IANA timezone ID is returned\n      if (this.type === mDateFormatTypes.DATETIME_WITH_TIMEZONE && this.oFormatOptions.pattern.includes(\"VV\")) {\n        return this.oLocaleData.getTimezoneTranslations()[sTimezone] || sTimezone;\n      }\n      Log.error(\"The given date instance isn't valid.\");\n      return \"\";\n    }\n    if (this.oFormatOptions.interval) {\n      Log.error(\"Interval DateFormat expects an array with two dates for the first argument but only one date is given.\");\n      return \"\";\n    }\n    vJSDate = convertToTimezone(vJSDate, sTimezone, bUTC);\n    sResult = this._format(vJSDate, bUTC, sTimezone);\n  }\n\n  // Support Japanese Gannen instead of Ichinen for first year of the era\n  if (sCalendarType === CalendarType.Japanese && this.oLocale.getLanguage() === \"ja\") {\n    sResult = sResult.replace(/(^|[^\\d])1年/g, \"$1元年\");\n  }\n  return sResult;\n};\n\n/**\n * Checks whether the interval to be formatted has to use the pattern of a custom interval delimiter.\n *\n * @param {object} oDiffFields\n *   An object describing which date information is required for this instance's interval format,\n *   for example <code>{\"Day\": true, \"Minutes\": true}</code>\n * @returns {boolean}\n *   Whether to use the custom interval delimiter pattern\n *\n * @private\n */\nDateFormat.prototype._useCustomIntervalDelimiter = function (oDiffFields) {\n  var aTokens;\n  if (!this.oFormatOptions.intervalDelimiter) {\n    return false;\n  }\n  // If there are no differences in the date/time parts specified by \"oFormatOptions.format\", a single value is\n  // formatted and there is no need to use the custom delimiter pattern.\n  if (this.oFormatOptions.format) {\n    aTokens = this.oLocaleData._parseSkeletonFormat(this.oFormatOptions.format);\n    return aTokens.some(function (oToken) {\n      return oDiffFields[oToken.group];\n    });\n  }\n  return true;\n};\nDateFormat.prototype._formatInterval = function (aJSDates, bUTC) {\n  var oDate,\n    oPart,\n    sPattern,\n    sSymbol,\n    aBuffer = [],\n    sCalendarType = this.oFormatOptions.calendarType,\n    aFormatArray = [],\n    oFromDate = UniversalDate.getInstance(aJSDates[0], sCalendarType),\n    oToDate = UniversalDate.getInstance(aJSDates[1], sCalendarType),\n    oDiffFields = this._getDiffFields([oFromDate, oToDate]);\n  if (!oDiffFields) {\n    return this._format(aJSDates[0], bUTC);\n  }\n  if (this._useCustomIntervalDelimiter(oDiffFields)) {\n    sPattern = this.intervalPatterns[0];\n  } else if (this.oFormatOptions.format) {\n    // when 'format' option is set, generate the pattern based on the greatest difference\n    sPattern = this.oLocaleData.getCustomIntervalPattern(this.oFormatOptions.format, oDiffFields, sCalendarType);\n  } else {\n    sPattern = this.oLocaleData.getCombinedIntervalPattern(this.oFormatOptions.pattern, sCalendarType);\n  }\n  aFormatArray = this.parseCldrDatePattern(sPattern);\n  oDate = oFromDate;\n  for (var i = 0; i < aFormatArray.length; i++) {\n    oPart = aFormatArray[i];\n    sSymbol = oPart.symbol || \"\";\n    if (oPart.repeat) {\n      oDate = oToDate;\n    }\n    aBuffer.push(this.oSymbols[sSymbol].format(oPart, oDate, bUTC, this));\n  }\n  return aBuffer.join(\"\");\n};\nvar mFieldToGroup = {\n  Era: \"Era\",\n  FullYear: \"Year\",\n  Quarter: \"Quarter\",\n  Month: \"Month\",\n  Week: \"Week\",\n  Date: \"Day\",\n  DayPeriod: \"DayPeriod\",\n  Hours: \"Hour\",\n  Minutes: \"Minute\",\n  Seconds: \"Second\"\n};\n\n/**\n * Returns an object containing the relevant date/time parts that differ in the two given dates.\n *\n * @param {sap.ui.core.date.UniversalDate[]} aDates\n *   An array with two UniversalDate instances representing the start and the end date of the interval;\n *   the dates are expected to be in UTC time zone\n * @returns {Object<string, boolean>|null}\n *   An object containing the different date/time parts, or <code>null</code> if the dates are the same\n *\n * @private\n */\nDateFormat.prototype._getDiffFields = function (aDates) {\n  var bDiffFound = false,\n    mDiff = {};\n  this.aIntervalCompareFields.forEach(function (sField) {\n    var sGetterPrefix = \"getUTC\",\n      sMethodName = sGetterPrefix + sField,\n      sFieldGroup = mFieldToGroup[sField],\n      vFromValue = aDates[0][sMethodName].apply(aDates[0]),\n      vToValue = aDates[1][sMethodName].apply(aDates[1]);\n    if (!deepEqual(vFromValue, vToValue)) {\n      bDiffFound = true;\n      mDiff[sFieldGroup] = true;\n    }\n  });\n  if (bDiffFound) {\n    return mDiff;\n  }\n  return null;\n};\nDateFormat.prototype._parse = function (sValue, aFormatArray, bUTC, bStrict, sTimezone) {\n  var sFlexibleDayPeriod,\n    oNextPart,\n    oPart,\n    bPM,\n    oPrevPart,\n    oResult,\n    sSubValue,\n    oDateValue = {\n      valid: true,\n      lastTimezonePatternSymbol: \"\"\n    },\n    iIndex = 0,\n    oParseConf = {\n      formatArray: aFormatArray,\n      dateValue: oDateValue,\n      strict: bStrict\n    },\n    that = this;\n  function getSymbol(oPart0) {\n    return that.oSymbols[oPart0.symbol || \"\"];\n  }\n  function isNumeric(oPart0) {\n    return !!oPart0 && getSymbol(oPart0).isNumeric(oPart0.digits);\n  }\n  for (var i = 0; i < aFormatArray.length; i++) {\n    sSubValue = sValue.substr(iIndex);\n    oPart = aFormatArray[i];\n    oPrevPart = aFormatArray[i - 1];\n    oNextPart = aFormatArray[i + 1];\n    oParseConf.index = i;\n    oParseConf.exactLength = isNumeric(oPart) && (isNumeric(oPrevPart) || isNumeric(oNextPart));\n    oResult = getSymbol(oPart).parse(sSubValue, oPart, this, oParseConf, sTimezone) || {};\n    // Remember the last required timezone difference which needs to be calculated (V pattern) or applied (x and z pattern)\n    if (oResult.tzDiff !== undefined || oResult.timezone) {\n      oResult.lastTimezonePatternSymbol = oPart.symbol;\n    }\n    oDateValue = extend(oDateValue, oResult);\n    if (oResult.valid === false) {\n      break;\n    }\n    iIndex += oResult.length || 0;\n  }\n  oDateValue.index = iIndex;\n  bPM = oDateValue.pm;\n  // \"getFlexibleDayPeriodOfTime\" is required if the given time is earlier than 12 pm because,\n  // for a \"h\" pattern it can't distinguished whether e.g. 1 o'clock is meant to be AM or PM\n  if (oDateValue.flexDayPeriod && oDateValue.hour * 60 + (oDateValue.minute || 0) < 720) {\n    sFlexibleDayPeriod = this.oLocaleData.getFlexibleDayPeriodOfTime(oDateValue.hour + 12, oDateValue.minute || 0);\n    bPM = oDateValue.flexDayPeriod === sFlexibleDayPeriod;\n  }\n  if (bPM) {\n    oDateValue.hour += 12;\n  }\n\n  // use dayOfWeek (E) as dayNumberOfWeek (u) if dayNumberOfWeek (u) is not present\n  if (oDateValue.dayNumberOfWeek === undefined && oDateValue.dayOfWeek !== undefined) {\n    oDateValue.dayNumberOfWeek = this._adaptDayOfWeek(oDateValue.dayOfWeek);\n  }\n  if (oDateValue.quarter !== undefined && oDateValue.month === undefined && oDateValue.day === undefined) {\n    oDateValue.month = 3 * oDateValue.quarter;\n    oDateValue.day = 1;\n  }\n  return oDateValue;\n};\nDateFormat.prototype._parseInterval = function (sValue, sCalendarType, bUTC, bStrict, sTimezone) {\n  var aDateValues, iRepeat, oDateValue;\n\n  // Try out with all possible patterns until successfully parse has been done or the end of the array is reached\n  this.intervalPatterns.some(function (sPattern) {\n    var aFormatArray = this.parseCldrDatePattern(sPattern);\n    iRepeat = undefined;\n\n    // loop through aFormatArray until we have found the repeated date symbol and get the index\n    for (var i = 0; i < aFormatArray.length; i++) {\n      if (aFormatArray[i].repeat) {\n        iRepeat = i;\n        break;\n      }\n    }\n    if (iRepeat === undefined) {\n      // In case of standard date pattern, parse string as single date and put the same date twice into the aDateValues array\n      oDateValue = this._parse(sValue, aFormatArray, bUTC, bStrict, sTimezone);\n\n      // If input value has not been completely parsed, mark it as invalid\n      if (oDateValue.index === 0 || oDateValue.index < sValue.length) {\n        oDateValue.valid = false;\n      }\n      if (oDateValue.valid === false) {\n        return;\n      }\n      aDateValues = [oDateValue, oDateValue];\n      return true;\n    } else {\n      aDateValues = [];\n\n      // Call _parse function with start 0 and end index of repeated symbol\n      oDateValue = this._parse(sValue, aFormatArray.slice(0, iRepeat), bUTC, bStrict, sTimezone);\n      if (oDateValue.valid === false) {\n        return;\n      }\n      aDateValues.push(oDateValue);\n      var iLength = oDateValue.index;\n\n      // Call _parse function with start iRepeat and end of array\n      oDateValue = this._parse(sValue.substring(iLength), aFormatArray.slice(iRepeat), bUTC, bStrict, sTimezone);\n\n      // If input value has not been completely parsed, mark it as invalid\n      if (oDateValue.index === 0 || oDateValue.index + iLength < sValue.length) {\n        oDateValue.valid = false;\n      }\n      if (oDateValue.valid === false) {\n        return;\n      }\n      aDateValues.push(oDateValue);\n      return true;\n    }\n  }.bind(this));\n  return aDateValues;\n};\n\n/**\n * Retrieves the parameter for the calendar week configuration from the DateFormat's format\n * options\n *\n * @param {{firstDayOfWeek: int, minimalDaysInFirstWeek: int, calendarWeekNumbering: sap.ui.core.date.CalendarWeekNumbering}} oFormatOptions\n *   The format options with which the DateFormat instance was created\n * @returns {sap.ui.core.date.CalendarWeekNumbering|{firstDayOfWeek: int, minimalDaysInFirstWeek: int}|undefined}\n *   The parameter for the calendar week configuration\n */\nfunction getCalendarWeekParameter(oFormatOptions) {\n  if (oFormatOptions.calendarWeekNumbering) {\n    return oFormatOptions.calendarWeekNumbering;\n    // either both are provided or none (checked in DateFormat.createInstance)\n  } else if (oFormatOptions.firstDayOfWeek !== undefined && oFormatOptions.minimalDaysInFirstWeek !== undefined) {\n    return {\n      firstDayOfWeek: oFormatOptions.firstDayOfWeek,\n      minimalDaysInFirstWeek: oFormatOptions.minimalDaysInFirstWeek\n    };\n  }\n  return undefined;\n}\n\n/**\n * Converts a given date to the given timezone if bUTC is false\n *\n * @param {Date} oJSDate The date which should be converted\n * @param {string} sTimezone target timezone\n * @param {boolean} bUTC whether it is utc\n * @returns {Date} the converted date\n */\nvar convertToTimezone = function (oJSDate, sTimezone, bUTC) {\n  // Convert to timezone if provided and a valid date is supplied\n  if (!bUTC && isValidDateObject(oJSDate)) {\n    // convert given date to a date in the target timezone\n    return TimezoneUtil.convertToTimezone(oJSDate, sTimezone);\n  }\n  return oJSDate;\n};\n\n// recreate javascript date object from the given oDateValues.\n// In case of oDateValue.valid == false, null value will be returned\nvar fnCreateDate = function (oDateValue, sCalendarType, bUTC, bStrict, sTimezone, oFormatOptions, oLocale) {\n  if (!oDateValue.valid) {\n    return null;\n  }\n  var oDate,\n    iYear = typeof oDateValue.year === \"number\" ? oDateValue.year : 1970;\n\n  // no need to use UI5Date.getInstance as only the UTC timestamp is used\n  oDate = UniversalDate.getInstance(new Date(0), sCalendarType);\n  oDate.setUTCEra(oDateValue.era || UniversalDate.getCurrentEra(sCalendarType));\n  // Set parsed year, month and day in one call to avoid calculation issues when converting the calendar specific\n  // date into a Gregorian date.\n  oDate.setUTCFullYear(iYear, oDateValue.month || 0, oDateValue.day || 1);\n  oDate.setUTCHours(oDateValue.hour || 0);\n  oDate.setUTCMinutes(oDateValue.minute || 0);\n  oDate.setUTCSeconds(oDateValue.second || 0);\n  oDate.setUTCMilliseconds(oDateValue.millisecond || 0);\n  if (bStrict && (oDateValue.day || 1) !== oDate.getUTCDate()) {\n    // check if valid date given - if invalid, day is not the same (31.Apr -> 1.May)\n    return null;\n  }\n  if (oDateValue.week !== undefined && (oDateValue.month === undefined || oDateValue.day === undefined)) {\n    //check that the week is only set if the day/month has not been set, because day/month have higher precedence than week\n    oDate.setUTCWeek({\n      year: oDateValue.weekYear || oDateValue.year,\n      week: oDateValue.week\n    }, oLocale, getCalendarWeekParameter(oFormatOptions));\n\n    // add the dayNumberOfWeek to the current day\n    if (oDateValue.dayNumberOfWeek !== undefined) {\n      oDate.setUTCDate(oDate.getUTCDate() + oDateValue.dayNumberOfWeek - 1);\n    }\n  }\n  oDate = oDate.getJSDate();\n\n  // Set the tzDiff based on the timezone difference\n  if (!bUTC && (oDateValue.lastTimezonePatternSymbol === \"V\" && oDateValue.timezone || oDateValue.tzDiff === undefined)) {\n    // The last parsed timezone pattern will be considered. If this is the \"V\" pattern for the IANA timezone ID, it needs\n    // to be calculated here. The tzDiff cannot be determined in the parse method because we need the parsed parts to calculate it.\n    if (oDateValue.timezone) {\n      sTimezone = oDateValue.timezone;\n    }\n    if (sTimezone) {\n      oDateValue.tzDiff = TimezoneUtil.calculateOffset(oDate, sTimezone);\n    }\n  }\n  if (oDateValue.tzDiff) {\n    // tzDiff is in seconds for a higher precision (historical timezone might have differences in seconds)\n    // e.g. UI5Date.getInstance(\"1730-01-01T00:00:00Z\")\n    // is in Berlin: Sun Jan 01 1730 00:53:28 GMT+0053 (Central European Standard Time)\n    oDate.setUTCSeconds(oDate.getUTCSeconds() + oDateValue.tzDiff);\n  }\n  return oDate;\n};\n\n// Copy the properties of object2 into object1 without\n// overwriting the existing properties in object1\nfunction mergeWithoutOverwrite(object1, object2) {\n  if (object1 === object2) {\n    return object1;\n  }\n  var oMergedObject = {};\n\n  // Clone object1\n  Object.keys(object1).forEach(function (sKey) {\n    oMergedObject[sKey] = object1[sKey];\n  });\n\n  // merge\n  Object.keys(object2).forEach(function (sKey) {\n    if (!oMergedObject.hasOwnProperty(sKey)) {\n      oMergedObject[sKey] = object2[sKey];\n    }\n  });\n  return oMergedObject;\n}\n\n// Checks if the given start date is before the end date.\nfunction isValidDateRange(oStartDate, oEndDate) {\n  if (oStartDate.getTime() > oEndDate.getTime()) {\n    return false;\n  }\n  return true;\n}\n\n// the expectation is that a valid Date has a getTime function which returns a valid number\nfunction isValidDateObject(oDate) {\n  return oDate && typeof oDate.getTime === \"function\" && !isNaN(oDate.getTime());\n}\n\n/**\n * Parse a string which is formatted according to the given format options.\n *\n * Uses the timezone from {@link sap.ui.core.Configuration#getTimezone}, which falls back to the\n * browser's local timezone to convert the given date.\n *\n * When using instances from getDateTimeWithTimezoneInstance, please see the corresponding documentation:\n * {@link sap.ui.core.format.DateFormat.DateTimeWithTimezone#parse}.\n *\n * @example <caption>DateTime (assuming timezone \"Europe/Berlin\")</caption>\n * var oDate = UI5Date.getInstance(\"2021-12-24T13:37:00Z\");\n * DateFormat.getDateTimeInstance().parse(\"Dec 24, 2021, 2:37:00 PM\");\n * // output: oDate\n *\n * @param {string} sValue the string containing a formatted date/time value\n * @param {boolean} [bUTC] whether to use UTC\n * @param {boolean} [bStrict] whether to use strict value check\n * @return {Date|Date[]|module:sap/ui/core/date/UI5Date|module:sap/ui/core/date/UI5Date[]} the parsed value(s)\n * @public\n */\nDateFormat.prototype.parse = function (sValue, bUTC, bStrict) {\n  // in order to convert a datetime to a timezone both the date and the time part are required.\n  // If only one is present it cannot be guaranteed that the parsed result is correct, due to\n  // daylight saving time which might shift hours and the timezone difference which might shift\n  // days. For now only the date and time can be parsed using a timezone.\n  var bShowDate = this.oFormatOptions.showDate === undefined || this.oFormatOptions.showDate;\n  var bShowTime = this.oFormatOptions.showTime === undefined || this.oFormatOptions.showTime;\n  if (this.type === mDateFormatTypes.DATETIME_WITH_TIMEZONE && (bShowDate && !bShowTime || !bShowDate && bShowTime)) {\n    throw new TypeError(\"The input can only be parsed back to date if both date and time are supplied.\");\n  }\n  var sTimezone;\n  if (bUTC === undefined && this.type !== mDateFormatTypes.DATETIME_WITH_TIMEZONE) {\n    bUTC = this.oFormatOptions.UTC;\n  }\n  // preserve UTC parameter for fallback instances (must inherit format option UTC from parent)\n  var bUTCInputParameter = bUTC;\n  if (this.type === mDateFormatTypes.DATETIME_WITH_TIMEZONE) {\n    // UTC and timezone are not supported at the same time, therefore set bUTC to false\n    sTimezone = bUTC;\n    bUTC = false;\n    checkTimezoneParameterType(sTimezone);\n    if (sTimezone && !TimezoneUtil.isValidTimezone(sTimezone)) {\n      Log.error(\"The given timezone isn't valid.\");\n      return null;\n    }\n  }\n  sValue = sValue == null ? \"\" : String(sValue).trim();\n  // normalize input by removing all RTL special characters and replacing all special spaces\n  // by a standard space (\\u0020)\n  sValue = DateFormat._normalize(sValue);\n  var oDateValue;\n  var sCalendarType = this.oFormatOptions.calendarType;\n\n  // default the timezone to the local timezone to always enforce the conversion\n  sTimezone = sTimezone || Configuration.getTimezone();\n  if (bStrict === undefined) {\n    bStrict = this.oFormatOptions.strictParsing;\n  }\n\n  // Support Japanese Gannen instead of Ichinen for first year of the era\n  if (sCalendarType === CalendarType.Japanese && this.oLocale.getLanguage() === \"ja\") {\n    sValue = sValue.replace(/元年/g, \"1年\");\n  }\n  if (!this.oFormatOptions.interval) {\n    var oJSDate = this.parseRelative(sValue, bUTC);\n    if (oJSDate) {\n      //Stop when relative parsing possible, else go on with standard parsing\n      return oJSDate;\n    }\n    oDateValue = this._parse(sValue, this.aFormatArray, bUTC, bStrict, sTimezone);\n\n    // If input value has not been completely parsed, mark it as invalid\n    if (oDateValue.index === 0 || oDateValue.index < sValue.length) {\n      oDateValue.valid = false;\n    }\n    oJSDate = fnCreateDate(oDateValue, sCalendarType, bUTC, bStrict, sTimezone, this.oFormatOptions, this.oLocale);\n    if (oJSDate) {\n      if (this.type === mDateFormatTypes.DATETIME_WITH_TIMEZONE) {\n        var bShowTimezone = this.oFormatOptions.showTimezone === undefined || this.oFormatOptions.showTimezone;\n        // fill fields according to showDate, showTime and showTimezone options and parsed values\n        if (!bShowTimezone && bShowDate && bShowTime) {\n          return [oJSDate, undefined];\n        } else if (bShowTimezone && !bShowDate && !bShowTime) {\n          return [undefined, oDateValue.timezone];\n        }\n        return [oJSDate, oDateValue.timezone || undefined];\n      }\n      return oJSDate;\n    }\n  } else {\n    var aDateValues = this._parseInterval(sValue, sCalendarType, bUTC, bStrict, sTimezone);\n    var oJSDate1, oJSDate2;\n    if (aDateValues && aDateValues.length === 2) {\n      var oDateValue1 = mergeWithoutOverwrite(aDateValues[0], aDateValues[1]);\n      var oDateValue2 = mergeWithoutOverwrite(aDateValues[1], aDateValues[0]);\n      oJSDate1 = fnCreateDate(oDateValue1, sCalendarType, bUTC, bStrict, sTimezone, this.oFormatOptions, this.oLocale);\n      oJSDate2 = fnCreateDate(oDateValue2, sCalendarType, bUTC, bStrict, sTimezone, this.oFormatOptions, this.oLocale);\n      if (oJSDate1 && oJSDate2) {\n        if (this.oFormatOptions.singleIntervalValue && oJSDate1.getTime() === oJSDate2.getTime()) {\n          return [oJSDate1, null];\n        }\n        var bValid = isValidDateRange(oJSDate1, oJSDate2);\n        if (bStrict && !bValid) {\n          Log.error(\"StrictParsing: Invalid date range. The given end date is before the start date.\");\n          return [null, null];\n        }\n        return [oJSDate1, oJSDate2];\n      }\n    }\n  }\n  if (this.aFallbackFormats) {\n    var vDate;\n    this.aFallbackFormats.every(function (oFallbackFormat) {\n      vDate = oFallbackFormat.parse(sValue, bUTCInputParameter, bStrict);\n      if (Array.isArray(vDate)) {\n        if (oFallbackFormat.type === mDateFormatTypes.DATETIME_WITH_TIMEZONE) {\n          return false;\n        }\n        return !(vDate[0] && vDate[1]);\n      } else {\n        return !vDate;\n      }\n    });\n    return vDate;\n  }\n  if (!this.oFormatOptions.interval) {\n    return null;\n  } else {\n    return [null, null];\n  }\n};\n\n/**\n * Parse the date pattern string and create a format array from it, which can be\n * used for parsing and formatting the date\n *\n * @param {string} sPattern the CLDR date pattern string\n * @returns {Array} format array\n */\nDateFormat.prototype.parseCldrDatePattern = function (sPattern) {\n  if (mCldrDatePattern[sPattern]) {\n    return mCldrDatePattern[sPattern];\n  }\n  var aFormatArray = [],\n    i,\n    bQuoted = false,\n    oCurrentObject = null,\n    sState = \"\",\n    sNewState = \"\",\n    mAppeared = {},\n    bIntervalStartFound = false;\n  for (i = 0; i < sPattern.length; i++) {\n    var sCurChar = sPattern.charAt(i),\n      sNextChar,\n      sPrevChar,\n      sPrevPrevChar;\n    if (bQuoted) {\n      if (sCurChar === \"'\") {\n        sPrevChar = sPattern.charAt(i - 1);\n        sPrevPrevChar = sPattern.charAt(i - 2);\n        sNextChar = sPattern.charAt(i + 1);\n        // handle abc''def correctly\n        if (sPrevChar === \"'\" && sPrevPrevChar !== \"'\") {\n          bQuoted = false;\n        } else if (sNextChar === \"'\") {\n          // handle 'abc''def' correctly\n\n          i += 1;\n        } else {\n          //  normal quote 'abcdef'\n          bQuoted = false;\n          continue;\n        }\n      }\n      if (sState === \"text\") {\n        oCurrentObject.value += sCurChar;\n      } else {\n        oCurrentObject = {\n          type: \"text\",\n          value: sCurChar\n        };\n        aFormatArray.push(oCurrentObject);\n        sState = \"text\";\n      }\n    } else {\n      if (sCurChar === \"'\") {\n        bQuoted = true;\n      } else if (this.oSymbols[sCurChar]) {\n        sNewState = this.oSymbols[sCurChar].name;\n        if (sState === sNewState) {\n          oCurrentObject.digits++;\n        } else {\n          oCurrentObject = {\n            type: sNewState,\n            symbol: sCurChar,\n            digits: 1\n          };\n          aFormatArray.push(oCurrentObject);\n          sState = sNewState;\n          if (!bIntervalStartFound) {\n            if (mAppeared[sNewState]) {\n              oCurrentObject.repeat = true;\n              bIntervalStartFound = true;\n            } else {\n              mAppeared[sNewState] = true;\n            }\n          }\n        }\n      } else {\n        if (sState === \"text\") {\n          oCurrentObject.value += sCurChar;\n        } else {\n          oCurrentObject = {\n            type: \"text\",\n            value: sCurChar\n          };\n          aFormatArray.push(oCurrentObject);\n          sState = \"text\";\n        }\n      }\n    }\n  }\n  mCldrDatePattern[sPattern] = aFormatArray;\n  return aFormatArray;\n};\n\n/**\n * Parse a date string relative to the current date.\n *\n * @param {string} sValue the string containing a formatted date/time value\n * @param {boolean} [bUTC] whether to use UTC, if no timezone is contained\n * @returns {Date|null} the parsed value or <code>null</code> if relative parsing not possible\n * @private\n */\nDateFormat.prototype.parseRelative = function (sValue, bUTC) {\n  var aPatterns, oEntry, rPattern, oResult, iValue;\n  if (!sValue) {\n    return null;\n  }\n  aPatterns = this.oLocaleData.getRelativePatterns(this.aRelativeParseScales, this.oFormatOptions.relativeStyle);\n  for (var i = 0; i < aPatterns.length; i++) {\n    oEntry = aPatterns[i];\n    rPattern = new RegExp(\"^\\\\s*\" + oEntry.pattern.replace(/\\{0\\}/, \"(\\\\d+)\") + \"\\\\s*$\", \"i\");\n    oResult = rPattern.exec(sValue);\n    if (oResult) {\n      if (oEntry.value !== undefined) {\n        return computeRelativeDate(oEntry.value, oEntry.scale);\n      } else {\n        iValue = parseInt(oResult[1]);\n        return computeRelativeDate(iValue * oEntry.sign, oEntry.scale);\n      }\n    }\n  }\n  function computeRelativeDate(iDiff, sScale) {\n    var oResult = UI5Date.getInstance();\n    if (bUTC) {\n      // date part and time part have to be set individually\n      oResult.setUTCFullYear(oResult.getFullYear(), oResult.getMonth(), oResult.getDate());\n      oResult.setUTCHours(oResult.getHours(), oResult.getMinutes(), oResult.getSeconds(), oResult.getMilliseconds());\n      // eslint-disable-next-line default-case\n      switch (sScale) {\n        case \"second\":\n          oResult.setUTCSeconds(oResult.getUTCSeconds() + iDiff);\n          break;\n        case \"minute\":\n          oResult.setUTCMinutes(oResult.getUTCMinutes() + iDiff);\n          break;\n        case \"hour\":\n          oResult.setUTCHours(oResult.getUTCHours() + iDiff);\n          break;\n        case \"day\":\n          oResult.setUTCDate(oResult.getUTCDate() + iDiff);\n          break;\n        case \"week\":\n          oResult.setUTCDate(oResult.getUTCDate() + iDiff * 7);\n          break;\n        case \"month\":\n          oResult.setUTCMonth(oResult.getUTCMonth() + iDiff);\n          break;\n        case \"quarter\":\n          oResult.setUTCMonth(oResult.getUTCMonth() + iDiff * 3);\n          break;\n        case \"year\":\n          oResult.setUTCFullYear(oResult.getUTCFullYear() + iDiff);\n          break;\n      }\n    } else {\n      // eslint-disable-next-line default-case\n      switch (sScale) {\n        case \"second\":\n          oResult.setSeconds(oResult.getSeconds() + iDiff);\n          break;\n        case \"minute\":\n          oResult.setMinutes(oResult.getMinutes() + iDiff);\n          break;\n        case \"hour\":\n          oResult.setHours(oResult.getHours() + iDiff);\n          break;\n        case \"day\":\n          oResult.setDate(oResult.getDate() + iDiff);\n          break;\n        case \"week\":\n          oResult.setDate(oResult.getDate() + iDiff * 7);\n          break;\n        case \"month\":\n          oResult.setMonth(oResult.getMonth() + iDiff);\n          break;\n        case \"quarter\":\n          oResult.setMonth(oResult.getMonth() + iDiff * 3);\n          break;\n        case \"year\":\n          oResult.setFullYear(oResult.getFullYear() + iDiff);\n          break;\n      }\n    }\n    return oResult;\n  }\n};\n\n/**\n * Format a date relative to the current date.\n *\n * @param {Date} oJSDate the value to format\n * @param {boolean} bUTC whether to use UTC\n * @param {number[]} aRange scale ranges\n * @param {string} sTimezone the IANA timezone ID\n * @returns {string|null} the formatted output value or <code>null</code> if relative formatting is not possible\n * @private\n */\nDateFormat.prototype.formatRelative = function (oJSDate, bUTC, aRange, sTimezone) {\n  var oDateUTC,\n    iDiff,\n    iDiffSeconds,\n    sPattern,\n    // no need to use UI5Date.getInstance as only the UTC timestamp is used\n    oToday = convertToTimezone(new Date(), sTimezone),\n    sScale = this.oFormatOptions.relativeScale || \"day\";\n  iDiffSeconds = (oJSDate.getTime() - oToday.getTime()) / 1000;\n  if (this.oFormatOptions.relativeScale === \"auto\") {\n    sScale = this._getScale(iDiffSeconds, this.aRelativeScales);\n    sScale = fixScaleForMonths(oJSDate, oToday, sScale, iDiffSeconds);\n  }\n  if (!aRange) {\n    aRange = this._mRanges[sScale];\n  }\n\n  // For dates normalize to UTC to avoid issues with summer-/wintertime\n  if (sScale === \"year\" || sScale === \"month\" || sScale === \"day\") {\n    // no need to use UI5Date.getInstance as only the UTC timestamp is used\n    oToday = new Date(Date.UTC(oToday.getUTCFullYear(), oToday.getUTCMonth(), oToday.getUTCDate()));\n\n    // no need to use UI5Date.getInstance as only the UTC timestamp is used\n    oDateUTC = new Date(0);\n\n    // The Date.UTC function doesn't accept years before 1900 (converts years before 100 into 1900 + years).\n    // Using setUTCFullYear to workaround this issue.\n    oDateUTC.setUTCFullYear(oJSDate.getUTCFullYear(), oJSDate.getUTCMonth(), oJSDate.getUTCDate());\n    oJSDate = oDateUTC;\n  }\n  iDiff = this._getDifference(sScale, [oToday, oJSDate]);\n  if (this.oFormatOptions.relativeScale !== \"auto\" && (iDiff < aRange[0] || iDiff > aRange[1])) {\n    //Relative parsing only in range +/- x days\n    return null;\n  }\n  sPattern = this.oLocaleData.getRelativePattern(sScale, iDiff, iDiffSeconds > 0, this.oFormatOptions.relativeStyle);\n  return formatMessage(sPattern, [Math.abs(iDiff)]);\n};\nDateFormat.prototype._mRanges = {\n  second: [-60, 60],\n  minute: [-60, 60],\n  hour: [-24, 24],\n  day: [-6, 6],\n  week: [-4, 4],\n  month: [-12, 12],\n  year: [-10, 10]\n};\nDateFormat.prototype._mScales = {\n  second: 1,\n  // 1\n  minute: 60,\n  // 60\n  hour: 3600,\n  // 60*60\n  day: 86400,\n  // 60*60*24         1 day\n  week: 604800,\n  // 60*60*24*7       7 days\n  month: 2592000,\n  // 60*60*24*30      30 days\n  quarter: 7776000,\n  // 60*60*24*30*3    90 days\n  year: 31536000 // 60*60*24*365     365 days\n};\nDateFormat.prototype._getScale = function (iDiffSeconds, aScales) {\n  // Determines the correct time scale\n  var sScale, sTestScale;\n  iDiffSeconds = Math.abs(iDiffSeconds);\n  for (var i = 0; i < aScales.length; i++) {\n    sTestScale = aScales[i];\n    if (iDiffSeconds >= this._mScales[sTestScale]) {\n      sScale = sTestScale;\n      break;\n    }\n  }\n  if (!sScale) {\n    sScale = aScales[aScales.length - 1];\n  }\n  return sScale;\n};\n\n// Fixes the scale for months/weeks\n// when involved months do not have 30 days\nfunction fixScaleForMonths(oJSDate, oToday, sScale, iDiffSeconds) {\n  var iMonthDiff = Math.abs(oJSDate.getUTCMonth() - oToday.getUTCMonth());\n  if (sScale === \"week\" && iMonthDiff === 2) {\n    // 2 months diff\n    // e.g. March 1st - Jan 31st\n    return \"month\";\n  } else if (sScale === \"week\" && iMonthDiff === 1) {\n    // same day but different month\n    // e.g. March 1st - Feb 1st\n    if (oJSDate.getUTCDate() === oToday.getUTCDate()\n    // future date\n    // e.g. Feb 14th - 15. Mar 15th (29/30 days diff) => 1 month\n    || iDiffSeconds < 0 && oJSDate.getUTCDate() < oToday.getUTCDate()\n    // past date\n    // e.g. Mar 15th - Feb 14th (29/30 days diff) => 1 month\n    || iDiffSeconds > 0 && oJSDate.getUTCDate() > oToday.getUTCDate()) {\n      return \"month\";\n    }\n  } else if (sScale === \"month\" && iMonthDiff === 1) {\n    // future date\n    // e.g. Mar 14th - Apr 13th (30 days diff)\n    if (iDiffSeconds > 0 && oJSDate.getUTCDate() < oToday.getUTCDate()\n    // past date\n    // Feb 14th - Jan 15th (30 days diff)\n    || iDiffSeconds < 0 && oJSDate.getUTCDate() > oToday.getUTCDate()) {\n      return \"week\";\n    }\n  }\n  return sScale;\n}\n\n/**\n * Modifies the Date and sets the values with a higher index to <code>0</code>\n *\n * @param {Date} oDate input date\n * @param {number} iStartIndex index of the value to set to <code>0</code>. Higher indices will also be set to <code>0</code>.\n * 0: FullYear\n * 1: Month\n * 2: Date\n * 3: Hours\n * 4: Minutes\n * 5: Seconds\n * 6: Milliseconds\n * e.g. iStartIndex <code>4</code> will set Minutes, Seconds and Milliseconds to <code>0</code>\n * @returns {Date} copy of the date with the modified values\n */\nfunction cutDateFields(oDate, iStartIndex) {\n  var sMethodName,\n    aFields = [\"FullYear\", \"Month\", \"Date\", \"Hours\", \"Minutes\", \"Seconds\", \"Milliseconds\"],\n    // no need to use UI5Date.getInstance as only the UTC timestamp is used\n    oDateCopy = new Date(oDate.getTime());\n  for (var i = iStartIndex; i < aFields.length; i++) {\n    sMethodName = \"setUTC\" + aFields[iStartIndex];\n    oDateCopy[sMethodName].apply(oDateCopy, [0]);\n  }\n  return oDateCopy;\n}\nvar mRelativeDiffs = {\n  year: function (oFromDate, oToDate) {\n    return oToDate.getUTCFullYear() - oFromDate.getUTCFullYear();\n  },\n  month: function (oFromDate, oToDate) {\n    return oToDate.getUTCMonth() - oFromDate.getUTCMonth() + this.year(oFromDate, oToDate) * 12;\n  },\n  week: function (oFromDate, oToDate, oFormat) {\n    var iFromDay = oFormat._adaptDayOfWeek(oFromDate.getUTCDay());\n    var iToDay = oFormat._adaptDayOfWeek(oToDate.getUTCDay());\n    oFromDate = cutDateFields(oFromDate, 3);\n    oToDate = cutDateFields(oToDate, 3);\n    return (oToDate.getTime() - oFromDate.getTime() - (iToDay - iFromDay) * oFormat._mScales.day * 1000) / (oFormat._mScales.week * 1000);\n  },\n  day: function (oFromDate, oToDate, oFormat) {\n    oFromDate = cutDateFields(oFromDate, 3);\n    oToDate = cutDateFields(oToDate, 3);\n    return (oToDate.getTime() - oFromDate.getTime()) / (oFormat._mScales.day * 1000);\n  },\n  hour: function (oFromDate, oToDate, oFormat) {\n    oFromDate = cutDateFields(oFromDate, 4);\n    oToDate = cutDateFields(oToDate, 4);\n    return (oToDate.getTime() - oFromDate.getTime()) / (oFormat._mScales.hour * 1000);\n  },\n  minute: function (oFromDate, oToDate, oFormat) {\n    oFromDate = cutDateFields(oFromDate, 5);\n    oToDate = cutDateFields(oToDate, 5);\n    return (oToDate.getTime() - oFromDate.getTime()) / (oFormat._mScales.minute * 1000);\n  },\n  second: function (oFromDate, oToDate, oFormat) {\n    oFromDate = cutDateFields(oFromDate, 6);\n    oToDate = cutDateFields(oToDate, 6);\n    return (oToDate.getTime() - oFromDate.getTime()) / (oFormat._mScales.second * 1000);\n  }\n};\nDateFormat.prototype._adaptDayOfWeek = function (iDayOfWeek) {\n  // day of week depends on the format locale\n  // the DateFormat's locale is independent\n  var vCalendarWeekParameter = getCalendarWeekParameter(this.oFormatOptions),\n    iFirstDayOfWeek;\n  if (typeof vCalendarWeekParameter === \"object\") {\n    iFirstDayOfWeek = vCalendarWeekParameter.firstDayOfWeek;\n  } else {\n    iFirstDayOfWeek = CalendarUtils.getWeekConfigurationValues(vCalendarWeekParameter, this.oLocale).firstDayOfWeek;\n  }\n  var iDayNumberOfWeek = iDayOfWeek - (iFirstDayOfWeek - 1);\n  if (iDayNumberOfWeek <= 0) {\n    iDayNumberOfWeek += 7;\n  }\n  return iDayNumberOfWeek;\n};\nDateFormat.prototype._getDifference = function (sScale, aDates) {\n  var oFromDate = aDates[0];\n  var oToDate = aDates[1];\n  return Math.round(mRelativeDiffs[sScale](oFromDate, oToDate, this));\n};\nDateFormat.prototype.getAllowedCharacters = function (aFormatArray) {\n  if (this.oFormatOptions.relative) {\n    return \"\"; //Allow all\n  }\n  var sAllowedCharacters = \"\";\n  var bNumbers = false;\n  var bAll = false;\n  var oPart;\n  for (var i = 0; i < aFormatArray.length; i++) {\n    oPart = aFormatArray[i];\n    switch (oPart.type) {\n      case \"text\":\n        if (sAllowedCharacters.indexOf(oPart.value) < 0) {\n          sAllowedCharacters += oPart.value;\n        }\n        break;\n      case \"day\":\n      case \"year\":\n      case \"weekYear\":\n      case \"dayNumberOfWeek\":\n      case \"weekInYear\":\n      case \"hour0_23\":\n      case \"hour1_24\":\n      case \"hour0_11\":\n      case \"hour1_12\":\n      case \"minute\":\n      case \"second\":\n      case \"fractionalsecond\":\n        if (!bNumbers) {\n          sAllowedCharacters += \"0123456789\";\n          bNumbers = true;\n        }\n        break;\n      case \"month\":\n      case \"monthStandalone\":\n        if (oPart.digits < 3) {\n          if (!bNumbers) {\n            sAllowedCharacters += \"0123456789\";\n            bNumbers = true;\n          }\n        } else {\n          bAll = true;\n        }\n        break;\n      default:\n        bAll = true;\n        break;\n    }\n  }\n  if (bAll) {\n    sAllowedCharacters = \"\";\n  }\n  return sAllowedCharacters;\n};\n\n/**\n * Returns a language-dependent placeholder text according to this instance's format options, for example\n * \"e.g. 12/31/2023\".\n *\n * @returns {string} The language-dependent placeholder text\n *\n * @private\n * @ui5-restricted sap.m\n */\nDateFormat.prototype.getPlaceholderText = function () {\n  var oResourceBundle = Core.getLibraryResourceBundle();\n  return oResourceBundle.getText(\"date.placeholder\", [this.format.apply(this, this.getSampleValue())]);\n};\n\n/**\n * Returns a sample date value.\n *\n * @returns {array}\n *   A sample date value as an array of parameter values as expected by {@link #format}\n *\n * @private\n */\nDateFormat.prototype.getSampleValue = function () {\n  var oDate,\n    iFullYear = UI5Date.getInstance().getFullYear(),\n    bUTC = this.oFormatOptions.UTC;\n  function getDate(iYear, iMonth, iDay, iHours, iMinutes, iSeconds, iMilliseconds) {\n    return bUTC ? UI5Date.getInstance(Date.UTC(iYear, iMonth, iDay, iHours, iMinutes, iSeconds, iMilliseconds)) : UI5Date.getInstance(iYear, iMonth, iDay, iHours, iMinutes, iSeconds, iMilliseconds);\n  }\n  oDate = getDate(iFullYear, 11, 31, 23, 59, 58, 123);\n  if (this.type === mDateFormatTypes.DATETIME_WITH_TIMEZONE) {\n    return [oDate, Configuration.getTimezone()];\n  }\n  if (this.oFormatOptions.interval) {\n    return [[getDate(iFullYear, 11, 22, 9, 12, 34, 567), oDate]];\n  }\n  return [oDate];\n};\nconst rAllRTLCharacters = /[\\u200e\\u200f\\u202a\\u202b\\u202c]/g;\nconst rAllSpaces = /\\s/g;\n\n/**\n * Normalizes the given string by removing RTL characters and replacing special space characters\n * by the standard ASCII space (\\u0020).\n *\n * @param {string} sValue The value to be normalized\n * @return {string} The normalized value\n */\nDateFormat._normalize = function (sValue) {\n  return sValue.replace(rAllRTLCharacters, \"\").replace(rAllSpaces, \" \");\n};\nexport default DateFormat;","map":{"version":3,"names":["Log","formatMessage","deepEqual","extend","CalendarType","Configuration","Core","Locale","LocaleData","Supportability","CalendarUtils","CalendarWeekNumbering","UI5Date","UniversalDate","TimezoneUtil","DateFormat","Error","mDateFormatTypes","DATE","TIME","DATETIME","DATETIME_WITH_TIMEZONE","mCldrDatePattern","checkTimezoneParameterType","sTimezone","String","TypeError","oDateInfo","type","oDefaultFormatOptions","style","relativeScale","relativeStyle","aFallbackFormatOptions","pattern","strictParsing","bShortFallbackFormatOptions","bPatternFallbackWithoutDelimiter","getPattern","oLocaleData","sStyle","sCalendarType","getDatePattern","oRequiredParts","aRelativeScales","aRelativeParseScales","aIntervalCompareFields","oDateTimeInfo","iSlashIndex","indexOf","getCombinedDateTimePattern","substr","_getDateTimeWithTimezoneInfo","oFormatOptions","bShowDate","showDate","undefined","bShowTime","showTime","bShowTimezone","showTimezone","oBaselineType","oTimeInfo","Object","assign","getTimezonePattern","sPattern","applyTimezonePattern","getTimePattern","getInstance","oLocale","getDateInstance","createInstance","getDateTimeInstance","getDateTimeWithTimezoneInstance","sShowTimezone","getTimeInstance","oInfo","bIsFallback","oFormat","create","prototype","getFormatSettings","getFormatLocale","interval","singleIntervalValue","UTC","calendarType","getCalendarType","firstDayOfWeek","minimalDaysInFirstWeek","calendarWeekNumbering","values","includes","format","getCustomDateTimePattern","sSinglePattern","sDelimiter","intervalDelimiter","intervalPatterns","getCustomIntervalPattern","push","getCombinedIntervalPattern","replace","unshift","Array","from","Set","concat","_createFallbackOptionsWithoutDelimiter","reduce","aFallbacks","oOptions","aKeys","keys","bDuplicate","some","oOptions0","length","every","sKey","aFallbackFormats","_createFallbackFormat","init","aMonthsAbbrev","_getMonthsWithAlternatives","aMonthsWide","getMonths","aMonthsNarrow","aMonthsAbbrevSt","_getMonthsStandAloneWithAlternatives","aMonthsWideSt","getMonthsStandAlone","aMonthsNarrowSt","aDaysAbbrev","getDays","aDaysWide","aDaysNarrow","aDaysShort","aDaysAbbrevSt","getDaysStandAlone","aDaysWideSt","aDaysNarrowSt","aDaysShortSt","aQuartersAbbrev","getQuarters","aQuartersWide","aQuartersNarrow","aQuartersAbbrevSt","getQuartersStandAlone","aQuartersWideSt","aQuartersNarrowSt","aErasNarrow","getEras","aErasAbbrev","aErasWide","aDayPeriodsAbbrev","getDayPeriods","aDayPeriodsNarrow","aDayPeriodsWide","oFlexibleDayPeriodsAbbrev","getFlexibleDayPeriods","oFlexibleDayPeriodsNarrow","oFlexibleDayPeriodsWide","oFlexibleDayPeriodsAbbrevSt","getFlexibleDayPeriodsStandAlone","oFlexibleDayPeriodsNarrowSt","oFlexibleDayPeriodsWideSt","aFormatArray","parseCldrDatePattern","sAllowedCharacters","getAllowedCharacters","oParentFormatOptions","map","sBasePattern","rNonDateFields","oDayReplace","regex","oMonthReplace","oYearReplace","sReplace","oParseHelper","isNumber","iCharCode","findNumbers","sValue","iMaxLength","iLength","charCodeAt","startsWithIgnoreCase","sSubstring","sLocale","startsWith","sSubToLocaleUpperCase","toLocaleUpperCase","sValueUpperCase","e","findEntry","aList","iFoundIndex","iMatchedLength","forEach","vEntry","j","isArray","sEntry","index","parseTZ","bColonSeparated","iTZFactor","charAt","sPart","tzDiff","iTZDiffHour","parseInt","iTZDiff","checkValid","sSymbolName","bPartInvalid","_oParseHelper","_createPatternSymbol","mParameters","fnIsNumeric","isNumeric","name","parse","oSymbols","oField","oDate","value","oPart","oConfig","sChar","bValid","iValueIndex","iPatternIndex","sPartValue","_normalize","formatArray","valid","bUTC","iEra","getUTCEra","digits","aErasVariants","i","aVariants","oFound","sCLDRLocaleId","era","iYear","getUTCFullYear","sYear","Japanese","padStart","iExpectedDigits","exactLength","oCurrentDate","iCurrentYear","iCurrentCentury","Math","floor","iYearDiff","year","oWeek","getUTCWeek","getCalendarWeekParameter","iWeekYear","sWeekYear","weekYear","iMonth","getUTCMonth","vName","aMonthsVariants","max","strict","month","iDigits","iWeek","week","sWeek","getCalendarWeek","rWeekNumber","RegExp","oResult","exec","iDate","getUTCDate","iDay","day","iQuarter","getUTCQuarter","aQuartersVariants","quarter","getUTCDay","aDaysVariants","dayOfWeek","_adaptDayOfWeek","dayNumberOfWeek","iDayPeriod","getUTCDayPeriod","rAMPM","bAMPMAlternativeCase","oEntry","aMatch","aDayPeriodsVariants","match","removeSpacesAndDots","sDayPeriod","pm","bContainsHour","oFormatElement","symbol","sFlexibleDayPeriod","getFlexibleDayPeriodOfTime","getUTCHours","getUTCMinutes","oVariant","aFlexibleDayPeriodVariants","flexDayPeriod","iHours","hour","sHours","bPM","dateValue","iMinutes","minute","iSeconds","getUTCSeconds","second","iMilliseconds","getUTCMilliseconds","sMilliseconds","sFractionalseconds","padEnd","millisecond","getTimezoneLong","getTimezoneShort","iTimezoneOffset","calculateOffset","sTimeZone","iTZOffset","abs","bPositiveOffset","iHourOffset","iMinuteOffset","oTZ","substring","error","oParsedTZ","getTimezoneTranslations","oTimezoneParsed","timezone","mTimezoneTranslations","aTimezoneTranslations","oTimezoneResult","sCurrentValue","slice","isValidTimezone","_format","oJSDate","relative","sRes","formatRelative","relativeRange","aBuffer","sResult","sSymbol","join","collectOriginInfo","originInfo","source","locale","toString","vJSDate","getTimezone","convertToTimezone","isValidDateObject","_formatInterval","getLanguage","_useCustomIntervalDelimiter","oDiffFields","aTokens","_parseSkeletonFormat","oToken","group","aJSDates","oFromDate","oToDate","_getDiffFields","repeat","mFieldToGroup","Era","FullYear","Quarter","Month","Week","Date","DayPeriod","Hours","Minutes","Seconds","aDates","bDiffFound","mDiff","sField","sGetterPrefix","sMethodName","sFieldGroup","vFromValue","apply","vToValue","_parse","bStrict","oNextPart","oPrevPart","sSubValue","oDateValue","lastTimezonePatternSymbol","iIndex","oParseConf","that","getSymbol","oPart0","_parseInterval","aDateValues","iRepeat","bind","fnCreateDate","setUTCEra","getCurrentEra","setUTCFullYear","setUTCHours","setUTCMinutes","setUTCSeconds","setUTCMilliseconds","setUTCWeek","setUTCDate","getJSDate","mergeWithoutOverwrite","object1","object2","oMergedObject","hasOwnProperty","isValidDateRange","oStartDate","oEndDate","getTime","isNaN","bUTCInputParameter","trim","parseRelative","oJSDate1","oJSDate2","oDateValue1","oDateValue2","vDate","oFallbackFormat","bQuoted","oCurrentObject","sState","sNewState","mAppeared","bIntervalStartFound","sCurChar","sNextChar","sPrevChar","sPrevPrevChar","aPatterns","rPattern","iValue","getRelativePatterns","computeRelativeDate","scale","sign","iDiff","sScale","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","setUTCMonth","setSeconds","setMinutes","setHours","setDate","setMonth","setFullYear","aRange","oDateUTC","iDiffSeconds","oToday","_getScale","fixScaleForMonths","_mRanges","_getDifference","getRelativePattern","_mScales","aScales","sTestScale","iMonthDiff","cutDateFields","iStartIndex","aFields","oDateCopy","mRelativeDiffs","iFromDay","iToDay","iDayOfWeek","vCalendarWeekParameter","iFirstDayOfWeek","getWeekConfigurationValues","iDayNumberOfWeek","round","bNumbers","bAll","getPlaceholderText","oResourceBundle","getLibraryResourceBundle","getText","getSampleValue","iFullYear","rAllRTLCharacters","rAllSpaces"],"sources":["/home/user/projects/reactproj/node_modules/@ui5/webcomponents-localization/dist/sap/ui/core/format/DateFormat.js"],"sourcesContent":["/*!\n * OpenUI5\n * (c) Copyright 2009-2024 SAP SE or an SAP affiliate company.\n * Licensed under the Apache License, Version 2.0 - see LICENSE.txt.\n */\n// Provides class sap.ui.core.format.DateFormat\nimport Log from \"../../../base/Log.js\";\nimport formatMessage from \"../../../base/strings/formatMessage.js\";\nimport deepEqual from \"../../../base/util/deepEqual.js\";\nimport extend from \"../../../base/util/extend.js\";\nimport CalendarType from \"../CalendarType.js\";\nimport Configuration from \"../Configuration.js\";\nimport Core from \"../Core.js\";\nimport Locale from \"../Locale.js\";\nimport LocaleData from \"../LocaleData.js\";\nimport Supportability from \"../Supportability.js\";\nimport CalendarUtils from \"../date/CalendarUtils.js\";\nimport CalendarWeekNumbering from \"../date/CalendarWeekNumbering.js\";\nimport UI5Date from \"../date/UI5Date.js\";\nimport UniversalDate from \"../date/UniversalDate.js\";\nimport TimezoneUtil from \"./TimezoneUtil.js\";\n/**\n * Constructor for DateFormat - must not be used:\n * <ul>\n *   <li>To get a {@link sap.ui.core.format.DateFormat} instance, please use {@link sap.ui.core.format.DateFormat.getDateInstance}, {@link sap.ui.core.format.DateFormat.getDateTimeInstance} or {@link sap.ui.core.format.DateFormat.getTimeInstance}</li>\n *   <li>To get a {@link sap.ui.core.format.DateFormat.DateTimeWithTimezone} instance, please use {@link sap.ui.core.format.DateFormat.getDateTimeWithTimezoneInstance}</li>\n * </ul>\n *\n * @class\n * The DateFormat is a static class for formatting and parsing single date and time values or date and time intervals according\n * to a set of format options.\n *\n * Important:\n * Every Date is converted with the timezone taken from {@link sap.ui.core.Configuration#getTimezone}.\n * The timezone falls back to the browser's local timezone.\n *\n * Supported format options are pattern based on Unicode LDML Date Format notation. Please note that only a subset of the LDML date symbols\n * is supported.\n * If no pattern is specified a default pattern according to the locale settings is used.\n *\n * Documentation links:\n * <ul>\n *   <li>{@link topic:91f2eba36f4d1014b6dd926db0e91070 Date Format}</li>\n *   <li>{@link http://unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table}</li>\n * </ul>\n *\n * @public\n * @hideconstructor\n * @alias sap.ui.core.format.DateFormat\n */\nvar DateFormat = function () {\n  // Do not use the constructor\n  throw new Error();\n};\n\n/**\n * Internal enumeration to differentiate DateFormat types\n */\nvar mDateFormatTypes = {\n  DATE: \"date\",\n  TIME: \"time\",\n  DATETIME: \"datetime\",\n  DATETIME_WITH_TIMEZONE: \"datetimeWithTimezone\"\n};\n\n// Cache for parsed CLDR DatePattern\nvar mCldrDatePattern = {};\n\n/**\n * Timezone parameter type check\n *\n * @param {string} sTimezone The timezone to check\n * @throws {TypeError} Thrown if the parameter <code>sTimezone</code> is provided and has the wrong type.\n */\nvar checkTimezoneParameterType = function (sTimezone) {\n  if (typeof sTimezone !== \"string\" && !(sTimezone instanceof String) && sTimezone != null) {\n    throw new TypeError(\"The given timezone must be a string.\");\n  }\n};\nDateFormat.oDateInfo = {\n  type: mDateFormatTypes.DATE,\n  oDefaultFormatOptions: {\n    style: \"medium\",\n    relativeScale: \"day\",\n    relativeStyle: \"wide\"\n  },\n  aFallbackFormatOptions: [{\n    style: \"short\"\n  }, {\n    style: \"medium\"\n  }, {\n    pattern: \"yyyy-MM-dd\"\n  }, {\n    pattern: \"yyyyMMdd\",\n    strictParsing: true\n  }],\n  bShortFallbackFormatOptions: true,\n  bPatternFallbackWithoutDelimiter: true,\n  getPattern: function (oLocaleData, sStyle, sCalendarType) {\n    return oLocaleData.getDatePattern(sStyle, sCalendarType);\n  },\n  oRequiredParts: {\n    \"text\": true,\n    \"year\": true,\n    \"weekYear\": true,\n    \"month\": true,\n    \"day\": true\n  },\n  aRelativeScales: [\"year\", \"month\", \"week\", \"day\"],\n  aRelativeParseScales: [\"year\", \"quarter\", \"month\", \"week\", \"day\", \"hour\", \"minute\", \"second\"],\n  aIntervalCompareFields: [\"Era\", \"FullYear\", \"Quarter\", \"Month\", \"Week\", \"Date\"]\n};\nDateFormat.oDateTimeInfo = {\n  type: mDateFormatTypes.DATETIME,\n  oDefaultFormatOptions: {\n    style: \"medium\",\n    relativeScale: \"auto\",\n    relativeStyle: \"wide\"\n  },\n  aFallbackFormatOptions: [{\n    style: \"short\"\n  }, {\n    style: \"medium\"\n  }, {\n    pattern: \"yyyy-MM-dd'T'HH:mm:ss\"\n  }, {\n    pattern: \"yyyyMMdd HHmmss\"\n  }],\n  getPattern: function (oLocaleData, sStyle, sCalendarType) {\n    // If style is mixed (\"medium/short\") split it and pass both parts separately\n    var iSlashIndex = sStyle.indexOf(\"/\");\n    if (iSlashIndex > 0) {\n      return oLocaleData.getCombinedDateTimePattern(sStyle.substr(0, iSlashIndex), sStyle.substr(iSlashIndex + 1), sCalendarType);\n    } else {\n      return oLocaleData.getCombinedDateTimePattern(sStyle, sStyle, sCalendarType);\n    }\n  },\n  oRequiredParts: {\n    \"text\": true,\n    \"year\": true,\n    \"weekYear\": true,\n    \"month\": true,\n    \"day\": true,\n    \"hour0_23\": true,\n    \"hour1_24\": true,\n    \"hour0_11\": true,\n    \"hour1_12\": true\n  },\n  aRelativeScales: [\"year\", \"month\", \"week\", \"day\", \"hour\", \"minute\", \"second\"],\n  aRelativeParseScales: [\"year\", \"quarter\", \"month\", \"week\", \"day\", \"hour\", \"minute\", \"second\"],\n  aIntervalCompareFields: [\"Era\", \"FullYear\", \"Quarter\", \"Month\", \"Week\", \"Date\", \"DayPeriod\", \"Hours\", \"Minutes\", \"Seconds\"]\n};\n\n/**\n * Retrieves info object for timezone instance\n *\n * @param {object} oFormatOptions the format options, relevant are: showDate, showTime and showTimezone\n * @returns {object} info object\n * @private\n */\nDateFormat._getDateTimeWithTimezoneInfo = function (oFormatOptions) {\n  var bShowDate = oFormatOptions.showDate === undefined || oFormatOptions.showDate;\n  var bShowTime = oFormatOptions.showTime === undefined || oFormatOptions.showTime;\n  var bShowTimezone = oFormatOptions.showTimezone === undefined || oFormatOptions.showTimezone;\n  var oBaselineType = DateFormat.oDateTimeInfo;\n  if (bShowDate && !bShowTime) {\n    oBaselineType = DateFormat.oDateInfo;\n  } else if (!bShowDate && bShowTime) {\n    oBaselineType = DateFormat.oTimeInfo;\n  }\n  return Object.assign({}, oBaselineType, {\n    type: mDateFormatTypes.DATETIME_WITH_TIMEZONE,\n    // This function is used to transform the pattern of the fallbackFormatOptions to a timezone pattern.\n    getTimezonePattern: function (sPattern) {\n      if (!bShowDate && !bShowTime && bShowTimezone) {\n        return \"VV\";\n      } else if (!bShowTimezone) {\n        return sPattern;\n      } else {\n        return sPattern + \" VV\";\n      }\n    },\n    getPattern: function (oLocaleData, sStyle, sCalendarType) {\n      if (!bShowDate && !bShowTime && bShowTimezone) {\n        return \"VV\";\n      }\n      if (!bShowTimezone) {\n        return oBaselineType.getPattern(oLocaleData, sStyle, sCalendarType);\n      }\n      var sPattern = oBaselineType.getPattern(oLocaleData, sStyle, sCalendarType);\n      return oLocaleData.applyTimezonePattern(sPattern);\n    }\n  });\n};\nDateFormat.oTimeInfo = {\n  type: mDateFormatTypes.TIME,\n  oDefaultFormatOptions: {\n    style: \"medium\",\n    relativeScale: \"auto\",\n    relativeStyle: \"wide\"\n  },\n  aFallbackFormatOptions: [{\n    style: \"short\"\n  }, {\n    style: \"medium\"\n  }, {\n    pattern: \"HH:mm:ss\"\n  }, {\n    pattern: \"HHmmss\"\n  }],\n  getPattern: function (oLocaleData, sStyle, sCalendarType) {\n    return oLocaleData.getTimePattern(sStyle, sCalendarType);\n  },\n  oRequiredParts: {\n    \"text\": true,\n    \"hour0_23\": true,\n    \"hour1_24\": true,\n    \"hour0_11\": true,\n    \"hour1_12\": true\n  },\n  aRelativeScales: [\"hour\", \"minute\", \"second\"],\n  aRelativeParseScales: [\"year\", \"quarter\", \"month\", \"week\", \"day\", \"hour\", \"minute\", \"second\"],\n  aIntervalCompareFields: [\"DayPeriod\", \"Hours\", \"Minutes\", \"Seconds\"]\n};\n\n/**\n * @see sap.ui.core.format.DateFormat.getDateInstance\n */\nDateFormat.getInstance = function (oFormatOptions, oLocale) {\n  return this.getDateInstance(oFormatOptions, oLocale);\n};\n\n/**\n * Get a date instance of the DateFormat, which can be used for formatting.\n *\n * @param {object} [oFormatOptions] Object which defines the format options\n * @param {sap.ui.core.date.CalendarWeekNumbering} [oFormatOptions.calendarWeekNumbering] since 1.108.0 specifies the calendar week numbering.\n *   If specified, this overwrites <code>oFormatOptions.firstDayOfWeek</code> and <code>oFormatOptions.minimalDaysInFirstWeek</code>.\n * @param {int} [oFormatOptions.firstDayOfWeek] since 1.105.0 specifies the first day of the week starting with <code>0</code> (which is Sunday); if not defined, the value taken from the locale is used\n * @param {int} [oFormatOptions.minimalDaysInFirstWeek] since 1.105.0 minimal days at the beginning of the year which define the first calendar week; if not defined, the value taken from the locale is used\n * @param {string} [oFormatOptions.format] since 1.34.0 contains pattern symbols (e.g. \"yMMMd\" or \"Hms\") which will be converted into the pattern in the used locale, which matches the wanted symbols best.\n *  The symbols must be in canonical order, that is: Era (G), Year (y/Y), Quarter (q/Q), Month (M/L), Week (w), Day-Of-Week (E/e/c), Day (d), Hour (h/H/k/K/j/J), Minute (m), Second (s), Timezone (z/Z/v/V/O/X/x)\n *  See {@link http://unicode.org/reports/tr35/tr35-dates.html#availableFormats_appendItems}\n * @param {string} [oFormatOptions.pattern] a data pattern in LDML format. It is not verified whether the pattern represents only a date.\n * @param {string} [oFormatOptions.style] can be either 'short, 'medium', 'long' or 'full'. If no pattern is given, a locale dependent default date pattern of that style is used from the LocaleData class.\n * @param {boolean} [oFormatOptions.strictParsing] if true, by parsing it is checked if the value is a valid date\n * @param {boolean} [oFormatOptions.relative] if true, the date is formatted relatively to todays date if it is within the given day range, e.g. \"today\", \"1 day ago\", \"in 5 days\"\n * @param {int[]} [oFormatOptions.relativeRange] the day range used for relative formatting. If <code>oFormatOptions.relativeScale</code> is set to default value 'day', the relativeRange is by default [-6, 6], which means only the last 6 days, today and the next 6 days are formatted relatively. Otherwise when <code>oFormatOptions.relativeScale</code> is set to 'auto', all dates are formatted relatively.\n * @param {string} [oFormatOptions.relativeScale=\"day\"] if 'auto' is set, new relative time format is switched on for all Date/Time Instances. The relative scale is chosen depending on the difference between the given date and now.\n * @param {string} [oFormatOptions.relativeStyle=\"wide\"] since 1.32.10, 1.34.4 the style of the relative format. The valid values are \"wide\", \"short\", \"narrow\"\n * @param {boolean} [oFormatOptions.interval=false] since 1.48.0 if true, the {@link sap.ui.core.format.DateFormat#format format} method expects an array with two dates as the first argument and formats them as interval. Further interval \"Jan 10, 2008 - Jan 12, 2008\" will be formatted as \"Jan 10-12, 2008\" if the 'format' option is set with necessary symbols.\n *   Otherwise the two given dates are formatted separately and concatenated with local dependent pattern.\n * @param {string} [oFormatOptions.intervalDelimiter]\n *   Since 1.113.0, a delimiter for intervals. With a given interval delimiter a specific interval format is\n *   created. <b>Example:</b> If <code>oFormatOptions.intervalDelimiter</code> is set to \"...\", an interval would be\n *   given as \"Jan 10, 2008...Feb 12, 2008\".\n *   <b>Note:</b> If this format option is set, the locale-specific interval notation is overruled, for example\n *   \"Jan 10 – Feb 12, 2008\" becomes \"Jan 10, 2008...Feb 12, 2008\".\n * @param {boolean} [oFormatOptions.singleIntervalValue=false] Only relevant if oFormatOptions.interval is set to 'true'. This allows to pass an array with only one date object to the {@link sap.ui.core.format.DateFormat#format format} method.\n * @param {boolean} [oFormatOptions.UTC] if true, the date is formatted and parsed as UTC instead of the local timezone\n * @param {sap.ui.core.CalendarType} [oFormatOptions.calendarType] The calender type which is used to format and parse the date. This value is by default either set in configuration or calculated based on current locale.\n * @param {sap.ui.core.Locale} [oLocale] Locale to ask for locale specific texts/settings\n * @ui5-omissible-params oFormatOptions\n * @return {sap.ui.core.format.DateFormat} date instance of the DateFormat\n * @static\n * @public\n * @throws {TypeError} If:\n * <ul>\n *   <li>The <code>calendarWeekNumbering</code> format option has an unsupported value, or</li>\n *   <li>only one of the <code>firstDayOfWeek</code> and <code>minimalDaysInFirstWeek</code> parameters was provided.</li>\n * </ul>\n */\nDateFormat.getDateInstance = function (oFormatOptions, oLocale) {\n  return this.createInstance(oFormatOptions, oLocale, this.oDateInfo);\n};\n\n/**\n * Get a datetime instance of the DateFormat, which can be used for formatting.\n *\n * @param {object} [oFormatOptions] Object which defines the format options\n * @param {sap.ui.core.date.CalendarWeekNumbering} [oFormatOptions.calendarWeekNumbering] since 1.108.0 specifies the calendar week numbering.\n *   If specified, this overwrites <code>oFormatOptions.firstDayOfWeek</code> and <code>oFormatOptions.minimalDaysInFirstWeek</code>.\n * @param {int} [oFormatOptions.firstDayOfWeek] since 1.105.0 specifies the first day of the week starting with <code>0</code> (which is Sunday); if not defined, the value taken from the locale is used\n * @param {int} [oFormatOptions.minimalDaysInFirstWeek] since 1.105.0 minimal days at the beginning of the year which define the first calendar week; if not defined, the value taken from the locale is used\n * @param {string} [oFormatOptions.format] since 1.34.0 contains pattern symbols (e.g. \"yMMMd\" or \"Hms\") which will be converted into the pattern in the used locale, which matches the wanted symbols best.\n *  The symbols must be in canonical order, that is: Era (G), Year (y/Y), Quarter (q/Q), Month (M/L), Week (w), Day-Of-Week (E/e/c), Day (d), Hour (h/H/k/K/j/J), Minute (m), Second (s), Timezone (z/Z/v/V/O/X/x)\n *  See http://unicode.org/reports/tr35/tr35-dates.html#availableFormats_appendItems\n * @param {string} [oFormatOptions.pattern] a datetime pattern in LDML format. It is not verified whether the pattern represents a full datetime.\n * @param {string} [oFormatOptions.style] can be either 'short, 'medium', 'long' or 'full'. For datetime you can also define mixed styles, separated with a slash, where the first part is the date style and the second part is the time style (e.g. \"medium/short\"). If no pattern is given, a locale dependent default datetime pattern of that style is used from the LocaleData class.\n * @param {boolean} [oFormatOptions.strictParsing] if true, by parsing it is checked if the value is a valid datetime\n * @param {boolean} [oFormatOptions.relative] if true, the date is formatted relatively to today's date if it is within the given day range, e.g. \"today\", \"1 day ago\", \"in 5 days\"\n * @param {int[]} [oFormatOptions.relativeRange] the day range used for relative formatting. If <code>oFormatOptions.relativeScale</code> is set to default value 'day', the relativeRange is by default [-6, 6], which means only the last 6 days, today and the next 6 days are formatted relatively. Otherwise when <code>oFormatOptions.relativeScale</code> is set to 'auto', all dates are formatted relatively.\n * @param {string} [oFormatOptions.relativeScale=\"day\"] if 'auto' is set, new relative time format is switched on for all Date/Time Instances. The relative scale is chosen depending on the difference between the given date and now.\n * @param {string} [oFormatOptions.relativeStyle=\"wide\"] since 1.32.10, 1.34.4 the style of the relative format. The valid values are \"wide\", \"short\", \"narrow\"\n * @param {boolean} [oFormatOptions.interval=false] since 1.48.0 if true, the {@link sap.ui.core.format.DateFormat#format format} method expects an array with two dates as the first argument and formats them as interval. Further interval \"Jan 10, 2008 - Jan 12, 2008\" will be formatted as \"Jan 10-12, 2008\" if the 'format' option is set with necessary symbols.\n *   Otherwise the two given dates are formatted separately and concatenated with local dependent pattern.\n * @param {string} [oFormatOptions.intervalDelimiter]\n *   Since 1.113.0, a delimiter for intervals. With a given interval delimiter a specific interval format is\n *   created. <b>Example:</b> If <code>oFormatOptions.intervalDelimiter</code> is set to \"...\", an interval would be\n *   given as \"Jan 10, 2008, 9:15:00 AM...Jan 10, 2008, 11:45:00 AM\".\n *   <b>Note:</b> If this format option is set, the locale-specific interval notation is overruled, for example\n *   \"Jan 10, 2008, 9:15 – 11:45 AM\" becomes \"Jan 10, 2008, 9:15 AM...Jan 10, 2008, 11:45 AM\".\n * @param {boolean} [oFormatOptions.singleIntervalValue=false] Only relevant if oFormatOptions.interval is set to 'true'. This allows to pass an array with only one date object to the {@link sap.ui.core.format.DateFormat#format format} method.\n * @param {boolean} [oFormatOptions.UTC] if true, the date is formatted and parsed as UTC instead of the local timezone\n * @param {sap.ui.core.CalendarType} [oFormatOptions.calendarType] The calender type which is used to format and parse the date. This value is by default either set in configuration or calculated based on current locale.\n * @param {sap.ui.core.Locale} [oLocale] Locale to ask for locale specific texts/settings\n * @ui5-omissible-params oFormatOptions\n * @return {sap.ui.core.format.DateFormat} datetime instance of the DateFormat\n * @static\n * @public\n * @throws {TypeError} If:\n * <ul>\n *   <li>The <code>calendarWeekNumbering</code> format option has an unsupported value, or</li>\n *   <li>only one of the <code>firstDayOfWeek</code> and <code>minimalDaysInFirstWeek</code> parameters was provided.</li>\n * </ul>\n */\nDateFormat.getDateTimeInstance = function (oFormatOptions, oLocale) {\n  return this.createInstance(oFormatOptions, oLocale, this.oDateTimeInfo);\n};\n\n/**\n * Interface for a timezone-specific DateFormat, which is able to format and parse a date\n * based on a given timezone. The timezone is used to convert the given date, and also for\n * timezone-related pattern symbols. The timezone is an IANA timezone ID, e.g. \"America/New_York\".\n *\n * @see sap.ui.core.format.DateFormat\n *\n * @author SAP SE\n * @since 1.99\n * @interface\n * @name sap.ui.core.format.DateFormat.DateTimeWithTimezone\n * @public\n */\n\n/**\n * Format a date object to a string according to the given timezone and format options.\n *\n * @example <caption>Format option showTimezone: true (default)</caption>\n * var oDate = UI5Date.getInstance(\"2021-12-24T13:37:00Z\");\n *\n * DateFormat.getDateTimeWithTimezoneInstance().format(oDate, \"Europe/Berlin\");\n * // output: \"Dec 24, 2021, 2:37:00 PM Europe, Berlin\"\n *\n * DateFormat.getDateTimeWithTimezoneInstance().format(oDate, \"America/New_York\");\n * // output: \"Dec 24, 2021, 8:37:00 AM Americas, New York\"\n *\n * @example <caption>Format option showTimezone: false</caption>\n * var oDate = UI5Date.getInstance(\"2021-12-24T13:37:00Z\");\n * DateFormat.getDateTimeWithTimezoneInstance({showTimezone: false}).format(oDate, \"America/New_York\");\n * // output: \"Dec 24, 2021, 8:37:00 AM\"\n *\n * @example <caption>Format option showDate: false and showTime:false</caption>\n * var oDate = UI5Date.getInstance(\"2021-12-24T13:37:00Z\");\n * DateFormat.getDateTimeWithTimezoneInstance({showDate: false, showTime: false}).format(oDate, \"America/New_York\");\n * // output: \"Americas, New York\"\n *\n * @param {Date} oJSDate The date to format\n * @param {string} [sTimezone] The IANA timezone ID in which the date will be calculated and\n *   formatted e.g. \"America/New_York\". If the parameter is omitted, <code>null</code> or an empty string, the timezone\n *   will be taken from {@link sap.ui.core.Configuration#getTimezone}. For an invalid IANA timezone ID, an empty string will be returned.\n * @throws {TypeError} Thrown if the parameter <code>sTimezone</code> is provided and has the wrong type.\n * @return {string} the formatted output value. If an invalid date or timezone is given, an empty string is returned.\n * @name sap.ui.core.format.DateFormat.DateTimeWithTimezone.format\n * @function\n * @public\n * @since 1.99\n */\n\n/**\n * Parse a string which is formatted according to the given format options to an array\n * containing a date object and the timezone.\n *\n * @example <caption>Format option showTimezone: true (default)</caption>\n * var oDate = UI5Date.getInstance(\"2021-12-24T13:37:00Z\");\n *\n * DateFormat.getDateTimeWithTimezoneInstance().parse(\"Dec 24, 2021, 2:37:00 PM Europe, Berlin\", \"Europe/Berlin\");\n * // output: [oDate, \"Europe/Berlin\"]\n *\n * DateFormat.getDateTimeWithTimezoneInstance().parse(\"Dec 24, 2021, 8:37:00 AM Americas, New York\", \"America/New_York\");\n * // output: [oDate, \"America/New_York\"]\n *\n * @example <caption>Format option showTimezone: false</caption>\n * var oDate = UI5Date.getInstance(\"2021-12-24T13:37:00Z\");\n * DateFormat.getDateTimeWithTimezoneInstance({showTimezone: false}).parse(\"Dec 24, 2021, 8:37:00 AM\", \"America/New_York\");\n * // output: [oDate, undefined]\n *\n * @example <caption>Format option showDate: false and showTime: false</caption>\n * DateFormat.getDateTimeWithTimezoneInstance({showDate: false, showTime: false}).parse(\"Americas, New York\", \"America/New_York\");\n * // output: [undefined, \"America/New_York\"]\n *\n * @param {string} sValue the string containing a formatted date/time value\n * @param {string} [sTimezone] The IANA timezone ID which should be used to convert the date\n *   e.g. \"America/New_York\". If the parameter is omitted, <code>null</code> or an empty string, the timezone will be taken\n *   from {@link sap.ui.core.Configuration#getTimezone}. For an invalid IANA timezone ID, <code>null</code> will be returned.\n * @param {boolean} [bStrict] Whether to be strict with regards to the value ranges of date fields,\n * e.g. for a month pattern of <code>MM</code> and a value range of [1-12]\n * <code>strict</code> ensures that the value is within the range;\n * if it is larger than <code>12</code> it cannot be parsed and <code>null</code> is returned\n * @throws {TypeError} Thrown if one of the following applies:\n *   <ul>\n *       <li>the <code>sTimezone</code> parameter is provided and has the wrong type</li>\n *       <li>only the time is shown (<code>showDate</code> is <code>false</code>), or only the\n *       date is shown (<code>showTime</code> is <code>false</code>)</li>\n *   </ul>\n * @return {Array} the parsed values\n * <ul>\n *   <li>An array containing datetime and timezone depending on the showDate, showTime and showTimezone options\n *     <ul>\n *         <li>(Default): [Date, string], e.g.\n *           [UI5Date.getInstance(\"2021-11-13T13:22:33Z\"), \"America/New_York\"]</li>\n *         <li><code>showTimezone: false</code>: [Date, undefined], e.g.\n *           [UI5Date.getInstance(\"2021-11-13T13:22:33Z\"), undefined]</li>\n *         <li><code>showDate: false, showTime: false</code>: [undefined, string], e.g.\n *           [undefined, \"America/New_York\"]</li>\n *     </ul>\n *   </li>\n * </ul>\n *\n * @public\n * @name sap.ui.core.format.DateFormat.DateTimeWithTimezone.parse\n * @function\n * @since 1.99\n */\n// This method has a TypeScript specific overlay for a better return value documentation,\n// see 'src/sap.ui.core/.dtsgenrc'\n\n/**\n * Get a datetimeWithTimezone instance of the DateFormat, which can be used for formatting.\n *\n * @param {object} [oFormatOptions] An object which defines the format options\n * @param {sap.ui.core.date.CalendarWeekNumbering} [oFormatOptions.calendarWeekNumbering] since 1.108.0 specifies the calendar week numbering.\n *   If specified, this overwrites <code>oFormatOptions.firstDayOfWeek</code> and <code>oFormatOptions.minimalDaysInFirstWeek</code>.\n * @param {int} [oFormatOptions.firstDayOfWeek] since 1.105.0 specifies the first day of the week starting with <code>0</code> (which is Sunday); if not defined, the value taken from the locale is used\n * @param {int} [oFormatOptions.minimalDaysInFirstWeek] since 1.105.0 minimal days at the beginning of the year which define the first calendar week; if not defined, the value taken from the locale is used\n * @param {string} [oFormatOptions.format] A string containing pattern symbols (e.g. \"yMMMd\" or \"Hms\") which will be converted into a pattern for the used locale that matches the wanted symbols best.\n *  The symbols must be in canonical order, that is: Era (G), Year (y/Y), Quarter (q/Q), Month (M/L), Week (w), Day-Of-Week (E/e/c), Day (d), Hour (h/H/k/K/j/J), Minute (m), Second (s), Timezone (z/Z/v/V/O/X/x)\n *  See http://unicode.org/reports/tr35/tr35-dates.html#availableFormats_appendItems\n * @param {string} [oFormatOptions.pattern] a datetime pattern in LDML format. It is not verified whether the pattern represents a full datetime.\n * @param {boolean} [oFormatOptions.showDate=true] Specifies if the date should be displayed.\n *   It is ignored for formatting when an options pattern or a format are supplied.\n * @param {boolean} [oFormatOptions.showTime=true] Specifies if the time should be displayed.\n *   It is ignored for formatting when an options pattern or a format are supplied.\n * @param {boolean} [oFormatOptions.showTimezone=true] Specifies if the timezone should be displayed.\n *   It is ignored for formatting when an options pattern or a format are supplied.\n * @param {string} [oFormatOptions.style] Can be either 'short, 'medium', 'long' or 'full'. For datetime you can also define mixed styles, separated with a slash, where the first part is the date style and the second part is the time style (e.g. \"medium/short\"). If no pattern is given, a locale-dependent default datetime pattern of that style from the LocaleData class is used.\n * @param {boolean} [oFormatOptions.strictParsing] Whether to check by parsing if the value is a valid datetime\n * @param {boolean} [oFormatOptions.relative] Whether the date is formatted relatively to today's date if it is within the given day range, e.g. \"today\", \"1 day ago\", \"in 5 days\"\n * @param {int[]} [oFormatOptions.relativeRange] The day range used for relative formatting. If <code>oFormatOptions.relativeScale</code> is set to the default value 'day', the <code>relativeRange<code> is by default [-6, 6], which means that only the previous 6 and the following 6 days are formatted relatively. If <code>oFormatOptions.relativeScale</code> is set to 'auto', all dates are formatted relatively.\n * @param {string} [oFormatOptions.relativeScale] If 'auto' is set, a new relative time format is switched on for all Date/Time instances. The default value depends on <code>showDate</code> and <code>showTime</code> options.\n * @param {string} [oFormatOptions.relativeStyle=\"wide\"] The style of the relative format. The valid values are \"wide\", \"short\", \"narrow\"\n * @param {sap.ui.core.CalendarType} [oFormatOptions.calendarType] The calendar type which is used to format and parse the date. This value is by default either set in the configuration or calculated based on the current locale.\n * @param {sap.ui.core.Locale} [oLocale] Locale to ask for locale-specific texts/settings\n * @ui5-omissible-params oFormatOptions\n * @throws {TypeError} If an invalid configuration was supplied, i.e. when the\n *   <code>showDate</code>, <code>showTime</code>, and <code>showTimezone</code> format options\n *   are all <code>false</code>\n * @return {sap.ui.core.format.DateFormat.DateTimeWithTimezone} dateTimeWithTimezone instance of the DateFormat\n * @static\n * @public\n * @since 1.99.0\n * @throws {TypeError} If:\n * <ul>\n *   <li>The <code>calendarWeekNumbering</code> format option has an unsupported value, or</li>\n *   <li>only one of the <code>firstDayOfWeek</code> and <code>minimalDaysInFirstWeek</code> parameters was provided.</li>\n * </ul>\n */\nDateFormat.getDateTimeWithTimezoneInstance = function (oFormatOptions, oLocale) {\n  if (oFormatOptions && !(oFormatOptions instanceof Locale)) {\n    /** @deprecated As of version 1.101.0 */\n    (function () {\n      // do not modify the input format options\n      oFormatOptions = Object.assign({}, oFormatOptions);\n      // translate old showTimezone values (backward compatibility)\n      if (typeof oFormatOptions.showTimezone === \"string\") {\n        var sShowTimezone = oFormatOptions.showTimezone;\n        if (oFormatOptions.showDate === undefined && oFormatOptions.showTime === undefined) {\n          if (sShowTimezone === \"Hide\") {\n            oFormatOptions.showTimezone = false;\n          } else if (sShowTimezone === \"Only\") {\n            oFormatOptions.showDate = false;\n            oFormatOptions.showTime = false;\n          }\n        }\n        oFormatOptions.showTimezone = sShowTimezone !== \"Hide\";\n      }\n    })();\n    if (oFormatOptions.showDate === false && oFormatOptions.showTime === false && oFormatOptions.showTimezone === false) {\n      throw new TypeError(\"Invalid Configuration. One of the following format options must be true: \" + \"showDate, showTime or showTimezone.\");\n    }\n  }\n  return this.createInstance(oFormatOptions, oLocale, DateFormat._getDateTimeWithTimezoneInfo(oFormatOptions || {}));\n};\n\n/**\n * Get a time instance of the DateFormat, which can be used for formatting.\n *\n * @param {object} [oFormatOptions] Object which defines the format options\n * @param {sap.ui.core.date.CalendarWeekNumbering} [oFormatOptions.calendarWeekNumbering] since 1.108.0 specifies the calendar week numbering.\n *   If specified, this overwrites <code>oFormatOptions.firstDayOfWeek</code> and <code>oFormatOptions.minimalDaysInFirstWeek</code>.\n * @param {int} [oFormatOptions.firstDayOfWeek] since 1.105.0 specifies the first day of the week starting with <code>0</code> (which is Sunday); if not defined, the value taken from the locale is used\n * @param {int} [oFormatOptions.minimalDaysInFirstWeek] since 1.105.0 minimal days at the beginning of the year which define the first calendar week; if not defined, the value taken from the locale is used\n * @param {string} [oFormatOptions.format] since 1.34.0 contains pattern symbols (e.g. \"yMMMd\" or \"Hms\") which will be converted into the pattern in the used locale, which matches the wanted symbols best.\n *  The symbols must be in canonical order, that is: Era (G), Year (y/Y), Quarter (q/Q), Month (M/L), Week (w), Day-Of-Week (E/e/c), Day (d), Hour (h/H/k/K/j/J), Minute (m), Second (s), Timezone (z/Z/v/V/O/X/x)\n *  See http://unicode.org/reports/tr35/tr35-dates.html#availableFormats_appendItems\n * @param {string} [oFormatOptions.pattern] a time pattern in LDML format. It is not verified whether the pattern only represents a time.\n * @param {string} [oFormatOptions.style] can be either 'short, 'medium', 'long' or 'full'. If no pattern is given, a locale dependent default time pattern of that style is used from the LocaleData class.\n * @param {boolean} [oFormatOptions.strictParsing] if true, by parsing it is checked if the value is a valid time\n * @param {boolean} [oFormatOptions.relative] if true, the date is formatted relatively to todays date if it is within the given day range, e.g. \"today\", \"1 day ago\", \"in 5 days\"\n * @param {int[]} [oFormatOptions.relativeRange] the day range used for relative formatting. If <code>oFormatOptions.relativeScale</code> is set to default value 'day', the relativeRange is by default [-6, 6], which means only the last 6 days, today and the next 6 days are formatted relatively. Otherwise when <code>oFormatOptions.relativeScale</code> is set to 'auto', all dates are formatted relatively.\n * @param {string} [oFormatOptions.relativeScale=\"day\"] if 'auto' is set, new relative time format is switched on for all Date/Time Instances. The relative scale is chosen depending on the difference between the given date and now.\n * @param {string} [oFormatOptions.relativeStyle=\"wide\"] since 1.32.10, 1.34.4 the style of the relative format. The valid values are \"wide\", \"short\", \"narrow\"\n * @param {boolean} [oFormatOptions.interval=false] since 1.48.0 if true, the {@link sap.ui.core.format.DateFormat#format format} method expects an array with two dates as the first argument and formats them as interval. Further interval \"Jan 10, 2008 - Jan 12, 2008\" will be formatted as \"Jan 10-12, 2008\" if the 'format' option is set with necessary symbols.\n *   Otherwise the two given dates are formatted separately and concatenated with local dependent pattern.\n * @param {string} [oFormatOptions.intervalDelimiter]\n *   Since 1.113.0, a delimiter for intervals. With a given interval delimiter a specific interval format is\n *   created. <b>Example:</b> If <code>oFormatOptions.intervalDelimiter</code> is set to \"...\", an interval would be\n *   given as \"09:15 AM...11:45 AM\".\n *   <b>Note:</b> If this format option is set, the locale-specific interval notation is overruled, for example\n *   \"09:15 – 11:45 AM\" becomes \"9:15 AM...11:45 AM\".\n * @param {boolean} [oFormatOptions.singleIntervalValue=false] Only relevant if oFormatOptions.interval is set to 'true'. This allows to pass an array with only one date object to the {@link sap.ui.core.format.DateFormat#format format} method.\n * @param {boolean} [oFormatOptions.UTC] if true, the time is formatted and parsed as UTC instead of the local timezone\n * @param {sap.ui.core.CalendarType} [oFormatOptions.calendarType] The calender type which is used to format and parse the date. This value is by default either set in configuration or calculated based on current locale.\n * @param {sap.ui.core.Locale} [oLocale] Locale to ask for locale specific texts/settings\n * @ui5-omissible-params oFormatOptions\n * @return {sap.ui.core.format.DateFormat} time instance of the DateFormat\n * @static\n * @public\n * @throws {TypeError} If:\n * <ul>\n *   <li>The <code>calendarWeekNumbering</code> format option has an unsupported value, or</li>\n *   <li>only one of the <code>firstDayOfWeek</code> and <code>minimalDaysInFirstWeek</code> parameters was provided.</li>\n * </ul>\n */\nDateFormat.getTimeInstance = function (oFormatOptions, oLocale) {\n  return this.createInstance(oFormatOptions, oLocale, this.oTimeInfo);\n};\n\n/**\n * Create instance of the DateFormat.\n *\n * @param {object} [oFormatOptions] Object which defines the format options\n * @param {sap.ui.core.Locale} [oLocale] Locale to ask for locale specific texts/settings\n * @param {object} [oInfo] Info information common to all instances of the created \"type\",\n *   e.g. default format options\n * @param {boolean} [bIsFallback=false] Whether this is a fallback format instance\n * @return {sap.ui.core.format.DateFormat} time instance of the DateFormat\n * @static\n * @private\n * @throws {TypeError} If:\n * <ul>\n *   <li>The <code>calendarWeekNumbering</code> format option has an unsupported value, or</li>\n *   <li>only one of the <code>firstDayOfWeek</code> and <code>minimalDaysInFirstWeek</code> parameters was provided.</li>\n * </ul>\n */\nDateFormat.createInstance = function (oFormatOptions, oLocale, oInfo, bIsFallback) {\n  var aFallbackFormatOptions, oFormat, sPattern;\n\n  // Create an instance of the DateFormat\n  oFormat = Object.create(this.prototype);\n\n  // Handle optional parameters\n  if (oFormatOptions instanceof Locale) {\n    oLocale = oFormatOptions;\n    oFormatOptions = undefined;\n  }\n\n  // Get Locale and LocaleData to use\n  if (!oLocale) {\n    oLocale = Configuration.getFormatSettings().getFormatLocale();\n  }\n  oFormat.oLocale = oLocale;\n  oFormat.oLocaleData = LocaleData.getInstance(oLocale);\n\n  // Extend the default format options with custom format options and retrieve the pattern\n  // from the LocaleData, in case it is not defined yet\n  oFormat.oFormatOptions = extend({}, oInfo.oDefaultFormatOptions, oFormatOptions);\n\n  // set unsupported properties to false/undefined\n  if (oInfo.type === mDateFormatTypes.DATETIME_WITH_TIMEZONE) {\n    oFormat.oFormatOptions.interval = false;\n    oFormat.oFormatOptions.singleIntervalValue = false;\n    oFormat.oFormatOptions.UTC = false;\n  } else {\n    oFormat.oFormatOptions.showTimezone = undefined;\n    oFormat.oFormatOptions.showDate = undefined;\n    oFormat.oFormatOptions.showTime = undefined;\n  }\n\n  // type cannot be changed and should be an instance property instead of a format option\n  oFormat.type = oInfo.type;\n  if (!oFormat.oFormatOptions.calendarType) {\n    oFormat.oFormatOptions.calendarType = Configuration.getCalendarType();\n  }\n  if (oFormat.oFormatOptions.firstDayOfWeek === undefined && oFormat.oFormatOptions.minimalDaysInFirstWeek !== undefined || oFormat.oFormatOptions.firstDayOfWeek !== undefined && oFormat.oFormatOptions.minimalDaysInFirstWeek === undefined) {\n    throw new TypeError(\"Format options firstDayOfWeek and minimalDaysInFirstWeek need both to be set, but only one was provided.\");\n  }\n  if (oFormat.oFormatOptions.calendarWeekNumbering && !Object.values(CalendarWeekNumbering).includes(oFormat.oFormatOptions.calendarWeekNumbering)) {\n    throw new TypeError(\"Illegal format option calendarWeekNumbering: '\" + oFormat.oFormatOptions.calendarWeekNumbering + \"'\");\n  }\n  if (!oFormat.oFormatOptions.pattern) {\n    if (oFormat.oFormatOptions.format) {\n      oFormat.oFormatOptions.pattern = oFormat.oLocaleData.getCustomDateTimePattern(oFormat.oFormatOptions.format, oFormat.oFormatOptions.calendarType);\n    } else {\n      oFormat.oFormatOptions.pattern = oInfo.getPattern(oFormat.oLocaleData, oFormat.oFormatOptions.style, oFormat.oFormatOptions.calendarType);\n    }\n  }\n  if (oFormat.oFormatOptions.interval) {\n    var sSinglePattern,\n      sDelimiter = oFormat.oFormatOptions.intervalDelimiter;\n    if (oFormat.oFormatOptions.format) {\n      // when 'format' option is set, generate the pattern based on the greatest difference\n      oFormat.intervalPatterns = oFormat.oLocaleData.getCustomIntervalPattern(oFormat.oFormatOptions.format, null /*=no diff*/, oFormat.oFormatOptions.calendarType);\n\n      // In case oFormat.intervalPatterns is a string, put the single string into array\n      if (typeof oFormat.intervalPatterns === \"string\") {\n        oFormat.intervalPatterns = [oFormat.intervalPatterns];\n      }\n      sSinglePattern = oFormat.oLocaleData.getCustomDateTimePattern(oFormat.oFormatOptions.format, oFormat.oFormatOptions.calendarType);\n      // Put the single date pattern, which is generated based on the oFormatOptions.format, into the array in\n      // case the date interval is formatted as a single date\n      oFormat.intervalPatterns.push(sSinglePattern);\n    } else {\n      sSinglePattern = oFormat.oFormatOptions.pattern;\n      oFormat.intervalPatterns = [\n      // when 'format' option is not set, generate the combined interval pattern\n      oFormat.oLocaleData.getCombinedIntervalPattern(oFormat.oFormatOptions.pattern, oFormat.oFormatOptions.calendarType),\n      // Put the single date pattern into the array in case the date interval is formatted as a single date\n      oFormat.oFormatOptions.pattern];\n    }\n    oFormat.intervalPatterns.push(oFormat.oFormatOptions.pattern + \" - \" + oFormat.oFormatOptions.pattern);\n    if (sDelimiter) {\n      // use delimiter pattern as first choice\n      sDelimiter = sDelimiter.replace(/'/g, \"''\");\n      sDelimiter = \"'\" + sDelimiter + \"'\";\n      oFormat.intervalPatterns.unshift(sSinglePattern + sDelimiter + sSinglePattern);\n    }\n    oFormat.intervalPatterns = Array.from(new Set(oFormat.intervalPatterns));\n  }\n\n  // if the current format isn't a fallback format, create its fallback formats\n  if (!bIsFallback) {\n    aFallbackFormatOptions = oInfo.aFallbackFormatOptions;\n    // Add two fallback patterns for locale-dependent short format without delimiters\n    if (oInfo.bShortFallbackFormatOptions) {\n      sPattern = oInfo.getPattern(oFormat.oLocaleData, \"short\");\n      // add the options of fallback formats without delimiters to the fallback options array\n      aFallbackFormatOptions = aFallbackFormatOptions.concat(DateFormat._createFallbackOptionsWithoutDelimiter(sPattern));\n    }\n    if (oFormat.oFormatOptions.pattern && oInfo.bPatternFallbackWithoutDelimiter) {\n      // create options of fallback formats by removing delimiters from the given pattern\n      // insert the new fallback format options to the front of the array\n      aFallbackFormatOptions = DateFormat._createFallbackOptionsWithoutDelimiter(oFormat.oFormatOptions.pattern).concat(aFallbackFormatOptions);\n    }\n\n    // remove duplicate format options (e.g. fallback format with same pattern is not needed twice)\n    aFallbackFormatOptions = aFallbackFormatOptions.reduce(function (aFallbacks, oOptions) {\n      var aKeys = Object.keys(oOptions),\n        bDuplicate = aFallbacks.some(function (oOptions0) {\n          return Object.keys(oOptions0).length === aKeys.length && aKeys.every(function (sKey) {\n            return oOptions0[sKey] === oOptions[sKey];\n          });\n        });\n      if (!bDuplicate) {\n        aFallbacks.push(oOptions);\n      }\n      return aFallbacks;\n    }, []);\n    oFormat.aFallbackFormats = DateFormat._createFallbackFormat(aFallbackFormatOptions, oFormat.oFormatOptions.calendarType, oLocale, oInfo, oFormat.oFormatOptions);\n  }\n  oFormat.oRequiredParts = oInfo.oRequiredParts;\n  oFormat.aRelativeScales = oInfo.aRelativeScales;\n  oFormat.aRelativeParseScales = oInfo.aRelativeParseScales;\n  oFormat.aIntervalCompareFields = oInfo.aIntervalCompareFields;\n  oFormat.init();\n  return oFormat;\n};\n\n/**\n * Initialize date format\n */\nDateFormat.prototype.init = function () {\n  var sCalendarType = this.oFormatOptions.calendarType;\n  this.aMonthsAbbrev = this.oLocaleData._getMonthsWithAlternatives(\"abbreviated\", sCalendarType);\n  this.aMonthsWide = this.oLocaleData.getMonths(\"wide\", sCalendarType);\n  this.aMonthsNarrow = this.oLocaleData.getMonths(\"narrow\", sCalendarType);\n  this.aMonthsAbbrevSt = this.oLocaleData._getMonthsStandAloneWithAlternatives(\"abbreviated\", sCalendarType);\n  this.aMonthsWideSt = this.oLocaleData.getMonthsStandAlone(\"wide\", sCalendarType);\n  this.aMonthsNarrowSt = this.oLocaleData.getMonthsStandAlone(\"narrow\", sCalendarType);\n  this.aDaysAbbrev = this.oLocaleData.getDays(\"abbreviated\", sCalendarType);\n  this.aDaysWide = this.oLocaleData.getDays(\"wide\", sCalendarType);\n  this.aDaysNarrow = this.oLocaleData.getDays(\"narrow\", sCalendarType);\n  this.aDaysShort = this.oLocaleData.getDays(\"short\", sCalendarType);\n  this.aDaysAbbrevSt = this.oLocaleData.getDaysStandAlone(\"abbreviated\", sCalendarType);\n  this.aDaysWideSt = this.oLocaleData.getDaysStandAlone(\"wide\", sCalendarType);\n  this.aDaysNarrowSt = this.oLocaleData.getDaysStandAlone(\"narrow\", sCalendarType);\n  this.aDaysShortSt = this.oLocaleData.getDaysStandAlone(\"short\", sCalendarType);\n  this.aQuartersAbbrev = this.oLocaleData.getQuarters(\"abbreviated\", sCalendarType);\n  this.aQuartersWide = this.oLocaleData.getQuarters(\"wide\", sCalendarType);\n  this.aQuartersNarrow = this.oLocaleData.getQuarters(\"narrow\", sCalendarType);\n  this.aQuartersAbbrevSt = this.oLocaleData.getQuartersStandAlone(\"abbreviated\", sCalendarType);\n  this.aQuartersWideSt = this.oLocaleData.getQuartersStandAlone(\"wide\", sCalendarType);\n  this.aQuartersNarrowSt = this.oLocaleData.getQuartersStandAlone(\"narrow\", sCalendarType);\n  this.aErasNarrow = this.oLocaleData.getEras(\"narrow\", sCalendarType);\n  this.aErasAbbrev = this.oLocaleData.getEras(\"abbreviated\", sCalendarType);\n  this.aErasWide = this.oLocaleData.getEras(\"wide\", sCalendarType);\n  this.aDayPeriodsAbbrev = this.oLocaleData.getDayPeriods(\"abbreviated\", sCalendarType);\n  this.aDayPeriodsNarrow = this.oLocaleData.getDayPeriods(\"narrow\", sCalendarType);\n  this.aDayPeriodsWide = this.oLocaleData.getDayPeriods(\"wide\", sCalendarType);\n  this.oFlexibleDayPeriodsAbbrev = this.oLocaleData.getFlexibleDayPeriods(\"abbreviated\", sCalendarType);\n  this.oFlexibleDayPeriodsNarrow = this.oLocaleData.getFlexibleDayPeriods(\"narrow\", sCalendarType);\n  this.oFlexibleDayPeriodsWide = this.oLocaleData.getFlexibleDayPeriods(\"wide\", sCalendarType);\n  this.oFlexibleDayPeriodsAbbrevSt = this.oLocaleData.getFlexibleDayPeriodsStandAlone(\"abbreviated\", sCalendarType);\n  this.oFlexibleDayPeriodsNarrowSt = this.oLocaleData.getFlexibleDayPeriodsStandAlone(\"narrow\", sCalendarType);\n  this.oFlexibleDayPeriodsWideSt = this.oLocaleData.getFlexibleDayPeriodsStandAlone(\"wide\", sCalendarType);\n  this.aFormatArray = this.parseCldrDatePattern(this.oFormatOptions.pattern);\n  this.sAllowedCharacters = this.getAllowedCharacters(this.aFormatArray);\n};\n\n/**\n * Creates DateFormat instances based on the given format options. The created\n * instances are used as fallback formats of another DateFormat instances.\n *\n * @param {Object[]} aFallbackFormatOptions the options for creating the fallback DateFormat\n * @param {sap.ui.core.CalendarType} sCalendarType the type of the current calendarType\n * @param {sap.ui.core.Locale} oLocale Locale to ask for locale specific texts/settings\n * @param {Object} oInfo The default info object of the current date type\n * @param {object} oParentFormatOptions the format options, relevant are: interval, showDate, showTime and showTimezone\n * @return {sap.ui.core.DateFormat[]} an array of fallback DateFormat instances\n * @private\n */\nDateFormat._createFallbackFormat = function (aFallbackFormatOptions, sCalendarType, oLocale, oInfo, oParentFormatOptions) {\n  return aFallbackFormatOptions.map(function (oOptions) {\n    // The format options within the aFallbackFormatOptions array are static\n    // and shouldn't be manipulated. Hence, cloning each format option is required.\n    var oFormatOptions = Object.assign({}, oOptions);\n\n    // Pass the showDate, showTime and showTimezone format options to the fallback instance.\n    oFormatOptions.showDate = oParentFormatOptions.showDate;\n    oFormatOptions.showTime = oParentFormatOptions.showTime;\n    oFormatOptions.showTimezone = oParentFormatOptions.showTimezone;\n\n    // the timezone instance's fallback patterns depend on the showDate, showTime and\n    // showTimezone format option which means they cannot be static,\n    // therefore they are generated using the getTimezonePattern function\n    if (typeof oInfo.getTimezonePattern === \"function\" && oFormatOptions.pattern) {\n      oFormatOptions.pattern = oInfo.getTimezonePattern(oFormatOptions.pattern);\n    }\n    if (oParentFormatOptions.interval) {\n      oFormatOptions.interval = true;\n    }\n    oFormatOptions.calendarType = sCalendarType;\n    return DateFormat.createInstance(oFormatOptions, oLocale, oInfo, true);\n  });\n};\n\n/**\n * Creates options for fallback DateFormat instance by removing all delimiters\n * from the given base pattern.\n *\n * @param {string} sBasePattern The pattern where the result pattern will be\n * generated by removing the delimiters\n * @return {Object} Format option object which contains the new pattern\n */\nDateFormat._createFallbackOptionsWithoutDelimiter = function (sBasePattern) {\n  var rNonDateFields = /[^dMyGU]/g,\n    oDayReplace = {\n      regex: /d+/g,\n      replace: \"dd\"\n    },\n    oMonthReplace = {\n      regex: /M+/g,\n      replace: \"MM\"\n    },\n    oYearReplace = {\n      regex: /[yU]+/g,\n      replace: [\"yyyy\", \"yy\"]\n    };\n  sBasePattern = sBasePattern.replace(rNonDateFields, \"\"); //remove all delimiters\n  sBasePattern = sBasePattern.replace(oDayReplace.regex, oDayReplace.replace); // replace day entries with 2 digits\n  sBasePattern = sBasePattern.replace(oMonthReplace.regex, oMonthReplace.replace); // replace month entries with 2 digits\n\n  return oYearReplace.replace.map(function (sReplace) {\n    return {\n      pattern: sBasePattern.replace(oYearReplace.regex, sReplace),\n      strictParsing: true\n    };\n  });\n};\nvar oParseHelper = {\n  isNumber: function (iCharCode) {\n    return iCharCode >= 48 && iCharCode <= 57;\n  },\n  findNumbers: function (sValue, iMaxLength) {\n    var iLength = 0;\n    while (iLength < iMaxLength && this.isNumber(sValue.charCodeAt(iLength))) {\n      iLength++;\n    }\n    return sValue.substr(0, iLength);\n  },\n  /**\n   * Returns if the given string starts with another given string ignoring the case.\n   *\n   * Takes the locale into account to ensure the characters are interpreted the right way.\n   *\n   * First, an exact case check is performed to remain backward compatible, then a case-insensitive check\n   * based on the locale is done.\n   *\n   * When during the case conversion the length of the string changes we cannot safely match\n   * it and return <code>false</code>.\n   *\n   * @param {string} sValue the value to check, e.g. \"März 2013\"\n   * @param {string} sSubstring the string to compare it with, e.g. \"MÄRZ\"\n   * @param {string} sLocale the locale, e.g. \"de-DE\"\n   * @returns {boolean} true if the given string <code>sValue</code> starts with <code>sSubstring</code>\n   * @private\n   */\n  startsWithIgnoreCase: function (sValue, sSubstring, sLocale) {\n    // exact case comparison (backward compatible)\n    if (sValue.startsWith(sSubstring)) {\n      return true;\n    }\n    try {\n      // Use String#toLocaleUpperCase instead of String#toLocaleLowerCase because there\n      // are known cases where an upper case letter has 2 lower case variants, e.g. Greek sigma.\n      var sSubToLocaleUpperCase = sSubstring.toLocaleUpperCase(sLocale);\n      var sValueUpperCase = sValue.toLocaleUpperCase(sLocale);\n\n      // During the upper-case conversion there are cases where length changes, e.g. ß -> SS.\n      // This cannot be properly determined without probing therefore we do not support this case.\n      if (sSubToLocaleUpperCase.length !== sSubstring.length || sValueUpperCase.length !== sValue.length) {\n        return false;\n      }\n      return sValueUpperCase.startsWith(sSubToLocaleUpperCase);\n    } catch (e) {\n      // Can fail for String#toLocaleUpperCase with an invalid locale\n      // the API fails in the case with: Incorrect locale information provided\n      return false;\n    }\n  },\n  /**\n   * Finds the longest matching entry for which the following applies:\n   * * <code>sValue</code> starts with the found entry\n   *\n   * The index of the finding in <code>aList</code> and the length of the match is returned.\n   * The case is ignored and the given locale is used for the string comparison.\n   *\n   * @example\n   * findEntry(\"MÄRZ 2013\", [\"Januar\", \"Februar\", \"März\", \"April\", ...], \"de-DE\");\n   * // {length: 4, index: 2}\n   * @example\n   * findEntry(\"Sep 2013\", [..., \"Aug\", [\"Sept\", \"Sep\"], \"Oct\", ...], \"en-GB\");\n   * // {length: 3, index: 8}\n   *\n   * @param {string} sValue the input value, e.g. \"MÄRZ 2013\"\n   * @param {string[]|Array<string[]>} aList\n   *   The list of values to check, e.g. [\"Januar\", \"Februar\", \"März\", \"April\", ...]; the list may contain also\n   *   arrays of strings containing alternatives, e.g. [..., \"Aug\", [\"Sept\", \"Sep\"], \"Oct\", ...]\n   * @param {string} sLocale the locale which is used for the string comparison, e.g. \"de-DE\"\n   * @returns {{length: number, index: number}} the length of the match in sValue, the index in the list of values\n   *   e.g. length: 4, index: 2 (\"MÄRZ\")\n   * @private\n   */\n  findEntry: function (sValue, aList, sLocale) {\n    let iFoundIndex = -1;\n    let iMatchedLength = 0;\n    aList.forEach((vEntry, j) => {\n      (Array.isArray(vEntry) ? vEntry : [vEntry]).forEach(sEntry => {\n        if (sEntry.length > iMatchedLength && this.startsWithIgnoreCase(sValue, sEntry, sLocale)) {\n          iFoundIndex = j;\n          iMatchedLength = sEntry.length;\n        }\n      });\n    });\n    return {\n      index: iFoundIndex,\n      length: iMatchedLength\n    };\n  },\n  /**\n   * Parses a given timezone\n   *\n   * @param {string} sValue String to parse, e.g. \"-0800\", \"-08:00\", \"-08\"\n   * @param {boolean} bColonSeparated Whether or not the values are colon separated, e.g. \"-08:00\"\n   * @returns {{tzDiff: number, length: number}} Object containing the timezone difference in seconds and the length of the parsed segment\n   */\n  parseTZ: function (sValue, bColonSeparated) {\n    var iLength = 0;\n    var iTZFactor = sValue.charAt(0) === \"+\" ? -1 : 1;\n    var sPart;\n    if (sValue[0] === \"Z\") {\n      return {\n        length: 1,\n        tzDiff: 0\n      };\n    }\n    iLength++; //\"+\" or \"-\"\n    sPart = this.findNumbers(sValue.substr(iLength), 2);\n    var iTZDiffHour = parseInt(sPart);\n    iLength += 2; //hh: 2 digits for hours\n\n    if (bColonSeparated) {\n      iLength++; //\":\"\n    }\n    sPart = this.findNumbers(sValue.substr(iLength), 2);\n    var iTZDiff = 0;\n    // timezone pattern \"X\": will produce only 2 digits: \"-08\"\n    if (sPart) {\n      iLength += 2; //mm: 2 digits for minutes\n      iTZDiff = parseInt(sPart);\n    }\n    return {\n      length: iLength,\n      tzDiff: (iTZDiff + 60 * iTZDiffHour) * 60 * iTZFactor\n    };\n  },\n  /**\n   * Returns <code>false</code> if the given pattern symbol name is required and the value for that part is\n   * invalid, otherwise <code>true</code> is returned.\n   *\n   * @param {string} sSymbolName\n   *   A unique pattern symbol name\n   * @param {boolean} bPartInvalid\n   *   Whether the value for the given pattern symbol name is invalid\n   * @param {sap.ui.core.format.DateFormat} oFormat\n   *   The <code>DateFormat</code> instance\n   * @returns {boolean}\n   *   <code>false</code> if the given pattern symbol name is required and the value for that part is invalid,\n   *   otherwise <code>true</code>\n   */\n  checkValid: function (sSymbolName, bPartInvalid, oFormat) {\n    if (sSymbolName in oFormat.oRequiredParts && bPartInvalid) {\n      return false;\n    }\n    return true;\n  }\n};\nDateFormat._oParseHelper = oParseHelper; // make parse helper a private static member for testing\n\n/**\n * Creates a pattern symbol object containing all needed functions to be used for formatting and parsing.\n * Functions which are not given in <code>mParameters</code> are provided with a default implementation.\n *\n * @param {Object<string,any>} mParameters\n *   A parameters map for creating a pattern symbol\n * @param {string} mParameters.name\n *   An internal unique name describing this symbol\n * @param {function(Object<string, any>, sap.ui.core.date.UniversalDate, boolean, sap.ui.core.format.DateFormat,\n *     string): string} [mParameters.format]\n *   A function to format the symbol part based on a given date object\n * @param {function(string, Object<string, any>, sap.ui.core.format.DateFormat, object, string): object}\n *     [mParameters.parse]\n *   A function to parse the symbol part based on a given date string\n * @param {boolean|function(int): boolean} [mParameters.isNumeric]\n *   A boolean to describe, or a function to evaluate, whether the pattern symbol expects a\n *   numeric representation. For example pattern \"MM\" results in \"02\" and is therefore numeric,\n *   but \"MMM\" results in \"Feb\" which is not numeric.\n * @returns {{name: string, format: function, parse: function, isNumeric: function}}\n *   A pattern symbol object\n *\n * @private\n */\nDateFormat._createPatternSymbol = function (mParameters) {\n  var fnIsNumeric = typeof mParameters.isNumeric === \"function\" && mParameters.isNumeric\n  // Default: false\n  || function () {\n    return mParameters.isNumeric || false;\n  };\n  return {\n    name: mParameters.name,\n    /**\n     * Formatter for a pattern symbol.\n     *\n     * @param {Object<string, any>} oField\n     *   The date pattern field as parsed by {@link DateFormat#parseCldrDatePattern}\n     * @param {sap.ui.core.date.UniversalDate} oDate\n     *   The date object to format\n     * @param {boolean} bUTC\n     *   Whether the UTC option is set\n     * @param {sap.ui.core.format.DateFormat} oFormat\n     *   The <code>DateFormat</code> instance\n     * @returns {string}\n     *   The formatted date information for this date pattern part\n     */\n    format: mParameters.format\n    // not supported, but reserved\n    || function () {\n      return \"\";\n    },\n    /**\n     * Parser for a pattern symbol.\n     *\n     * @param {string} sValue\n     *   The given input\n     * @param {Object<string, any>} oPart\n     *   The date pattern field as parsed by {@link DateFormat#parseCldrDatePattern}\n     * @param {sap.ui.core.format.DateFormat} oFormat\n     *   The <code>DateFormat</code> instance\n     * @param {object} oConfig\n     *   The configuration object for parsing the value\n     * @param {object} oConfig.dateValue\n     *   The already parsed date fields\n     * @param {boolean} oConfig.exactLength\n     *   Whether parsing with the exact length specified by {@link DateFormat#parseCldrDatePattern} is needed\n     * @param {object[]} oConfig.formatArray\n     *   The complete format array as parsed by {@link DateFormat#parseCldrDatePattern}\n     * @param {int} oConfig.index\n     *   The current index in the format array\n     * @param {boolean} oConfig.strict\n     *   Whether to disallow overflows for component values of a date (see\n     *   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/Date).\n     *   Note that the corresponding checks are just for number ranges which are possible <em>at max</em>\n     *   without overflow; the check for day does not consider the month and year to compute the maximum\n     *   number of days allowed.\n     * @param {string} sTimezone\n     *   The IANA timezone ID\n     * @returns {object}\n     *   The parsed date information for this date pattern part; could contain the property <code>valid</code>\n     *   set to <code>false</code> if parsing was not successful\n     */\n    parse: mParameters.parse\n    // not supported, but reserved\n    || function () {\n      return {};\n    },\n    /**\n     * Evaluates whether this symbol has a numeric representation.\n     *\n     * @param {int} [iDigits] The number of repetitions of the pattern symbol, e.g. <code>3</code> for \"aaa\"\n     * @returns {boolean} Whether this symbol has a numeric representation\n     */\n    isNumeric: fnIsNumeric\n  };\n};\n\n/**\n * Provides functionality to format and parse a given pattern symbol.\n * @see https://unicode.org/reports/tr35/tr35-dates.html#table-date-field-symbol-table\n */\nDateFormat.prototype.oSymbols = {\n  \"\": DateFormat._createPatternSymbol({\n    name: \"text\",\n    format: function (oField, oDate) {\n      return oField.value;\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var sChar;\n      var bValid = true;\n      var iValueIndex = 0;\n      var iPatternIndex = 0;\n      // https://www.compart.com/en/unicode/category/Pd\n      var sDelimiter = \"\\u002d\\u007E\\u2010\\u2011\\u2012\\u2013\\u2014\\ufe58\\ufe63\\uff0d\\uFF5E\";\n\n      // Compare the letters in oPart.value (the pattern) and sValue (the given string to parse)\n      // one by one.\n      // If the current letter in the pattern is \" \", sValue is allowed to have no match, exact match\n      // or multiple \" \". This makes the parsing more tolerant. Special spaces or RTL characters have\n      // to be normalized before comparison.\n      const sPartValue = DateFormat._normalize(oPart.value);\n      for (; iPatternIndex < sPartValue.length; iPatternIndex++) {\n        sChar = sPartValue.charAt(iPatternIndex);\n        if (sChar === \" \") {\n          // allows to have multiple spaces\n          while (sValue.charAt(iValueIndex) === \" \") {\n            iValueIndex++;\n          }\n        } else if (sDelimiter.includes(sChar)) {\n          if (!sDelimiter.includes(sValue.charAt(iValueIndex))) {\n            bValid = false;\n          }\n          iValueIndex++;\n        } else {\n          if (sValue.charAt(iValueIndex) !== sChar) {\n            // if it's not a space, there must be an exact match\n            bValid = false;\n          }\n          iValueIndex++;\n        }\n        if (!bValid) {\n          break;\n        }\n      }\n      if (bValid) {\n        return {\n          length: iValueIndex\n        };\n      } else {\n        var bPartInvalid = false;\n\n        // only require text, if next part is also required\n        if (oConfig.index < oConfig.formatArray.length - 1) {\n          bPartInvalid = oConfig.formatArray[oConfig.index + 1].type in oFormat.oRequiredParts;\n        }\n        return {\n          valid: oParseHelper.checkValid(oPart.type, bPartInvalid, oFormat)\n        };\n      }\n    }\n  }),\n  \"G\": DateFormat._createPatternSymbol({\n    name: \"era\",\n    format: function (oField, oDate, bUTC, oFormat) {\n      var iEra = oDate.getUTCEra();\n      if (oField.digits <= 3) {\n        return oFormat.aErasAbbrev[iEra];\n      } else if (oField.digits === 4) {\n        return oFormat.aErasWide[iEra];\n      } else {\n        return oFormat.aErasNarrow[iEra];\n      }\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var aErasVariants = [oFormat.aErasWide, oFormat.aErasAbbrev, oFormat.aErasNarrow];\n      for (var i = 0; i < aErasVariants.length; i++) {\n        var aVariants = aErasVariants[i];\n        var oFound = oParseHelper.findEntry(sValue, aVariants, oFormat.oLocaleData.sCLDRLocaleId);\n        if (oFound.index !== -1) {\n          return {\n            era: oFound.index,\n            length: oFound.length\n          };\n        }\n      }\n      return {\n        era: oFormat.aErasWide.length - 1,\n        valid: oParseHelper.checkValid(oPart.type, true, oFormat)\n      };\n    }\n  }),\n  \"y\": DateFormat._createPatternSymbol({\n    name: \"year\",\n    format: function (oField, oDate, bUTC, oFormat) {\n      var iYear = oDate.getUTCFullYear();\n      var sYear = String(iYear);\n      var sCalendarType = oFormat.oFormatOptions.calendarType;\n      if (oField.digits === 2 && sYear.length > 2) {\n        sYear = sYear.substr(sYear.length - 2);\n      }\n      // When parsing we assume dates less than 100 to be in the current/last century,\n      // so when formatting we have to make sure they are differentiable by prefixing with zeros\n      if (sCalendarType !== CalendarType.Japanese && oField.digits === 1 && iYear < 100) {\n        sYear = sYear.padStart(4, \"0\");\n      }\n      return sYear.padStart(oField.digits, \"0\");\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var iExpectedDigits,\n        sPart,\n        bPartInvalid,\n        sCalendarType = oFormat.oFormatOptions.calendarType;\n      if (oPart.digits === 1) {\n        iExpectedDigits = 4;\n      } else if (oPart.digits === 2) {\n        iExpectedDigits = 2;\n      } else {\n        iExpectedDigits = oPart.digits;\n      }\n      sPart = oParseHelper.findNumbers(sValue, iExpectedDigits);\n      bPartInvalid = sPart === \"\" || oConfig.exactLength && sPart.length !== iExpectedDigits;\n      var iYear = parseInt(sPart);\n      // Find the right century for two-digit years\n      // https://tc39.es/ecma262/#sec-date.parse\n      // \"The function first attempts to parse the String according to the format\n      // described in Date Time String Format (https://tc39.es/ecma262/#sec-date-time-string-format),\n      // including expanded years.\n      // If the String does not conform to that format the function may fall back to\n      // any implementation-specific heuristics or implementation-specific date formats.\"\n      //\n      // Since a two-digit year is not format conform, each JS implementations might differ.\n      // Therefore we provide an own implementation:\n\n      // current year: 1978\n      // 1978: 08 = 1908 (diff: -70)\n      // 1978: 07 = 2007 (diff: -71)\n\n      // current year: 2018\n      // 2018: 48 = 1948 (diff: 30)\n      // 2018: 47 = 2047 (diff: 29)\n      if (sCalendarType !== CalendarType.Japanese && sPart.length <= 2) {\n        var oCurrentDate = UniversalDate.getInstance(UI5Date.getInstance(), sCalendarType),\n          iCurrentYear = oCurrentDate.getUTCFullYear(),\n          iCurrentCentury = Math.floor(iCurrentYear / 100),\n          iYearDiff = iCurrentCentury * 100 + iYear - iCurrentYear;\n        if (iYearDiff < -70) {\n          iYear += (iCurrentCentury + 1) * 100;\n        } else if (iYearDiff < 30) {\n          iYear += iCurrentCentury * 100;\n        } else {\n          iYear += (iCurrentCentury - 1) * 100;\n        }\n      }\n      return {\n        length: sPart.length,\n        valid: oParseHelper.checkValid(oPart.type, bPartInvalid, oFormat),\n        year: iYear\n      };\n    },\n    isNumeric: true\n  }),\n  \"Y\": DateFormat._createPatternSymbol({\n    name: \"weekYear\",\n    format: function (oField, oDate, bUTC, oFormat) {\n      var oWeek = oDate.getUTCWeek(oFormat.oLocale, getCalendarWeekParameter(oFormat.oFormatOptions));\n      var iWeekYear = oWeek.year;\n      var sWeekYear = String(iWeekYear);\n      var sCalendarType = oFormat.oFormatOptions.calendarType;\n      if (oField.digits === 2 && sWeekYear.length > 2) {\n        sWeekYear = sWeekYear.substr(sWeekYear.length - 2);\n      }\n      // When parsing we assume dates less than 100 to be in the current/last century,\n      // so when formatting we have to make sure they are differentiable by prefixing with zeros\n      if (sCalendarType !== CalendarType.Japanese && oField.digits === 1 && iWeekYear < 100) {\n        sWeekYear = sWeekYear.padStart(4, \"0\");\n      }\n      return sWeekYear.padStart(oField.digits, \"0\");\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var iExpectedDigits,\n        sPart,\n        bPartInvalid,\n        sCalendarType = oFormat.oFormatOptions.calendarType;\n      if (oPart.digits === 1) {\n        iExpectedDigits = 4;\n      } else if (oPart.digits === 2) {\n        iExpectedDigits = 2;\n      } else {\n        iExpectedDigits = oPart.digits;\n      }\n      sPart = oParseHelper.findNumbers(sValue, iExpectedDigits);\n      bPartInvalid = sPart === \"\" || oConfig.exactLength && sPart.length !== iExpectedDigits;\n      var iYear = parseInt(sPart);\n      var iWeekYear = iYear;\n      // Find the right century for two-digit years\n      if (sCalendarType !== CalendarType.Japanese && sPart.length <= 2) {\n        var oCurrentDate = UniversalDate.getInstance(UI5Date.getInstance(), sCalendarType),\n          iCurrentYear = oCurrentDate.getUTCFullYear(),\n          iCurrentCentury = Math.floor(iCurrentYear / 100),\n          iYearDiff = iCurrentCentury * 100 + iWeekYear - iCurrentYear;\n        if (iYearDiff < -70) {\n          iWeekYear += (iCurrentCentury + 1) * 100;\n        } else if (iYearDiff < 30) {\n          iWeekYear += iCurrentCentury * 100;\n        } else {\n          iWeekYear += (iCurrentCentury - 1) * 100;\n        }\n      }\n      return {\n        length: sPart.length,\n        valid: oParseHelper.checkValid(oPart.type, bPartInvalid, oFormat),\n        year: iYear,\n        weekYear: iWeekYear\n      };\n    },\n    isNumeric: true\n  }),\n  \"M\": DateFormat._createPatternSymbol({\n    name: \"month\",\n    format: function (oField, oDate, bUTC, oFormat) {\n      var iMonth = oDate.getUTCMonth();\n      if (oField.digits === 3) {\n        const vName = oFormat.aMonthsAbbrev[iMonth]; // vName may be an array if there are alternatives\n        return Array.isArray(vName) ? vName[0] : vName;\n      } else if (oField.digits === 4) {\n        return oFormat.aMonthsWide[iMonth];\n      } else if (oField.digits > 4) {\n        return oFormat.aMonthsNarrow[iMonth];\n      } else {\n        return String(iMonth + 1).padStart(oField.digits, \"0\");\n      }\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var iMonth,\n        sPart,\n        bPartInvalid,\n        bValid,\n        aMonthsVariants = [oFormat.aMonthsWide, oFormat.aMonthsWideSt, oFormat.aMonthsAbbrev, oFormat.aMonthsAbbrevSt, oFormat.aMonthsNarrow, oFormat.aMonthsNarrowSt];\n      if (oPart.digits < 3) {\n        sPart = oParseHelper.findNumbers(sValue, Math.max(oPart.digits, 2));\n        bPartInvalid = sPart === \"\" || oConfig.exactLength && sPart.length < 2;\n        bValid = oParseHelper.checkValid(oPart.type, bPartInvalid, oFormat);\n        iMonth = parseInt(sPart) - 1;\n        if (oConfig.strict && (iMonth > 11 || iMonth < 0)) {\n          bValid = false;\n        }\n      } else {\n        for (var i = 0; i < aMonthsVariants.length; i++) {\n          var aVariants = aMonthsVariants[i];\n          var oFound = oParseHelper.findEntry(sValue, aVariants, oFormat.oLocaleData.sCLDRLocaleId);\n          if (oFound.index !== -1) {\n            return {\n              month: oFound.index,\n              length: oFound.length\n            };\n          }\n        }\n        bValid = oParseHelper.checkValid(oPart.type, true, oFormat);\n      }\n      return {\n        month: iMonth,\n        length: sPart ? sPart.length : 0,\n        valid: bValid\n      };\n    },\n    isNumeric: function (iDigits) {\n      return iDigits < 3;\n    }\n  }),\n  \"L\": DateFormat._createPatternSymbol({\n    name: \"monthStandalone\",\n    format: function (oField, oDate, bUTC, oFormat) {\n      var iMonth = oDate.getUTCMonth();\n      if (oField.digits === 3) {\n        const vName = oFormat.aMonthsAbbrevSt[iMonth]; // vName may be an array if there are alternatives\n        return Array.isArray(vName) ? vName[0] : vName;\n      } else if (oField.digits === 4) {\n        return oFormat.aMonthsWideSt[iMonth];\n      } else if (oField.digits > 4) {\n        return oFormat.aMonthsNarrowSt[iMonth];\n      } else {\n        return String(iMonth + 1).padStart(oField.digits, \"0\");\n      }\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var iMonth,\n        sPart,\n        bPartInvalid,\n        bValid,\n        aMonthsVariants = [oFormat.aMonthsWide, oFormat.aMonthsWideSt, oFormat.aMonthsAbbrev, oFormat.aMonthsAbbrevSt, oFormat.aMonthsNarrow, oFormat.aMonthsNarrowSt];\n      if (oPart.digits < 3) {\n        sPart = oParseHelper.findNumbers(sValue, Math.max(oPart.digits, 2));\n        bPartInvalid = sPart === \"\" || oConfig.exactLength && sPart.length < 2;\n        bValid = oParseHelper.checkValid(oPart.type, bPartInvalid, oFormat);\n        iMonth = parseInt(sPart) - 1;\n        if (oConfig.strict && (iMonth > 11 || iMonth < 0)) {\n          bValid = false;\n        }\n      } else {\n        for (var i = 0; i < aMonthsVariants.length; i++) {\n          var aVariants = aMonthsVariants[i];\n          var oFound = oParseHelper.findEntry(sValue, aVariants, oFormat.oLocaleData.sCLDRLocaleId);\n          if (oFound.index !== -1) {\n            return {\n              month: oFound.index,\n              length: oFound.length\n            };\n          }\n        }\n        bValid = oParseHelper.checkValid(oPart.type, true, oFormat);\n      }\n      return {\n        month: iMonth,\n        length: sPart ? sPart.length : 0,\n        valid: bValid\n      };\n    },\n    isNumeric: function (iDigits) {\n      return iDigits < 3;\n    }\n  }),\n  \"w\": DateFormat._createPatternSymbol({\n    name: \"weekInYear\",\n    format: function (oField, oDate, bUTC, oFormat) {\n      var oWeek = oDate.getUTCWeek(oFormat.oLocale, getCalendarWeekParameter(oFormat.oFormatOptions));\n      var iWeek = oWeek.week;\n      var sWeek = String(iWeek + 1);\n      if (oField.digits < 3) {\n        sWeek = sWeek.padStart(oField.digits, \"0\");\n      } else {\n        sWeek = oFormat.oLocaleData.getCalendarWeek(oField.digits === 3 ? \"narrow\" : \"wide\", sWeek.padStart(2, \"0\"));\n      }\n      return sWeek;\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var sPart,\n        bPartInvalid,\n        bValid,\n        iWeek,\n        iLength = 0;\n      if (oPart.digits < 3) {\n        sPart = oParseHelper.findNumbers(sValue, 2);\n        iLength = sPart.length;\n        iWeek = parseInt(sPart) - 1;\n        bPartInvalid = !sPart || oConfig.exactLength && iLength < 2;\n        bValid = oParseHelper.checkValid(oPart.type, bPartInvalid, oFormat);\n      } else {\n        sPart = oFormat.oLocaleData.getCalendarWeek(oPart.digits === 3 ? \"narrow\" : \"wide\");\n        sPart = sPart.replace(\"{0}\", \"([0-9]+)\");\n        var rWeekNumber = new RegExp(sPart),\n          oResult = rWeekNumber.exec(sValue);\n        if (oResult) {\n          // e.g. for input \"CW 01\" create pattern \"CW ([0-9]+)\"\n          // and extract number from \"01\" part of the input\n          iLength = oResult[0].length;\n          iWeek = parseInt(oResult[oResult.length - 1]) - 1;\n        } else {\n          bValid = oParseHelper.checkValid(oPart.type, true, oFormat);\n        }\n      }\n      return {\n        length: iLength,\n        valid: bValid,\n        week: iWeek\n      };\n    },\n    isNumeric: function (iDigits) {\n      return iDigits < 3;\n    }\n  }),\n  \"W\": DateFormat._createPatternSymbol({\n    name: \"weekInMonth\"\n  }),\n  \"D\": DateFormat._createPatternSymbol({\n    name: \"dayInYear\"\n  }),\n  \"d\": DateFormat._createPatternSymbol({\n    name: \"day\",\n    format: function (oField, oDate) {\n      var iDate = oDate.getUTCDate();\n      return String(iDate).padStart(oField.digits, \"0\");\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var sPart = oParseHelper.findNumbers(sValue, Math.max(oPart.digits, 2)),\n        bPartInvalid = sPart === \"\" || oConfig.exactLength && sPart.length < 2,\n        bValid = oParseHelper.checkValid(oPart.type, bPartInvalid, oFormat),\n        iDay = parseInt(sPart);\n      if (oConfig.strict && (iDay > 31 || iDay < 1)) {\n        bValid = false;\n      }\n      return {\n        day: iDay,\n        length: sPart.length,\n        valid: bValid\n      };\n    },\n    isNumeric: true\n  }),\n  \"Q\": DateFormat._createPatternSymbol({\n    name: \"quarter\",\n    format: function (oField, oDate, bUTC, oFormat) {\n      var iQuarter = oDate.getUTCQuarter();\n      if (oField.digits === 3) {\n        return oFormat.aQuartersAbbrev[iQuarter];\n      } else if (oField.digits === 4) {\n        return oFormat.aQuartersWide[iQuarter];\n      } else if (oField.digits > 4) {\n        return oFormat.aQuartersNarrow[iQuarter];\n      } else {\n        return String(iQuarter + 1).padStart(oField.digits, \"0\");\n      }\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var sPart, bPartInvalid, iQuarter, bValid;\n      var aQuartersVariants = [oFormat.aQuartersWide, oFormat.aQuartersWideSt, oFormat.aQuartersAbbrev, oFormat.aQuartersAbbrevSt, oFormat.aQuartersNarrow, oFormat.aQuartersNarrowSt];\n      if (oPart.digits < 3) {\n        sPart = oParseHelper.findNumbers(sValue, Math.max(oPart.digits, 2));\n        bPartInvalid = sPart === \"\" || oConfig.exactLength && sPart.length < 2;\n        bValid = oParseHelper.checkValid(oPart.type, bPartInvalid, oFormat);\n        iQuarter = parseInt(sPart) - 1;\n        if (oConfig.strict && iQuarter > 3) {\n          bValid = false;\n        }\n      } else {\n        for (var i = 0; i < aQuartersVariants.length; i++) {\n          var aVariants = aQuartersVariants[i];\n          var oFound = oParseHelper.findEntry(sValue, aVariants, oFormat.oLocaleData.sCLDRLocaleId);\n          if (oFound.index !== -1) {\n            return {\n              quarter: oFound.index,\n              length: oFound.length\n            };\n          }\n        }\n        bValid = oParseHelper.checkValid(oPart.type, true, oFormat);\n      }\n      return {\n        length: sPart ? sPart.length : 0,\n        quarter: iQuarter,\n        valid: bValid\n      };\n    },\n    isNumeric: function (iDigits) {\n      return iDigits < 3;\n    }\n  }),\n  \"q\": DateFormat._createPatternSymbol({\n    name: \"quarterStandalone\",\n    format: function (oField, oDate, bUTC, oFormat) {\n      var iQuarter = oDate.getUTCQuarter();\n      if (oField.digits === 3) {\n        return oFormat.aQuartersAbbrevSt[iQuarter];\n      } else if (oField.digits === 4) {\n        return oFormat.aQuartersWideSt[iQuarter];\n      } else if (oField.digits > 4) {\n        return oFormat.aQuartersNarrowSt[iQuarter];\n      } else {\n        return String(iQuarter + 1).padStart(oField.digits, \"0\");\n      }\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var sPart, bPartInvalid, iQuarter, bValid;\n      var aQuartersVariants = [oFormat.aQuartersWide, oFormat.aQuartersWideSt, oFormat.aQuartersAbbrev, oFormat.aQuartersAbbrevSt, oFormat.aQuartersNarrow, oFormat.aQuartersNarrowSt];\n      if (oPart.digits < 3) {\n        sPart = oParseHelper.findNumbers(sValue, Math.max(oPart.digits, 2));\n        bPartInvalid = sPart === \"\" || oConfig.exactLength && sPart.length < 2;\n        bValid = oParseHelper.checkValid(oPart.type, bPartInvalid, oFormat);\n        iQuarter = parseInt(sPart) - 1;\n        if (oConfig.strict && iQuarter > 3) {\n          bValid = false;\n        }\n      } else {\n        for (var i = 0; i < aQuartersVariants.length; i++) {\n          var aVariants = aQuartersVariants[i];\n          var oFound = oParseHelper.findEntry(sValue, aVariants, oFormat.oLocaleData.sCLDRLocaleId);\n          if (oFound.index !== -1) {\n            return {\n              quarter: oFound.index,\n              length: oFound.length\n            };\n          }\n        }\n        bValid = oParseHelper.checkValid(oPart.type, true, oFormat);\n      }\n      return {\n        length: sPart ? sPart.length : 0,\n        quarter: iQuarter,\n        valid: bValid\n      };\n    },\n    isNumeric: function (iDigits) {\n      return iDigits < 3;\n    }\n  }),\n  \"F\": DateFormat._createPatternSymbol({\n    name: \"dayOfWeekInMonth\"\n  }),\n  \"E\": DateFormat._createPatternSymbol({\n    name: \"dayNameInWeek\",\n    //Day of week name, format style.\n    format: function (oField, oDate, bUTC, oFormat) {\n      var iDay = oDate.getUTCDay();\n      if (oField.digits < 4) {\n        return oFormat.aDaysAbbrev[iDay];\n      } else if (oField.digits === 4) {\n        return oFormat.aDaysWide[iDay];\n      } else if (oField.digits === 5) {\n        return oFormat.aDaysNarrow[iDay];\n      } else {\n        return oFormat.aDaysShort[iDay];\n      }\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var aDaysVariants = [oFormat.aDaysWide, oFormat.aDaysWideSt, oFormat.aDaysAbbrev, oFormat.aDaysAbbrevSt, oFormat.aDaysShort, oFormat.aDaysShortSt, oFormat.aDaysNarrow, oFormat.aDaysNarrowSt];\n      for (var i = 0; i < aDaysVariants.length; i++) {\n        var aVariants = aDaysVariants[i];\n        var oFound = oParseHelper.findEntry(sValue, aVariants, oFormat.oLocaleData.sCLDRLocaleId);\n        if (oFound.index !== -1) {\n          return {\n            // gets translated to dayOfWeek where the day of week is relative to the week\n            dayOfWeek: oFound.index,\n            length: oFound.length\n          };\n        }\n      }\n    }\n  }),\n  \"c\": DateFormat._createPatternSymbol({\n    name: \"dayNameInWeekStandalone\",\n    format: function (oField, oDate, bUTC, oFormat) {\n      var iDay = oDate.getUTCDay();\n      if (oField.digits < 4) {\n        return oFormat.aDaysAbbrevSt[iDay];\n      } else if (oField.digits === 4) {\n        return oFormat.aDaysWideSt[iDay];\n      } else if (oField.digits === 5) {\n        return oFormat.aDaysNarrowSt[iDay];\n      } else {\n        return oFormat.aDaysShortSt[iDay];\n      }\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var aDaysVariants = [oFormat.aDaysWide, oFormat.aDaysWideSt, oFormat.aDaysAbbrev, oFormat.aDaysAbbrevSt, oFormat.aDaysShort, oFormat.aDaysShortSt, oFormat.aDaysNarrow, oFormat.aDaysNarrowSt];\n      for (var i = 0; i < aDaysVariants.length; i++) {\n        var aVariants = aDaysVariants[i];\n        var oFound = oParseHelper.findEntry(sValue, aVariants, oFormat.oLocaleData.sCLDRLocaleId);\n        if (oFound.index !== -1) {\n          return {\n            day: oFound.index,\n            length: oFound.length\n          };\n        }\n      }\n    }\n  }),\n  // day number of week (depends on locale's first day of week)\n  // e.g. Thursday\n  // \"de\": 4 (firstDay: 1)\n  // \"en\": 5 (firstDay: 0)\n  // \"ar\": 6 (firstDay: 6)\n  \"u\": DateFormat._createPatternSymbol({\n    name: \"dayNumberOfWeek\",\n    format: function (oField, oDate, bUTC, oFormat) {\n      var iDay = oDate.getUTCDay();\n      return oFormat._adaptDayOfWeek(iDay);\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var sPart = oParseHelper.findNumbers(sValue, oPart.digits),\n        bPartInvalid = oConfig.exactLength && sPart.length !== oPart.digits;\n      return {\n        dayNumberOfWeek: parseInt(sPart),\n        length: sPart.length,\n        valid: oParseHelper.checkValid(oPart.type, bPartInvalid, oFormat)\n      };\n    },\n    isNumeric: true\n  }),\n  \"a\": DateFormat._createPatternSymbol({\n    name: \"amPmMarker\",\n    /**\n     * Formats the day period.\n     *\n     * @param {Object<string, any>} oField\n     *   The date pattern field as parsed by {@link DateFormat#parseCldrDatePattern}\n     * @param {number} oField.digits\n     *   The number of repetitions of the pattern symbol, e.g. <code>3</code> for \"aaa\"\n     * @param {string} oField.symbol\n     *   The pattern symbol \"a\"\n     * @param {string} oField.type\n     *   The symbol name \"amPmMarker\"\n     * @param {sap.ui.core.date.UniversalDate} oDate\n     *   The date to format\n     * @param {boolean} [bUTC]\n     *   Whether the UTC option is set; not used\n     * @param {sap.ui.core.format.DateFormat} oFormat\n     *   The <code>DateFormat</code> instance\n     * @returns {string}\n     *   The formatted day period, e.g. \"AM\" for symbol \"a\"\n     */\n    format: function (oField, oDate, bUTC, oFormat) {\n      var iDayPeriod = oDate.getUTCDayPeriod();\n      if (oField.digits <= 3) {\n        return oFormat.aDayPeriodsAbbrev[iDayPeriod];\n      } else if (oField.digits === 4) {\n        return oFormat.aDayPeriodsWide[iDayPeriod];\n      } else {\n        return oFormat.aDayPeriodsNarrow[iDayPeriod];\n      }\n    },\n    /**\n     * Parses the day period from a given input string.\n     *\n     * @param {string} sValue\n     *   The given input, e.g. \"am 13:37\"\n     * @param {Object<string, any>} oPart\n     *   The date pattern field as parsed by {@link DateFormat#parseCldrDatePattern}\n     * @param {number} oPart.digits\n     *   The number of repetitions of the pattern symbol, e.g. <code>3</code> for \"aaa\"\n     * @param {string} oPart.symbol\n     *   The pattern symbol \"a\"\n     * @param {string} oPart.type\n     *   The symbol name \"amPmMarker\"\n     * @param {sap.ui.core.format.DateFormat} oFormat\n     *   The <code>DateFormat</code> instance\n     * @param {Object<string, any>} [oConfig]\n     *   The configuration object for parsing the value\n     * @param {object[]} [oConfig.formatArray]\n     *   The complete format array as parsed by {@link DateFormat#parseCldrDatePattern}\n     * @param {object} [oConfig.dateValue]\n     *   The already parsed date fields\n     * @param {number} [oConfig.index]\n     *   The index in the format array\n     * @param {boolean} [oConfig.strict]\n     *   Whether to use the strict option\n     * @param {string} [sTimezone]\n     *   The IANA timezone ID\n     * @returns {{length : number, pm : boolean}|{}}\n     *   An object with the <code>length</code> of the match and the parsed <code>pm</code>\n     *   value; or an object with property valid <code>false</code> if it could not be\n     *   parsed correctly\n     */\n    parse: function (sValue, oPart, oFormat, oConfig, sTimezone) {\n      // process longer patterns first to find the longest match\n      // wide > abbreviated > narrow\n      var rAMPM,\n        bAMPMAlternativeCase,\n        oEntry,\n        i,\n        aMatch,\n        aVariants,\n        aDayPeriodsVariants = [oFormat.aDayPeriodsWide, oFormat.aDayPeriodsAbbrev, oFormat.aDayPeriodsNarrow];\n\n      // Support ASCII alternative writings for AM/PM (when the locale has am/pm in its\n      // patterns), e.g. \"am\", \"a.m.\", \"am.\", \"a. m.\" (and their case alternatives)\n      // see: https://unicode.org/reports/tr35/tr35-dates.html#Parsing_Dates_Times\n      rAMPM = /[aApP](?:\\.)?[\\x20\\xA0]?[mM](?:\\.)?/;\n      aMatch = sValue.match(rAMPM);\n      bAMPMAlternativeCase = aMatch && aMatch.index === 0;\n      function removeSpacesAndDots(sValue) {\n        // Remove normal and non-breaking spaces and remove dots\n        return sValue.replace(/[\\x20\\xA0]/g, \"\").replace(/\\./g, \"\");\n      }\n      if (bAMPMAlternativeCase) {\n        sValue = removeSpacesAndDots(sValue);\n      }\n      for (i = 0; i < aDayPeriodsVariants.length; i += 1) {\n        aVariants = aDayPeriodsVariants[i].map(sDayPeriod => {\n          return DateFormat._normalize(sDayPeriod);\n        });\n        if (bAMPMAlternativeCase) {\n          // check normalized match for alternative case of am/pm\n          aVariants = aVariants.map(removeSpacesAndDots);\n        }\n        // check exact and case-insensitive match\n        oEntry = oParseHelper.findEntry(sValue, aVariants, oFormat.oLocaleData.sCLDRLocaleId);\n        if (oEntry.index !== -1) {\n          return {\n            pm: oEntry.index === 1,\n            // am/pm alternative may include an additional dot, e.g. \"am.\"\n            // therefore the length for the am/pm alternative is the length of the\n            // match\n            length: bAMPMAlternativeCase ? aMatch[0].length : oEntry.length\n          };\n        }\n      }\n      return {\n        valid: false\n      };\n    }\n  }),\n  \"B\": DateFormat._createPatternSymbol({\n    name: \"flexibleDayPeriod\",\n    /**\n     * Formats the flexible day period.\n     *\n     * @param {Object<string, any>} oField\n     *   The date pattern field as parsed by {@link DateFormat#parseCldrDatePattern}\n     * @param {int} oField.digits\n     *   The number of repetitions of the pattern symbol, e.g. <code>3</code> for \"BBB\"\n     * @param {sap.ui.core.date.UniversalDate} oDate\n     *   The date object to format\n     * @param {boolean} bUTC\n     *   Whether the UTC option is set; not used\n     * @param {sap.ui.core.format.DateFormat} oFormat\n     *   The <code>DateFormat</code> instance\n     * @returns {string}\n     *   The selected day period e.g. \"in the afternoon\" for the according style width\n     *   \"abbreviated\", \"narrow\" or \"wide\"\n     */\n    format: function (oField, oDate, bUTC, oFormat) {\n      // If no hours symbol is contained in the pattern, the stand-alone format must be\n      // used. Only non-input skeleton symbols are used. The pattern symbols for hour can\n      // be found under:\n      // https://unicode.org/reports/tr35/tr35-dates.html#dfst-hour\n      var bContainsHour = oFormat.aFormatArray.some(function (oFormatElement) {\n          return \"hHKk\".includes(oFormatElement.symbol);\n        }),\n        sFlexibleDayPeriod = oFormat.oLocaleData.getFlexibleDayPeriodOfTime(oDate.getUTCHours(), oDate.getUTCMinutes());\n      if (bContainsHour) {\n        if (oField.digits <= 3) {\n          return oFormat.oFlexibleDayPeriodsAbbrev[sFlexibleDayPeriod];\n        }\n        if (oField.digits === 4) {\n          return oFormat.oFlexibleDayPeriodsWide[sFlexibleDayPeriod];\n        }\n        return oFormat.oFlexibleDayPeriodsNarrow[sFlexibleDayPeriod];\n      }\n      if (oField.digits <= 3) {\n        return oFormat.oFlexibleDayPeriodsAbbrevSt[sFlexibleDayPeriod];\n      }\n      if (oField.digits === 4) {\n        return oFormat.oFlexibleDayPeriodsWideSt[sFlexibleDayPeriod];\n      }\n      return oFormat.oFlexibleDayPeriodsNarrowSt[sFlexibleDayPeriod];\n    },\n    /**\n     * Parses the flexible day period from a given input string.\n     *\n     * @param {string} sValue\n     *   The given input, e.g. \"in the afternoon 01:37\"\n     * @param {Object<string, any>} oPart\n     *   The date pattern field as parsed by {@link DateFormat#parseCldrDatePattern}\n     * @param {sap.ui.core.format.DateFormat} oFormat\n     *   The <code>DateFormat</code> instance\n     * @param {object} oConfig\n     *   The configuration object for parsing the value\n     * @returns {{flexDayPeriod: string, length: number}|{valid: boolean}}\n     *   An object with the parsed <code>flexDayPeriod</code> and the <code>length</code>\n     *   value of the match; otherwise, an object with property <code>valid</code>\n     *   <code>false</code> if it could not be parsed correctly or in case it is attempted\n     *   to parse a string with a stand-alone format\n     */\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var i,\n        oFound,\n        oVariant,\n        bContainsHour = oFormat.aFormatArray.some(function (oFormatElement) {\n          return \"hHKk\".includes(oFormatElement.symbol);\n        }),\n        // \"aFlexibleDayPeriodVariants\" is ordered from \"wide\" to \"narrow\" to find the\n        // longest match\n        aFlexibleDayPeriodVariants = [oFormat.oFlexibleDayPeriodsWide, oFormat.oFlexibleDayPeriodsAbbrev, oFormat.oFlexibleDayPeriodsNarrow];\n      if (bContainsHour) {\n        for (i = 0; i < aFlexibleDayPeriodVariants.length; i++) {\n          oVariant = aFlexibleDayPeriodVariants[i];\n          oFound = oParseHelper.findEntry(sValue, Object.values(oVariant), oFormat.oLocaleData.sCLDRLocaleId);\n          if (oFound.index !== -1) {\n            return {\n              flexDayPeriod: Object.keys(oVariant)[oFound.index],\n              length: oFound.length\n            };\n          }\n        }\n      }\n      return {\n        valid: false\n      };\n    }\n  }),\n  \"H\": DateFormat._createPatternSymbol({\n    name: \"hour0_23\",\n    format: function (oField, oDate) {\n      var iHours = oDate.getUTCHours();\n      return String(iHours).padStart(oField.digits, \"0\");\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var sPart = oParseHelper.findNumbers(sValue, Math.max(oPart.digits, 2)),\n        iHours = parseInt(sPart),\n        bPartInvalid = sPart === \"\" || oConfig.exactLength && sPart.length < 2,\n        bValid = oParseHelper.checkValid(oPart.type, bPartInvalid, oFormat);\n      if (oConfig.strict && iHours > 23) {\n        bValid = false;\n      }\n      return {\n        hour: iHours,\n        length: sPart.length,\n        valid: bValid\n      };\n    },\n    isNumeric: true\n  }),\n  \"k\": DateFormat._createPatternSymbol({\n    name: \"hour1_24\",\n    format: function (oField, oDate) {\n      var iHours = oDate.getUTCHours();\n      var sHours = iHours === 0 ? \"24\" : String(iHours);\n      return sHours.padStart(oField.digits, \"0\");\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var sPart = oParseHelper.findNumbers(sValue, Math.max(oPart.digits, 2)),\n        iHours = parseInt(sPart),\n        bPartInvalid = sPart === \"\" || oConfig.exactLength && sPart.length < 2,\n        bValid = oParseHelper.checkValid(oPart.type, bPartInvalid, oFormat);\n      if (iHours === 24) {\n        iHours = 0;\n      }\n      if (oConfig.strict && iHours > 23) {\n        bValid = false;\n      }\n      return {\n        hour: iHours,\n        length: sPart.length,\n        valid: bValid\n      };\n    },\n    isNumeric: true\n  }),\n  \"K\": DateFormat._createPatternSymbol({\n    name: \"hour0_11\",\n    format: function (oField, oDate) {\n      var iHours = oDate.getUTCHours();\n      var sHours = String(iHours > 11 ? iHours - 12 : iHours);\n      return sHours.padStart(oField.digits, \"0\");\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var sPart = oParseHelper.findNumbers(sValue, Math.max(oPart.digits, 2)),\n        iHours = parseInt(sPart),\n        bPartInvalid = sPart === \"\" || oConfig.exactLength && sPart.length < 2,\n        bValid = oParseHelper.checkValid(oPart.type, bPartInvalid, oFormat);\n      if (oConfig.strict && iHours > 11) {\n        bValid = false;\n      }\n      return {\n        hour: iHours,\n        length: sPart.length,\n        valid: bValid\n      };\n    },\n    isNumeric: true\n  }),\n  \"h\": DateFormat._createPatternSymbol({\n    name: \"hour1_12\",\n    format: function (oField, oDate) {\n      var iHours = oDate.getUTCHours();\n      var sHours;\n      if (iHours > 12) {\n        sHours = String(iHours - 12);\n      } else if (iHours === 0) {\n        sHours = \"12\";\n      } else {\n        sHours = String(iHours);\n      }\n      return sHours.padStart(oField.digits, \"0\");\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var bPM = oConfig.dateValue.pm,\n        sPart = oParseHelper.findNumbers(sValue, Math.max(oPart.digits, 2)),\n        iHours = parseInt(sPart),\n        bPartInvalid = sPart === \"\" || oConfig.exactLength && sPart.length < 2,\n        bValid = oParseHelper.checkValid(oPart.type, bPartInvalid, oFormat);\n      if (iHours === 12) {\n        iHours = 0;\n        // change the PM only when it's not yet parsed\n        // 12:00 defaults to 12:00 PM\n        bPM = bPM === undefined ? true : bPM;\n      }\n      if (oConfig.strict && iHours > 11) {\n        bValid = false;\n      }\n      return {\n        hour: iHours,\n        length: sPart.length,\n        pm: bPM,\n        valid: bValid\n      };\n    },\n    isNumeric: true\n  }),\n  \"m\": DateFormat._createPatternSymbol({\n    name: \"minute\",\n    format: function (oField, oDate) {\n      var iMinutes = oDate.getUTCMinutes();\n      return String(iMinutes).padStart(oField.digits, \"0\");\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var sPart = oParseHelper.findNumbers(sValue, Math.max(oPart.digits, 2)),\n        iMinutes = parseInt(sPart),\n        bPartInvalid = sPart === \"\" || oConfig.exactLength && sPart.length < 2,\n        bValid = oParseHelper.checkValid(oPart.type, bPartInvalid, oFormat);\n      if (oConfig.strict && iMinutes > 59) {\n        bValid = false;\n      }\n      return {\n        length: sPart.length,\n        minute: iMinutes,\n        valid: bValid\n      };\n    },\n    isNumeric: true\n  }),\n  \"s\": DateFormat._createPatternSymbol({\n    name: \"second\",\n    format: function (oField, oDate) {\n      var iSeconds = oDate.getUTCSeconds();\n      return String(iSeconds).padStart(oField.digits, \"0\");\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var iExpectedDigits = Math.max(oPart.digits, 2),\n        sPart = oParseHelper.findNumbers(sValue, iExpectedDigits),\n        bPartInvalid = sPart === \"\" || oConfig.exactLength && sPart.length < iExpectedDigits,\n        iSeconds = parseInt(sPart),\n        bValid = oParseHelper.checkValid(oPart.type, bPartInvalid, oFormat);\n      if (oConfig.strict && iSeconds > 59) {\n        bValid = false;\n      }\n      return {\n        length: sPart.length,\n        second: iSeconds,\n        valid: bValid\n      };\n    },\n    isNumeric: true\n  }),\n  \"S\": DateFormat._createPatternSymbol({\n    name: \"fractionalsecond\",\n    format: function (oField, oDate) {\n      var iMilliseconds = oDate.getUTCMilliseconds();\n      var sMilliseconds = String(iMilliseconds);\n      var sFractionalseconds = sMilliseconds.padStart(3, \"0\");\n      sFractionalseconds = sFractionalseconds.substr(0, oField.digits);\n      sFractionalseconds = sFractionalseconds.padEnd(oField.digits, \"0\");\n      return sFractionalseconds;\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var sPart = oParseHelper.findNumbers(sValue, oPart.digits),\n        iLength = sPart.length,\n        bPartInvalid = oConfig.exactLength && iLength < oPart.digits;\n      sPart = sPart.substr(0, 3);\n      sPart = sPart.padEnd(3, \"0\");\n      var iMilliseconds = parseInt(sPart);\n      return {\n        length: iLength,\n        millisecond: iMilliseconds,\n        valid: oParseHelper.checkValid(oPart.type, bPartInvalid, oFormat)\n      };\n    },\n    isNumeric: true\n  }),\n  \"z\": DateFormat._createPatternSymbol({\n    name: \"timezoneGeneral\",\n    format: function (oField, oDate, bUTC, oFormat, sTimezone) {\n      //TODO getTimezoneLong and getTimezoneShort does not exist on Date object\n      //-> this is a preparation for a future full timezone support (only used by unit test so far)\n      if (oField.digits > 3 && oDate.getTimezoneLong && oDate.getTimezoneLong()) {\n        return oDate.getTimezoneLong();\n      } else if (oDate.getTimezoneShort && oDate.getTimezoneShort()) {\n        return oDate.getTimezoneShort();\n      }\n\n      // valid for zzzz (fallback to OOOO)\n      var iTimezoneOffset = TimezoneUtil.calculateOffset(oDate, sTimezone);\n      var sTimeZone = \"GMT\";\n      var iTZOffset = Math.abs(iTimezoneOffset / 60);\n      var bPositiveOffset = iTimezoneOffset > 0;\n      var iHourOffset = Math.floor(iTZOffset / 60);\n      var iMinuteOffset = Math.floor(iTZOffset % 60);\n      if (!bUTC && iTZOffset !== 0) {\n        sTimeZone += bPositiveOffset ? \"-\" : \"+\";\n        sTimeZone += String(iHourOffset).padStart(2, \"0\");\n        sTimeZone += \":\";\n        sTimeZone += String(iMinuteOffset).padStart(2, \"0\");\n      } else {\n        sTimeZone += \"Z\";\n      }\n      return sTimeZone;\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      var iLength = 0;\n      var iTZDiff;\n      var oTZ = sValue.substring(0, 3);\n      if (oTZ === \"GMT\" || oTZ === \"UTC\") {\n        iLength = 3;\n      } else if (sValue.substring(0, 2) === \"UT\") {\n        iLength = 2;\n      } else if (sValue.charAt(0) === \"Z\") {\n        iLength = 1;\n        iTZDiff = 0;\n      } else {\n        return {\n          error: \"cannot be parsed correctly by sap.ui.core.format.DateFormat: The given timezone is not supported!\"\n        };\n      }\n      if (sValue.charAt(0) !== \"Z\") {\n        var oParsedTZ = oParseHelper.parseTZ(sValue.substr(iLength), true);\n        iLength += oParsedTZ.length;\n        iTZDiff = oParsedTZ.tzDiff;\n      }\n      return {\n        length: iLength,\n        tzDiff: iTZDiff\n      };\n    }\n  }),\n  \"Z\": DateFormat._createPatternSymbol({\n    name: \"timezoneRFC822\",\n    format: function (oField, oDate, bUTC, oFormat, sTimezone) {\n      var iTimezoneOffset = TimezoneUtil.calculateOffset(oDate, sTimezone);\n      var iTZOffset = Math.abs(iTimezoneOffset / 60);\n      var bPositiveOffset = iTimezoneOffset > 0;\n      var iHourOffset = Math.floor(iTZOffset / 60);\n      var iMinuteOffset = Math.floor(iTZOffset % 60);\n      var sTimeZone = \"\";\n\n      // valid for Z-ZZZ\n      // per RFC822 a timezone always has 4 digits\n      // UTC+0: \"+0000\"\n      // UTC-7: \"-0700\"\n      // UTC+2: \"+0200\"\n      // https://tools.ietf.org/html/rfc822 paragraph 5.1\n      if (!bUTC) {\n        sTimeZone += bPositiveOffset ? \"-\" : \"+\";\n        sTimeZone += String(iHourOffset).padStart(2, \"0\");\n        sTimeZone += String(iMinuteOffset).padStart(2, \"0\");\n      }\n      return sTimeZone;\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      return oParseHelper.parseTZ(sValue, false);\n    }\n  }),\n  \"X\": DateFormat._createPatternSymbol({\n    name: \"timezoneISO8601\",\n    format: function (oField, oDate, bUTC, oFormat, sTimezone) {\n      /*\n       * Mountain Standard Time (MST, UTC-7)\n       * X:           \"-07\"\n       * XX, XXXX:    \"-0700\"\n       * XXX, XXXXX:  \"-07:00\"\n       */\n\n      /*\n       * Central European Summer Time (CEST, UTC+2)\n       * X:           \"+02\"\n       * XX, XXXX:    \"+0200\"\n       * XXX, XXXXX:  \"+02:00\"\n       */\n\n      /*\n       * Indian Standard Time (IST, UTC+5:30)\n       * X:           \"+0530\"\n       * XX, XXXX:    \"+0530\"\n       * XXX, XXXXX:  \"+05:30\"\n       */\n\n      /*\n       * Greenwich Mean Time (GMT, UTC+0)\n       * X:           \"Z\"\n       * XX, XXXX:    \"Z\"\n       * XXX, XXXXX:  \"Z\"\n       */\n\n      // @see http://www.unicode.org/reports/tr35/tr35-dates.html#Time_Zone_Goals\n      var iTimezoneOffset = TimezoneUtil.calculateOffset(oDate, sTimezone);\n      var iTZOffset = Math.abs(iTimezoneOffset / 60);\n      var bPositiveOffset = iTimezoneOffset > 0;\n      var iHourOffset = Math.floor(iTZOffset / 60);\n      var iMinuteOffset = Math.floor(iTZOffset % 60);\n      var sTimeZone = \"\";\n      if (!bUTC && iTZOffset !== 0) {\n        sTimeZone += bPositiveOffset ? \"-\" : \"+\";\n        sTimeZone += String(iHourOffset).padStart(2, \"0\");\n        if (oField.digits > 1 || iMinuteOffset > 0) {\n          if (oField.digits === 3 || oField.digits === 5) {\n            sTimeZone += \":\";\n          }\n          sTimeZone += String(iMinuteOffset).padStart(2, \"0\");\n        }\n      } else {\n        sTimeZone += \"Z\";\n      }\n      return sTimeZone;\n    },\n    parse: function (sValue, oPart, oFormat, oConfig) {\n      if (sValue.charAt(0) === \"Z\") {\n        return {\n          length: 1,\n          tzDiff: 0\n        };\n      } else {\n        return oParseHelper.parseTZ(sValue, oPart.digits === 3 || oPart.digits === 5);\n      }\n    }\n  }),\n  \"V\": DateFormat._createPatternSymbol({\n    name: \"timezoneID\",\n    format: function (oField, oDate, bUTC, oFormat, sTimezone) {\n      // Only VV is supported\n      // The IANA time zone ID\n      // e.g. America/New_York\n      // @see http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns\n      if (!bUTC && oField.digits === 2) {\n        // fallback for unknown but valid IANA time zone IDs (IANA is a living standard and the browser\n        // might support more, while the CLDR data is fixed) such that the user can see, that there is no\n        // translation\n        return oFormat.oLocaleData.getTimezoneTranslations()[sTimezone] || sTimezone;\n      }\n      return \"\";\n    },\n    parse: function (sValue, oPart, oFormat, oConfig, sTimezone) {\n      var oTimezoneParsed = {\n        timezone: \"\",\n        length: 0\n      };\n\n      // VV - The long IANA time zone ID\n      if (oPart.digits === 2) {\n        var mTimezoneTranslations = oFormat.oLocaleData.getTimezoneTranslations();\n\n        // shortcut, first try the time zone parameter\n        if (sValue === mTimezoneTranslations[sTimezone]) {\n          return {\n            timezone: sTimezone,\n            length: sValue.length\n          };\n        }\n        var aTimezoneTranslations = Object.values(mTimezoneTranslations);\n        var oTimezoneResult = oParseHelper.findEntry(sValue, aTimezoneTranslations, oFormat.oLocaleData.sCLDRLocaleId);\n        if (oTimezoneResult.index !== -1) {\n          return {\n            timezone: Object.keys(mTimezoneTranslations)[oTimezoneResult.index],\n            length: oTimezoneResult.length\n          };\n        }\n\n        // fallback for IANA time zone IDs\n        var sCurrentValue = \"\";\n        // find the longest valid time zone ID at the beginning of sValue\n        for (var i = sValue.length; i > 0; i -= 1) {\n          sCurrentValue = sValue.slice(0, i);\n          if (TimezoneUtil.isValidTimezone(sCurrentValue)) {\n            oTimezoneParsed.timezone = sCurrentValue;\n            oTimezoneParsed.length = sCurrentValue.length;\n            break;\n          }\n        }\n      }\n      return oTimezoneParsed;\n    }\n  })\n};\nDateFormat.prototype._format = function (oJSDate, bUTC, sTimezone) {\n  if (this.oFormatOptions.relative) {\n    var sRes = this.formatRelative(oJSDate, bUTC, this.oFormatOptions.relativeRange, sTimezone);\n    if (sRes) {\n      //Stop when relative formatting possible, else go on with standard formatting\n      return sRes;\n    }\n  }\n  var sCalendarType = this.oFormatOptions.calendarType;\n  var oDate = UniversalDate.getInstance(oJSDate, sCalendarType);\n  var aBuffer = [],\n    oPart,\n    sResult,\n    sSymbol;\n  for (var i = 0; i < this.aFormatArray.length; i++) {\n    oPart = this.aFormatArray[i];\n    sSymbol = oPart.symbol || \"\";\n    aBuffer.push(this.oSymbols[sSymbol].format(oPart, oDate, bUTC, this, sTimezone));\n  }\n  sResult = aBuffer.join(\"\");\n  if (Supportability.collectOriginInfo()) {\n    // String object is created on purpose and must not be a string literal\n    // eslint-disable-next-line no-new-wrappers\n    sResult = new String(sResult);\n    sResult.originInfo = {\n      source: \"Common Locale Data Repository\",\n      locale: this.oLocale.toString(),\n      style: this.oFormatOptions.style,\n      pattern: this.oFormatOptions.pattern\n    };\n  }\n  return sResult;\n};\n\n/**\n * Format a date according to the given format options.\n *\n * Uses the timezone from {@link sap.ui.core.Configuration#getTimezone}, which falls back to the\n * browser's local timezone to convert the given date.\n *\n * When using instances from getDateTimeWithTimezoneInstance, please see the corresponding documentation:\n * {@link sap.ui.core.format.DateFormat.DateTimeWithTimezone#format}.\n *\n * @example <caption>DateTime (assuming timezone \"Europe/Berlin\")</caption>\n * var oDate = UI5Date.getInstance(\"2021-12-24T13:37:00Z\");\n * DateFormat.getDateTimeInstance().format(oDate);\n * // output: \"Dec 24, 2021, 2:37:00 PM\"\n *\n * @param {Date|Date[]} vJSDate the value to format\n * @param {boolean} [bUTC=false] whether to use UTC\n * @return {string} the formatted output value. If an invalid date is given, an empty string is returned.\n * @public\n */\nDateFormat.prototype.format = function (vJSDate, bUTC) {\n  var sTimezone;\n  if (this.type === mDateFormatTypes.DATETIME_WITH_TIMEZONE) {\n    // UTC and timezone are not supported at the same time, therefore set bUTC to false\n    sTimezone = bUTC;\n    bUTC = false;\n    checkTimezoneParameterType(sTimezone);\n    if (sTimezone && !TimezoneUtil.isValidTimezone(sTimezone)) {\n      Log.error(\"The given timezone isn't valid.\");\n      return \"\";\n    }\n  }\n  var sCalendarType = this.oFormatOptions.calendarType,\n    sResult;\n  if (bUTC === undefined) {\n    bUTC = this.oFormatOptions.UTC;\n  }\n\n  // default the timezone to the local timezone to always enforce the conversion\n  sTimezone = sTimezone || Configuration.getTimezone();\n  if (Array.isArray(vJSDate)) {\n    if (!this.oFormatOptions.interval) {\n      Log.error(\"Non-interval DateFormat can't format more than one date instance.\");\n      return \"\";\n    }\n    if (vJSDate.length !== 2) {\n      Log.error(\"Interval DateFormat can only format with 2 date instances but \" + vJSDate.length + \" is given.\");\n      return \"\";\n    }\n    vJSDate = vJSDate.map(function (oJSDate) {\n      return convertToTimezone(oJSDate, sTimezone, bUTC);\n    });\n    if (this.oFormatOptions.singleIntervalValue) {\n      if (vJSDate[0] === null) {\n        Log.error(\"First date instance which is passed to the interval DateFormat shouldn't be null.\");\n        return \"\";\n      }\n      if (vJSDate[1] === null) {\n        sResult = this._format(vJSDate[0], bUTC, sTimezone);\n      }\n    }\n    if (sResult === undefined) {\n      if (!vJSDate.every(isValidDateObject)) {\n        Log.error(\"At least one date instance which is passed to the interval DateFormat isn't valid.\");\n        return \"\";\n      }\n      sResult = this._formatInterval(vJSDate, bUTC);\n    }\n  } else {\n    if (!isValidDateObject(vJSDate)) {\n      // Although an invalid date was given, the DATETIME_WITH_TIMEZONE instance might\n      // have a pattern with the timezone (VV) inside then the IANA timezone ID is returned\n      if (this.type === mDateFormatTypes.DATETIME_WITH_TIMEZONE && this.oFormatOptions.pattern.includes(\"VV\")) {\n        return this.oLocaleData.getTimezoneTranslations()[sTimezone] || sTimezone;\n      }\n      Log.error(\"The given date instance isn't valid.\");\n      return \"\";\n    }\n    if (this.oFormatOptions.interval) {\n      Log.error(\"Interval DateFormat expects an array with two dates for the first argument but only one date is given.\");\n      return \"\";\n    }\n    vJSDate = convertToTimezone(vJSDate, sTimezone, bUTC);\n    sResult = this._format(vJSDate, bUTC, sTimezone);\n  }\n\n  // Support Japanese Gannen instead of Ichinen for first year of the era\n  if (sCalendarType === CalendarType.Japanese && this.oLocale.getLanguage() === \"ja\") {\n    sResult = sResult.replace(/(^|[^\\d])1年/g, \"$1元年\");\n  }\n  return sResult;\n};\n\n/**\n * Checks whether the interval to be formatted has to use the pattern of a custom interval delimiter.\n *\n * @param {object} oDiffFields\n *   An object describing which date information is required for this instance's interval format,\n *   for example <code>{\"Day\": true, \"Minutes\": true}</code>\n * @returns {boolean}\n *   Whether to use the custom interval delimiter pattern\n *\n * @private\n */\nDateFormat.prototype._useCustomIntervalDelimiter = function (oDiffFields) {\n  var aTokens;\n  if (!this.oFormatOptions.intervalDelimiter) {\n    return false;\n  }\n  // If there are no differences in the date/time parts specified by \"oFormatOptions.format\", a single value is\n  // formatted and there is no need to use the custom delimiter pattern.\n  if (this.oFormatOptions.format) {\n    aTokens = this.oLocaleData._parseSkeletonFormat(this.oFormatOptions.format);\n    return aTokens.some(function (oToken) {\n      return oDiffFields[oToken.group];\n    });\n  }\n  return true;\n};\nDateFormat.prototype._formatInterval = function (aJSDates, bUTC) {\n  var oDate,\n    oPart,\n    sPattern,\n    sSymbol,\n    aBuffer = [],\n    sCalendarType = this.oFormatOptions.calendarType,\n    aFormatArray = [],\n    oFromDate = UniversalDate.getInstance(aJSDates[0], sCalendarType),\n    oToDate = UniversalDate.getInstance(aJSDates[1], sCalendarType),\n    oDiffFields = this._getDiffFields([oFromDate, oToDate]);\n  if (!oDiffFields) {\n    return this._format(aJSDates[0], bUTC);\n  }\n  if (this._useCustomIntervalDelimiter(oDiffFields)) {\n    sPattern = this.intervalPatterns[0];\n  } else if (this.oFormatOptions.format) {\n    // when 'format' option is set, generate the pattern based on the greatest difference\n    sPattern = this.oLocaleData.getCustomIntervalPattern(this.oFormatOptions.format, oDiffFields, sCalendarType);\n  } else {\n    sPattern = this.oLocaleData.getCombinedIntervalPattern(this.oFormatOptions.pattern, sCalendarType);\n  }\n  aFormatArray = this.parseCldrDatePattern(sPattern);\n  oDate = oFromDate;\n  for (var i = 0; i < aFormatArray.length; i++) {\n    oPart = aFormatArray[i];\n    sSymbol = oPart.symbol || \"\";\n    if (oPart.repeat) {\n      oDate = oToDate;\n    }\n    aBuffer.push(this.oSymbols[sSymbol].format(oPart, oDate, bUTC, this));\n  }\n  return aBuffer.join(\"\");\n};\nvar mFieldToGroup = {\n  Era: \"Era\",\n  FullYear: \"Year\",\n  Quarter: \"Quarter\",\n  Month: \"Month\",\n  Week: \"Week\",\n  Date: \"Day\",\n  DayPeriod: \"DayPeriod\",\n  Hours: \"Hour\",\n  Minutes: \"Minute\",\n  Seconds: \"Second\"\n};\n\n/**\n * Returns an object containing the relevant date/time parts that differ in the two given dates.\n *\n * @param {sap.ui.core.date.UniversalDate[]} aDates\n *   An array with two UniversalDate instances representing the start and the end date of the interval;\n *   the dates are expected to be in UTC time zone\n * @returns {Object<string, boolean>|null}\n *   An object containing the different date/time parts, or <code>null</code> if the dates are the same\n *\n * @private\n */\nDateFormat.prototype._getDiffFields = function (aDates) {\n  var bDiffFound = false,\n    mDiff = {};\n  this.aIntervalCompareFields.forEach(function (sField) {\n    var sGetterPrefix = \"getUTC\",\n      sMethodName = sGetterPrefix + sField,\n      sFieldGroup = mFieldToGroup[sField],\n      vFromValue = aDates[0][sMethodName].apply(aDates[0]),\n      vToValue = aDates[1][sMethodName].apply(aDates[1]);\n    if (!deepEqual(vFromValue, vToValue)) {\n      bDiffFound = true;\n      mDiff[sFieldGroup] = true;\n    }\n  });\n  if (bDiffFound) {\n    return mDiff;\n  }\n  return null;\n};\nDateFormat.prototype._parse = function (sValue, aFormatArray, bUTC, bStrict, sTimezone) {\n  var sFlexibleDayPeriod,\n    oNextPart,\n    oPart,\n    bPM,\n    oPrevPart,\n    oResult,\n    sSubValue,\n    oDateValue = {\n      valid: true,\n      lastTimezonePatternSymbol: \"\"\n    },\n    iIndex = 0,\n    oParseConf = {\n      formatArray: aFormatArray,\n      dateValue: oDateValue,\n      strict: bStrict\n    },\n    that = this;\n  function getSymbol(oPart0) {\n    return that.oSymbols[oPart0.symbol || \"\"];\n  }\n  function isNumeric(oPart0) {\n    return !!oPart0 && getSymbol(oPart0).isNumeric(oPart0.digits);\n  }\n  for (var i = 0; i < aFormatArray.length; i++) {\n    sSubValue = sValue.substr(iIndex);\n    oPart = aFormatArray[i];\n    oPrevPart = aFormatArray[i - 1];\n    oNextPart = aFormatArray[i + 1];\n    oParseConf.index = i;\n    oParseConf.exactLength = isNumeric(oPart) && (isNumeric(oPrevPart) || isNumeric(oNextPart));\n    oResult = getSymbol(oPart).parse(sSubValue, oPart, this, oParseConf, sTimezone) || {};\n    // Remember the last required timezone difference which needs to be calculated (V pattern) or applied (x and z pattern)\n    if (oResult.tzDiff !== undefined || oResult.timezone) {\n      oResult.lastTimezonePatternSymbol = oPart.symbol;\n    }\n    oDateValue = extend(oDateValue, oResult);\n    if (oResult.valid === false) {\n      break;\n    }\n    iIndex += oResult.length || 0;\n  }\n  oDateValue.index = iIndex;\n  bPM = oDateValue.pm;\n  // \"getFlexibleDayPeriodOfTime\" is required if the given time is earlier than 12 pm because,\n  // for a \"h\" pattern it can't distinguished whether e.g. 1 o'clock is meant to be AM or PM\n  if (oDateValue.flexDayPeriod && oDateValue.hour * 60 + (oDateValue.minute || 0) < 720) {\n    sFlexibleDayPeriod = this.oLocaleData.getFlexibleDayPeriodOfTime(oDateValue.hour + 12, oDateValue.minute || 0);\n    bPM = oDateValue.flexDayPeriod === sFlexibleDayPeriod;\n  }\n  if (bPM) {\n    oDateValue.hour += 12;\n  }\n\n  // use dayOfWeek (E) as dayNumberOfWeek (u) if dayNumberOfWeek (u) is not present\n  if (oDateValue.dayNumberOfWeek === undefined && oDateValue.dayOfWeek !== undefined) {\n    oDateValue.dayNumberOfWeek = this._adaptDayOfWeek(oDateValue.dayOfWeek);\n  }\n  if (oDateValue.quarter !== undefined && oDateValue.month === undefined && oDateValue.day === undefined) {\n    oDateValue.month = 3 * oDateValue.quarter;\n    oDateValue.day = 1;\n  }\n  return oDateValue;\n};\nDateFormat.prototype._parseInterval = function (sValue, sCalendarType, bUTC, bStrict, sTimezone) {\n  var aDateValues, iRepeat, oDateValue;\n\n  // Try out with all possible patterns until successfully parse has been done or the end of the array is reached\n  this.intervalPatterns.some(function (sPattern) {\n    var aFormatArray = this.parseCldrDatePattern(sPattern);\n    iRepeat = undefined;\n\n    // loop through aFormatArray until we have found the repeated date symbol and get the index\n    for (var i = 0; i < aFormatArray.length; i++) {\n      if (aFormatArray[i].repeat) {\n        iRepeat = i;\n        break;\n      }\n    }\n    if (iRepeat === undefined) {\n      // In case of standard date pattern, parse string as single date and put the same date twice into the aDateValues array\n      oDateValue = this._parse(sValue, aFormatArray, bUTC, bStrict, sTimezone);\n\n      // If input value has not been completely parsed, mark it as invalid\n      if (oDateValue.index === 0 || oDateValue.index < sValue.length) {\n        oDateValue.valid = false;\n      }\n      if (oDateValue.valid === false) {\n        return;\n      }\n      aDateValues = [oDateValue, oDateValue];\n      return true;\n    } else {\n      aDateValues = [];\n\n      // Call _parse function with start 0 and end index of repeated symbol\n      oDateValue = this._parse(sValue, aFormatArray.slice(0, iRepeat), bUTC, bStrict, sTimezone);\n      if (oDateValue.valid === false) {\n        return;\n      }\n      aDateValues.push(oDateValue);\n      var iLength = oDateValue.index;\n\n      // Call _parse function with start iRepeat and end of array\n      oDateValue = this._parse(sValue.substring(iLength), aFormatArray.slice(iRepeat), bUTC, bStrict, sTimezone);\n\n      // If input value has not been completely parsed, mark it as invalid\n      if (oDateValue.index === 0 || oDateValue.index + iLength < sValue.length) {\n        oDateValue.valid = false;\n      }\n      if (oDateValue.valid === false) {\n        return;\n      }\n      aDateValues.push(oDateValue);\n      return true;\n    }\n  }.bind(this));\n  return aDateValues;\n};\n\n/**\n * Retrieves the parameter for the calendar week configuration from the DateFormat's format\n * options\n *\n * @param {{firstDayOfWeek: int, minimalDaysInFirstWeek: int, calendarWeekNumbering: sap.ui.core.date.CalendarWeekNumbering}} oFormatOptions\n *   The format options with which the DateFormat instance was created\n * @returns {sap.ui.core.date.CalendarWeekNumbering|{firstDayOfWeek: int, minimalDaysInFirstWeek: int}|undefined}\n *   The parameter for the calendar week configuration\n */\nfunction getCalendarWeekParameter(oFormatOptions) {\n  if (oFormatOptions.calendarWeekNumbering) {\n    return oFormatOptions.calendarWeekNumbering;\n    // either both are provided or none (checked in DateFormat.createInstance)\n  } else if (oFormatOptions.firstDayOfWeek !== undefined && oFormatOptions.minimalDaysInFirstWeek !== undefined) {\n    return {\n      firstDayOfWeek: oFormatOptions.firstDayOfWeek,\n      minimalDaysInFirstWeek: oFormatOptions.minimalDaysInFirstWeek\n    };\n  }\n  return undefined;\n}\n\n/**\n * Converts a given date to the given timezone if bUTC is false\n *\n * @param {Date} oJSDate The date which should be converted\n * @param {string} sTimezone target timezone\n * @param {boolean} bUTC whether it is utc\n * @returns {Date} the converted date\n */\nvar convertToTimezone = function (oJSDate, sTimezone, bUTC) {\n  // Convert to timezone if provided and a valid date is supplied\n  if (!bUTC && isValidDateObject(oJSDate)) {\n    // convert given date to a date in the target timezone\n    return TimezoneUtil.convertToTimezone(oJSDate, sTimezone);\n  }\n  return oJSDate;\n};\n\n// recreate javascript date object from the given oDateValues.\n// In case of oDateValue.valid == false, null value will be returned\nvar fnCreateDate = function (oDateValue, sCalendarType, bUTC, bStrict, sTimezone, oFormatOptions, oLocale) {\n  if (!oDateValue.valid) {\n    return null;\n  }\n  var oDate,\n    iYear = typeof oDateValue.year === \"number\" ? oDateValue.year : 1970;\n\n  // no need to use UI5Date.getInstance as only the UTC timestamp is used\n  oDate = UniversalDate.getInstance(new Date(0), sCalendarType);\n  oDate.setUTCEra(oDateValue.era || UniversalDate.getCurrentEra(sCalendarType));\n  // Set parsed year, month and day in one call to avoid calculation issues when converting the calendar specific\n  // date into a Gregorian date.\n  oDate.setUTCFullYear(iYear, oDateValue.month || 0, oDateValue.day || 1);\n  oDate.setUTCHours(oDateValue.hour || 0);\n  oDate.setUTCMinutes(oDateValue.minute || 0);\n  oDate.setUTCSeconds(oDateValue.second || 0);\n  oDate.setUTCMilliseconds(oDateValue.millisecond || 0);\n  if (bStrict && (oDateValue.day || 1) !== oDate.getUTCDate()) {\n    // check if valid date given - if invalid, day is not the same (31.Apr -> 1.May)\n    return null;\n  }\n  if (oDateValue.week !== undefined && (oDateValue.month === undefined || oDateValue.day === undefined)) {\n    //check that the week is only set if the day/month has not been set, because day/month have higher precedence than week\n    oDate.setUTCWeek({\n      year: oDateValue.weekYear || oDateValue.year,\n      week: oDateValue.week\n    }, oLocale, getCalendarWeekParameter(oFormatOptions));\n\n    // add the dayNumberOfWeek to the current day\n    if (oDateValue.dayNumberOfWeek !== undefined) {\n      oDate.setUTCDate(oDate.getUTCDate() + oDateValue.dayNumberOfWeek - 1);\n    }\n  }\n  oDate = oDate.getJSDate();\n\n  // Set the tzDiff based on the timezone difference\n  if (!bUTC && (oDateValue.lastTimezonePatternSymbol === \"V\" && oDateValue.timezone || oDateValue.tzDiff === undefined)) {\n    // The last parsed timezone pattern will be considered. If this is the \"V\" pattern for the IANA timezone ID, it needs\n    // to be calculated here. The tzDiff cannot be determined in the parse method because we need the parsed parts to calculate it.\n    if (oDateValue.timezone) {\n      sTimezone = oDateValue.timezone;\n    }\n    if (sTimezone) {\n      oDateValue.tzDiff = TimezoneUtil.calculateOffset(oDate, sTimezone);\n    }\n  }\n  if (oDateValue.tzDiff) {\n    // tzDiff is in seconds for a higher precision (historical timezone might have differences in seconds)\n    // e.g. UI5Date.getInstance(\"1730-01-01T00:00:00Z\")\n    // is in Berlin: Sun Jan 01 1730 00:53:28 GMT+0053 (Central European Standard Time)\n    oDate.setUTCSeconds(oDate.getUTCSeconds() + oDateValue.tzDiff);\n  }\n  return oDate;\n};\n\n// Copy the properties of object2 into object1 without\n// overwriting the existing properties in object1\nfunction mergeWithoutOverwrite(object1, object2) {\n  if (object1 === object2) {\n    return object1;\n  }\n  var oMergedObject = {};\n\n  // Clone object1\n  Object.keys(object1).forEach(function (sKey) {\n    oMergedObject[sKey] = object1[sKey];\n  });\n\n  // merge\n  Object.keys(object2).forEach(function (sKey) {\n    if (!oMergedObject.hasOwnProperty(sKey)) {\n      oMergedObject[sKey] = object2[sKey];\n    }\n  });\n  return oMergedObject;\n}\n\n// Checks if the given start date is before the end date.\nfunction isValidDateRange(oStartDate, oEndDate) {\n  if (oStartDate.getTime() > oEndDate.getTime()) {\n    return false;\n  }\n  return true;\n}\n\n// the expectation is that a valid Date has a getTime function which returns a valid number\nfunction isValidDateObject(oDate) {\n  return oDate && typeof oDate.getTime === \"function\" && !isNaN(oDate.getTime());\n}\n\n/**\n * Parse a string which is formatted according to the given format options.\n *\n * Uses the timezone from {@link sap.ui.core.Configuration#getTimezone}, which falls back to the\n * browser's local timezone to convert the given date.\n *\n * When using instances from getDateTimeWithTimezoneInstance, please see the corresponding documentation:\n * {@link sap.ui.core.format.DateFormat.DateTimeWithTimezone#parse}.\n *\n * @example <caption>DateTime (assuming timezone \"Europe/Berlin\")</caption>\n * var oDate = UI5Date.getInstance(\"2021-12-24T13:37:00Z\");\n * DateFormat.getDateTimeInstance().parse(\"Dec 24, 2021, 2:37:00 PM\");\n * // output: oDate\n *\n * @param {string} sValue the string containing a formatted date/time value\n * @param {boolean} [bUTC] whether to use UTC\n * @param {boolean} [bStrict] whether to use strict value check\n * @return {Date|Date[]|module:sap/ui/core/date/UI5Date|module:sap/ui/core/date/UI5Date[]} the parsed value(s)\n * @public\n */\nDateFormat.prototype.parse = function (sValue, bUTC, bStrict) {\n  // in order to convert a datetime to a timezone both the date and the time part are required.\n  // If only one is present it cannot be guaranteed that the parsed result is correct, due to\n  // daylight saving time which might shift hours and the timezone difference which might shift\n  // days. For now only the date and time can be parsed using a timezone.\n  var bShowDate = this.oFormatOptions.showDate === undefined || this.oFormatOptions.showDate;\n  var bShowTime = this.oFormatOptions.showTime === undefined || this.oFormatOptions.showTime;\n  if (this.type === mDateFormatTypes.DATETIME_WITH_TIMEZONE && (bShowDate && !bShowTime || !bShowDate && bShowTime)) {\n    throw new TypeError(\"The input can only be parsed back to date if both date and time are supplied.\");\n  }\n  var sTimezone;\n  if (bUTC === undefined && this.type !== mDateFormatTypes.DATETIME_WITH_TIMEZONE) {\n    bUTC = this.oFormatOptions.UTC;\n  }\n  // preserve UTC parameter for fallback instances (must inherit format option UTC from parent)\n  var bUTCInputParameter = bUTC;\n  if (this.type === mDateFormatTypes.DATETIME_WITH_TIMEZONE) {\n    // UTC and timezone are not supported at the same time, therefore set bUTC to false\n    sTimezone = bUTC;\n    bUTC = false;\n    checkTimezoneParameterType(sTimezone);\n    if (sTimezone && !TimezoneUtil.isValidTimezone(sTimezone)) {\n      Log.error(\"The given timezone isn't valid.\");\n      return null;\n    }\n  }\n  sValue = sValue == null ? \"\" : String(sValue).trim();\n  // normalize input by removing all RTL special characters and replacing all special spaces\n  // by a standard space (\\u0020)\n  sValue = DateFormat._normalize(sValue);\n  var oDateValue;\n  var sCalendarType = this.oFormatOptions.calendarType;\n\n  // default the timezone to the local timezone to always enforce the conversion\n  sTimezone = sTimezone || Configuration.getTimezone();\n  if (bStrict === undefined) {\n    bStrict = this.oFormatOptions.strictParsing;\n  }\n\n  // Support Japanese Gannen instead of Ichinen for first year of the era\n  if (sCalendarType === CalendarType.Japanese && this.oLocale.getLanguage() === \"ja\") {\n    sValue = sValue.replace(/元年/g, \"1年\");\n  }\n  if (!this.oFormatOptions.interval) {\n    var oJSDate = this.parseRelative(sValue, bUTC);\n    if (oJSDate) {\n      //Stop when relative parsing possible, else go on with standard parsing\n      return oJSDate;\n    }\n    oDateValue = this._parse(sValue, this.aFormatArray, bUTC, bStrict, sTimezone);\n\n    // If input value has not been completely parsed, mark it as invalid\n    if (oDateValue.index === 0 || oDateValue.index < sValue.length) {\n      oDateValue.valid = false;\n    }\n    oJSDate = fnCreateDate(oDateValue, sCalendarType, bUTC, bStrict, sTimezone, this.oFormatOptions, this.oLocale);\n    if (oJSDate) {\n      if (this.type === mDateFormatTypes.DATETIME_WITH_TIMEZONE) {\n        var bShowTimezone = this.oFormatOptions.showTimezone === undefined || this.oFormatOptions.showTimezone;\n        // fill fields according to showDate, showTime and showTimezone options and parsed values\n        if (!bShowTimezone && bShowDate && bShowTime) {\n          return [oJSDate, undefined];\n        } else if (bShowTimezone && !bShowDate && !bShowTime) {\n          return [undefined, oDateValue.timezone];\n        }\n        return [oJSDate, oDateValue.timezone || undefined];\n      }\n      return oJSDate;\n    }\n  } else {\n    var aDateValues = this._parseInterval(sValue, sCalendarType, bUTC, bStrict, sTimezone);\n    var oJSDate1, oJSDate2;\n    if (aDateValues && aDateValues.length === 2) {\n      var oDateValue1 = mergeWithoutOverwrite(aDateValues[0], aDateValues[1]);\n      var oDateValue2 = mergeWithoutOverwrite(aDateValues[1], aDateValues[0]);\n      oJSDate1 = fnCreateDate(oDateValue1, sCalendarType, bUTC, bStrict, sTimezone, this.oFormatOptions, this.oLocale);\n      oJSDate2 = fnCreateDate(oDateValue2, sCalendarType, bUTC, bStrict, sTimezone, this.oFormatOptions, this.oLocale);\n      if (oJSDate1 && oJSDate2) {\n        if (this.oFormatOptions.singleIntervalValue && oJSDate1.getTime() === oJSDate2.getTime()) {\n          return [oJSDate1, null];\n        }\n        var bValid = isValidDateRange(oJSDate1, oJSDate2);\n        if (bStrict && !bValid) {\n          Log.error(\"StrictParsing: Invalid date range. The given end date is before the start date.\");\n          return [null, null];\n        }\n        return [oJSDate1, oJSDate2];\n      }\n    }\n  }\n  if (this.aFallbackFormats) {\n    var vDate;\n    this.aFallbackFormats.every(function (oFallbackFormat) {\n      vDate = oFallbackFormat.parse(sValue, bUTCInputParameter, bStrict);\n      if (Array.isArray(vDate)) {\n        if (oFallbackFormat.type === mDateFormatTypes.DATETIME_WITH_TIMEZONE) {\n          return false;\n        }\n        return !(vDate[0] && vDate[1]);\n      } else {\n        return !vDate;\n      }\n    });\n    return vDate;\n  }\n  if (!this.oFormatOptions.interval) {\n    return null;\n  } else {\n    return [null, null];\n  }\n};\n\n/**\n * Parse the date pattern string and create a format array from it, which can be\n * used for parsing and formatting the date\n *\n * @param {string} sPattern the CLDR date pattern string\n * @returns {Array} format array\n */\nDateFormat.prototype.parseCldrDatePattern = function (sPattern) {\n  if (mCldrDatePattern[sPattern]) {\n    return mCldrDatePattern[sPattern];\n  }\n  var aFormatArray = [],\n    i,\n    bQuoted = false,\n    oCurrentObject = null,\n    sState = \"\",\n    sNewState = \"\",\n    mAppeared = {},\n    bIntervalStartFound = false;\n  for (i = 0; i < sPattern.length; i++) {\n    var sCurChar = sPattern.charAt(i),\n      sNextChar,\n      sPrevChar,\n      sPrevPrevChar;\n    if (bQuoted) {\n      if (sCurChar === \"'\") {\n        sPrevChar = sPattern.charAt(i - 1);\n        sPrevPrevChar = sPattern.charAt(i - 2);\n        sNextChar = sPattern.charAt(i + 1);\n        // handle abc''def correctly\n        if (sPrevChar === \"'\" && sPrevPrevChar !== \"'\") {\n          bQuoted = false;\n        } else if (sNextChar === \"'\") {\n          // handle 'abc''def' correctly\n\n          i += 1;\n        } else {\n          //  normal quote 'abcdef'\n          bQuoted = false;\n          continue;\n        }\n      }\n      if (sState === \"text\") {\n        oCurrentObject.value += sCurChar;\n      } else {\n        oCurrentObject = {\n          type: \"text\",\n          value: sCurChar\n        };\n        aFormatArray.push(oCurrentObject);\n        sState = \"text\";\n      }\n    } else {\n      if (sCurChar === \"'\") {\n        bQuoted = true;\n      } else if (this.oSymbols[sCurChar]) {\n        sNewState = this.oSymbols[sCurChar].name;\n        if (sState === sNewState) {\n          oCurrentObject.digits++;\n        } else {\n          oCurrentObject = {\n            type: sNewState,\n            symbol: sCurChar,\n            digits: 1\n          };\n          aFormatArray.push(oCurrentObject);\n          sState = sNewState;\n          if (!bIntervalStartFound) {\n            if (mAppeared[sNewState]) {\n              oCurrentObject.repeat = true;\n              bIntervalStartFound = true;\n            } else {\n              mAppeared[sNewState] = true;\n            }\n          }\n        }\n      } else {\n        if (sState === \"text\") {\n          oCurrentObject.value += sCurChar;\n        } else {\n          oCurrentObject = {\n            type: \"text\",\n            value: sCurChar\n          };\n          aFormatArray.push(oCurrentObject);\n          sState = \"text\";\n        }\n      }\n    }\n  }\n  mCldrDatePattern[sPattern] = aFormatArray;\n  return aFormatArray;\n};\n\n/**\n * Parse a date string relative to the current date.\n *\n * @param {string} sValue the string containing a formatted date/time value\n * @param {boolean} [bUTC] whether to use UTC, if no timezone is contained\n * @returns {Date|null} the parsed value or <code>null</code> if relative parsing not possible\n * @private\n */\nDateFormat.prototype.parseRelative = function (sValue, bUTC) {\n  var aPatterns, oEntry, rPattern, oResult, iValue;\n  if (!sValue) {\n    return null;\n  }\n  aPatterns = this.oLocaleData.getRelativePatterns(this.aRelativeParseScales, this.oFormatOptions.relativeStyle);\n  for (var i = 0; i < aPatterns.length; i++) {\n    oEntry = aPatterns[i];\n    rPattern = new RegExp(\"^\\\\s*\" + oEntry.pattern.replace(/\\{0\\}/, \"(\\\\d+)\") + \"\\\\s*$\", \"i\");\n    oResult = rPattern.exec(sValue);\n    if (oResult) {\n      if (oEntry.value !== undefined) {\n        return computeRelativeDate(oEntry.value, oEntry.scale);\n      } else {\n        iValue = parseInt(oResult[1]);\n        return computeRelativeDate(iValue * oEntry.sign, oEntry.scale);\n      }\n    }\n  }\n  function computeRelativeDate(iDiff, sScale) {\n    var oResult = UI5Date.getInstance();\n    if (bUTC) {\n      // date part and time part have to be set individually\n      oResult.setUTCFullYear(oResult.getFullYear(), oResult.getMonth(), oResult.getDate());\n      oResult.setUTCHours(oResult.getHours(), oResult.getMinutes(), oResult.getSeconds(), oResult.getMilliseconds());\n      // eslint-disable-next-line default-case\n      switch (sScale) {\n        case \"second\":\n          oResult.setUTCSeconds(oResult.getUTCSeconds() + iDiff);\n          break;\n        case \"minute\":\n          oResult.setUTCMinutes(oResult.getUTCMinutes() + iDiff);\n          break;\n        case \"hour\":\n          oResult.setUTCHours(oResult.getUTCHours() + iDiff);\n          break;\n        case \"day\":\n          oResult.setUTCDate(oResult.getUTCDate() + iDiff);\n          break;\n        case \"week\":\n          oResult.setUTCDate(oResult.getUTCDate() + iDiff * 7);\n          break;\n        case \"month\":\n          oResult.setUTCMonth(oResult.getUTCMonth() + iDiff);\n          break;\n        case \"quarter\":\n          oResult.setUTCMonth(oResult.getUTCMonth() + iDiff * 3);\n          break;\n        case \"year\":\n          oResult.setUTCFullYear(oResult.getUTCFullYear() + iDiff);\n          break;\n      }\n    } else {\n      // eslint-disable-next-line default-case\n      switch (sScale) {\n        case \"second\":\n          oResult.setSeconds(oResult.getSeconds() + iDiff);\n          break;\n        case \"minute\":\n          oResult.setMinutes(oResult.getMinutes() + iDiff);\n          break;\n        case \"hour\":\n          oResult.setHours(oResult.getHours() + iDiff);\n          break;\n        case \"day\":\n          oResult.setDate(oResult.getDate() + iDiff);\n          break;\n        case \"week\":\n          oResult.setDate(oResult.getDate() + iDiff * 7);\n          break;\n        case \"month\":\n          oResult.setMonth(oResult.getMonth() + iDiff);\n          break;\n        case \"quarter\":\n          oResult.setMonth(oResult.getMonth() + iDiff * 3);\n          break;\n        case \"year\":\n          oResult.setFullYear(oResult.getFullYear() + iDiff);\n          break;\n      }\n    }\n    return oResult;\n  }\n};\n\n/**\n * Format a date relative to the current date.\n *\n * @param {Date} oJSDate the value to format\n * @param {boolean} bUTC whether to use UTC\n * @param {number[]} aRange scale ranges\n * @param {string} sTimezone the IANA timezone ID\n * @returns {string|null} the formatted output value or <code>null</code> if relative formatting is not possible\n * @private\n */\nDateFormat.prototype.formatRelative = function (oJSDate, bUTC, aRange, sTimezone) {\n  var oDateUTC,\n    iDiff,\n    iDiffSeconds,\n    sPattern,\n    // no need to use UI5Date.getInstance as only the UTC timestamp is used\n    oToday = convertToTimezone(new Date(), sTimezone),\n    sScale = this.oFormatOptions.relativeScale || \"day\";\n  iDiffSeconds = (oJSDate.getTime() - oToday.getTime()) / 1000;\n  if (this.oFormatOptions.relativeScale === \"auto\") {\n    sScale = this._getScale(iDiffSeconds, this.aRelativeScales);\n    sScale = fixScaleForMonths(oJSDate, oToday, sScale, iDiffSeconds);\n  }\n  if (!aRange) {\n    aRange = this._mRanges[sScale];\n  }\n\n  // For dates normalize to UTC to avoid issues with summer-/wintertime\n  if (sScale === \"year\" || sScale === \"month\" || sScale === \"day\") {\n    // no need to use UI5Date.getInstance as only the UTC timestamp is used\n    oToday = new Date(Date.UTC(oToday.getUTCFullYear(), oToday.getUTCMonth(), oToday.getUTCDate()));\n\n    // no need to use UI5Date.getInstance as only the UTC timestamp is used\n    oDateUTC = new Date(0);\n\n    // The Date.UTC function doesn't accept years before 1900 (converts years before 100 into 1900 + years).\n    // Using setUTCFullYear to workaround this issue.\n    oDateUTC.setUTCFullYear(oJSDate.getUTCFullYear(), oJSDate.getUTCMonth(), oJSDate.getUTCDate());\n    oJSDate = oDateUTC;\n  }\n  iDiff = this._getDifference(sScale, [oToday, oJSDate]);\n  if (this.oFormatOptions.relativeScale !== \"auto\" && (iDiff < aRange[0] || iDiff > aRange[1])) {\n    //Relative parsing only in range +/- x days\n    return null;\n  }\n  sPattern = this.oLocaleData.getRelativePattern(sScale, iDiff, iDiffSeconds > 0, this.oFormatOptions.relativeStyle);\n  return formatMessage(sPattern, [Math.abs(iDiff)]);\n};\nDateFormat.prototype._mRanges = {\n  second: [-60, 60],\n  minute: [-60, 60],\n  hour: [-24, 24],\n  day: [-6, 6],\n  week: [-4, 4],\n  month: [-12, 12],\n  year: [-10, 10]\n};\nDateFormat.prototype._mScales = {\n  second: 1,\n  // 1\n  minute: 60,\n  // 60\n  hour: 3600,\n  // 60*60\n  day: 86400,\n  // 60*60*24         1 day\n  week: 604800,\n  // 60*60*24*7       7 days\n  month: 2592000,\n  // 60*60*24*30      30 days\n  quarter: 7776000,\n  // 60*60*24*30*3    90 days\n  year: 31536000 // 60*60*24*365     365 days\n};\nDateFormat.prototype._getScale = function (iDiffSeconds, aScales) {\n  // Determines the correct time scale\n  var sScale, sTestScale;\n  iDiffSeconds = Math.abs(iDiffSeconds);\n  for (var i = 0; i < aScales.length; i++) {\n    sTestScale = aScales[i];\n    if (iDiffSeconds >= this._mScales[sTestScale]) {\n      sScale = sTestScale;\n      break;\n    }\n  }\n  if (!sScale) {\n    sScale = aScales[aScales.length - 1];\n  }\n  return sScale;\n};\n\n// Fixes the scale for months/weeks\n// when involved months do not have 30 days\nfunction fixScaleForMonths(oJSDate, oToday, sScale, iDiffSeconds) {\n  var iMonthDiff = Math.abs(oJSDate.getUTCMonth() - oToday.getUTCMonth());\n  if (sScale === \"week\" && iMonthDiff === 2) {\n    // 2 months diff\n    // e.g. March 1st - Jan 31st\n    return \"month\";\n  } else if (sScale === \"week\" && iMonthDiff === 1) {\n    // same day but different month\n    // e.g. March 1st - Feb 1st\n    if (oJSDate.getUTCDate() === oToday.getUTCDate()\n    // future date\n    // e.g. Feb 14th - 15. Mar 15th (29/30 days diff) => 1 month\n    || iDiffSeconds < 0 && oJSDate.getUTCDate() < oToday.getUTCDate()\n    // past date\n    // e.g. Mar 15th - Feb 14th (29/30 days diff) => 1 month\n    || iDiffSeconds > 0 && oJSDate.getUTCDate() > oToday.getUTCDate()) {\n      return \"month\";\n    }\n  } else if (sScale === \"month\" && iMonthDiff === 1) {\n    // future date\n    // e.g. Mar 14th - Apr 13th (30 days diff)\n    if (iDiffSeconds > 0 && oJSDate.getUTCDate() < oToday.getUTCDate()\n    // past date\n    // Feb 14th - Jan 15th (30 days diff)\n    || iDiffSeconds < 0 && oJSDate.getUTCDate() > oToday.getUTCDate()) {\n      return \"week\";\n    }\n  }\n  return sScale;\n}\n\n/**\n * Modifies the Date and sets the values with a higher index to <code>0</code>\n *\n * @param {Date} oDate input date\n * @param {number} iStartIndex index of the value to set to <code>0</code>. Higher indices will also be set to <code>0</code>.\n * 0: FullYear\n * 1: Month\n * 2: Date\n * 3: Hours\n * 4: Minutes\n * 5: Seconds\n * 6: Milliseconds\n * e.g. iStartIndex <code>4</code> will set Minutes, Seconds and Milliseconds to <code>0</code>\n * @returns {Date} copy of the date with the modified values\n */\nfunction cutDateFields(oDate, iStartIndex) {\n  var sMethodName,\n    aFields = [\"FullYear\", \"Month\", \"Date\", \"Hours\", \"Minutes\", \"Seconds\", \"Milliseconds\"],\n    // no need to use UI5Date.getInstance as only the UTC timestamp is used\n    oDateCopy = new Date(oDate.getTime());\n  for (var i = iStartIndex; i < aFields.length; i++) {\n    sMethodName = \"setUTC\" + aFields[iStartIndex];\n    oDateCopy[sMethodName].apply(oDateCopy, [0]);\n  }\n  return oDateCopy;\n}\nvar mRelativeDiffs = {\n  year: function (oFromDate, oToDate) {\n    return oToDate.getUTCFullYear() - oFromDate.getUTCFullYear();\n  },\n  month: function (oFromDate, oToDate) {\n    return oToDate.getUTCMonth() - oFromDate.getUTCMonth() + this.year(oFromDate, oToDate) * 12;\n  },\n  week: function (oFromDate, oToDate, oFormat) {\n    var iFromDay = oFormat._adaptDayOfWeek(oFromDate.getUTCDay());\n    var iToDay = oFormat._adaptDayOfWeek(oToDate.getUTCDay());\n    oFromDate = cutDateFields(oFromDate, 3);\n    oToDate = cutDateFields(oToDate, 3);\n    return (oToDate.getTime() - oFromDate.getTime() - (iToDay - iFromDay) * oFormat._mScales.day * 1000) / (oFormat._mScales.week * 1000);\n  },\n  day: function (oFromDate, oToDate, oFormat) {\n    oFromDate = cutDateFields(oFromDate, 3);\n    oToDate = cutDateFields(oToDate, 3);\n    return (oToDate.getTime() - oFromDate.getTime()) / (oFormat._mScales.day * 1000);\n  },\n  hour: function (oFromDate, oToDate, oFormat) {\n    oFromDate = cutDateFields(oFromDate, 4);\n    oToDate = cutDateFields(oToDate, 4);\n    return (oToDate.getTime() - oFromDate.getTime()) / (oFormat._mScales.hour * 1000);\n  },\n  minute: function (oFromDate, oToDate, oFormat) {\n    oFromDate = cutDateFields(oFromDate, 5);\n    oToDate = cutDateFields(oToDate, 5);\n    return (oToDate.getTime() - oFromDate.getTime()) / (oFormat._mScales.minute * 1000);\n  },\n  second: function (oFromDate, oToDate, oFormat) {\n    oFromDate = cutDateFields(oFromDate, 6);\n    oToDate = cutDateFields(oToDate, 6);\n    return (oToDate.getTime() - oFromDate.getTime()) / (oFormat._mScales.second * 1000);\n  }\n};\nDateFormat.prototype._adaptDayOfWeek = function (iDayOfWeek) {\n  // day of week depends on the format locale\n  // the DateFormat's locale is independent\n  var vCalendarWeekParameter = getCalendarWeekParameter(this.oFormatOptions),\n    iFirstDayOfWeek;\n  if (typeof vCalendarWeekParameter === \"object\") {\n    iFirstDayOfWeek = vCalendarWeekParameter.firstDayOfWeek;\n  } else {\n    iFirstDayOfWeek = CalendarUtils.getWeekConfigurationValues(vCalendarWeekParameter, this.oLocale).firstDayOfWeek;\n  }\n  var iDayNumberOfWeek = iDayOfWeek - (iFirstDayOfWeek - 1);\n  if (iDayNumberOfWeek <= 0) {\n    iDayNumberOfWeek += 7;\n  }\n  return iDayNumberOfWeek;\n};\nDateFormat.prototype._getDifference = function (sScale, aDates) {\n  var oFromDate = aDates[0];\n  var oToDate = aDates[1];\n  return Math.round(mRelativeDiffs[sScale](oFromDate, oToDate, this));\n};\nDateFormat.prototype.getAllowedCharacters = function (aFormatArray) {\n  if (this.oFormatOptions.relative) {\n    return \"\"; //Allow all\n  }\n  var sAllowedCharacters = \"\";\n  var bNumbers = false;\n  var bAll = false;\n  var oPart;\n  for (var i = 0; i < aFormatArray.length; i++) {\n    oPart = aFormatArray[i];\n    switch (oPart.type) {\n      case \"text\":\n        if (sAllowedCharacters.indexOf(oPart.value) < 0) {\n          sAllowedCharacters += oPart.value;\n        }\n        break;\n      case \"day\":\n      case \"year\":\n      case \"weekYear\":\n      case \"dayNumberOfWeek\":\n      case \"weekInYear\":\n      case \"hour0_23\":\n      case \"hour1_24\":\n      case \"hour0_11\":\n      case \"hour1_12\":\n      case \"minute\":\n      case \"second\":\n      case \"fractionalsecond\":\n        if (!bNumbers) {\n          sAllowedCharacters += \"0123456789\";\n          bNumbers = true;\n        }\n        break;\n      case \"month\":\n      case \"monthStandalone\":\n        if (oPart.digits < 3) {\n          if (!bNumbers) {\n            sAllowedCharacters += \"0123456789\";\n            bNumbers = true;\n          }\n        } else {\n          bAll = true;\n        }\n        break;\n      default:\n        bAll = true;\n        break;\n    }\n  }\n  if (bAll) {\n    sAllowedCharacters = \"\";\n  }\n  return sAllowedCharacters;\n};\n\n/**\n * Returns a language-dependent placeholder text according to this instance's format options, for example\n * \"e.g. 12/31/2023\".\n *\n * @returns {string} The language-dependent placeholder text\n *\n * @private\n * @ui5-restricted sap.m\n */\nDateFormat.prototype.getPlaceholderText = function () {\n  var oResourceBundle = Core.getLibraryResourceBundle();\n  return oResourceBundle.getText(\"date.placeholder\", [this.format.apply(this, this.getSampleValue())]);\n};\n\n/**\n * Returns a sample date value.\n *\n * @returns {array}\n *   A sample date value as an array of parameter values as expected by {@link #format}\n *\n * @private\n */\nDateFormat.prototype.getSampleValue = function () {\n  var oDate,\n    iFullYear = UI5Date.getInstance().getFullYear(),\n    bUTC = this.oFormatOptions.UTC;\n  function getDate(iYear, iMonth, iDay, iHours, iMinutes, iSeconds, iMilliseconds) {\n    return bUTC ? UI5Date.getInstance(Date.UTC(iYear, iMonth, iDay, iHours, iMinutes, iSeconds, iMilliseconds)) : UI5Date.getInstance(iYear, iMonth, iDay, iHours, iMinutes, iSeconds, iMilliseconds);\n  }\n  oDate = getDate(iFullYear, 11, 31, 23, 59, 58, 123);\n  if (this.type === mDateFormatTypes.DATETIME_WITH_TIMEZONE) {\n    return [oDate, Configuration.getTimezone()];\n  }\n  if (this.oFormatOptions.interval) {\n    return [[getDate(iFullYear, 11, 22, 9, 12, 34, 567), oDate]];\n  }\n  return [oDate];\n};\nconst rAllRTLCharacters = /[\\u200e\\u200f\\u202a\\u202b\\u202c]/g;\nconst rAllSpaces = /\\s/g;\n\n/**\n * Normalizes the given string by removing RTL characters and replacing special space characters\n * by the standard ASCII space (\\u0020).\n *\n * @param {string} sValue The value to be normalized\n * @return {string} The normalized value\n */\nDateFormat._normalize = function (sValue) {\n  return sValue.replace(rAllRTLCharacters, \"\").replace(rAllSpaces, \" \");\n};\nexport default DateFormat;"],"mappings":"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AACvB,aAAa,CAAC;AACzE,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAhC,UAAU,CAAC2D,+BAA+B,GAAG,UAAUrB,cAAc,EAAEiB,OAAO,EAAE;EAC9E,IAAIjB,cAAc,IAAI,EAAEA,cAAc,YAAY9C,MAAM,CAAC,EAAE;IACzD;IACA,CAAC,YAAY;MACX;MACA8C,cAAc,GAAGU,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEX,cAAc,CAAC;MAClD;MACA,IAAI,OAAOA,cAAc,CAACO,YAAY,KAAK,QAAQ,EAAE;QACnD,IAAIe,aAAa,GAAGtB,cAAc,CAACO,YAAY;QAC/C,IAAIP,cAAc,CAACE,QAAQ,KAAKC,SAAS,IAAIH,cAAc,CAACK,QAAQ,KAAKF,SAAS,EAAE;UAClF,IAAImB,aAAa,KAAK,MAAM,EAAE;YAC5BtB,cAAc,CAACO,YAAY,GAAG,KAAK;UACrC,CAAC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AAO,KAAK;IACd;IACA,OAAO,IAAI;EACb;AACF,CAAC;AACD3M,UAAU,CAAC4M,aAAa,GAAGtC,YAAY,CAAC,CAAC;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAtK,UAAU,CAAC6M,oBAAoB,GAAG,UAAUC,WAAW,EAAE;EACvD,IAAIC,WAAW,GAAG,OAAOD,WAAW,CAACE,SAAS,KAAK,UAAU,IAAIF,WAAW,CAACE;EAC7E;EAAA,GACG,YAAY;IACb,OAAOF,WAAW,CAACE,SAAS,IAAI,KAAK;EACvC,CAAC;EACD,OAAO;IACLC,IAAI,EAAEH,WAAW,CAACG,IAAI;IACtB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIlI,MAAM,EAAE+H,WAAW,CAAC/H;IACpB;IAAA,GACG,YAAY;MACb,OAAO,EAAE;IACX,CAAC;IACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACImI,KAAK,EAAEJ,WAAW,CAACI;IACnB;IAAA,GACG,YAAY;MACb,OAAO,CAAC,CAAC;IACX,CAAC;IACD;AACJ;AACA;AACA;AACA;AACA;IACIF,SAAS,EAAED;EACb,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA/M,UAAU,CAACkE,SAAS,CAACiJ,QAAQ,GAAG;EAC9B,EAAE,EAAEnN,UAAU,CAAC6M,oBAAoB,CAAC;IAClCI,IAAI,EAAE,MAAM;IACZlI,MAAM,EAAE,SAAAA,CAAUqI,MAAM,EAAEC,KAAK,EAAE;MAC/B,OAAOD,MAAM,CAACE,KAAK;IACrB,CAAC;IACDJ,KAAK,EAAE,SAAAA,CAAUxC,MAAM,EAAE6C,KAAK,EAAEvJ,OAAO,EAAEwJ,OAAO,EAAE;MAChD,IAAIC,KAAK;MACT,IAAIC,MAAM,GAAG,IAAI;MACjB,IAAIC,WAAW,GAAG,CAAC;MACnB,IAAIC,aAAa,GAAG,CAAC;MACrB;MACA,IAAI1I,UAAU,GAAG,oEAAoE;;MAErF;MACA;MACA;MACA;MACA;MACA,MAAM2I,UAAU,GAAG7N,UAAU,CAAC8N,UAAU,CAACP,KAAK,CAACD,KAAK,CAAC;MACrD,OAAOM,aAAa,GAAGC,UAAU,CAACtH,MAAM,EAAEqH,aAAa,EAAE,EAAE;QACzDH,KAAK,GAAGI,UAAU,CAAC1B,MAAM,CAACyB,aAAa,CAAC;QACxC,IAAIH,KAAK,KAAK,GAAG,EAAE;UACjB;UACA,OAAO/C,MAAM,CAACyB,MAAM,CAACwB,WAAW,CAAC,KAAK,GAAG,EAAE;YACzCA,WAAW,EAAE;UACf;QACF,CAAC,MAAM,IAAIzI,UAAU,CAACJ,QAAQ,CAAC2I,KAAK,CAAC,EAAE;UACrC,IAAI,CAACvI,UAAU,CAACJ,QAAQ,CAAC4F,MAAM,CAACyB,MAAM,CAACwB,WAAW,CAAC,CAAC,EAAE;YACpDD,MAAM,GAAG,KAAK;UAChB;UACAC,WAAW,EAAE;QACf,CAAC,MAAM;UACL,IAAIjD,MAAM,CAACyB,MAAM,CAACwB,WAAW,CAAC,KAAKF,KAAK,EAAE;YACxC;YACAC,MAAM,GAAG,KAAK;UAChB;UACAC,WAAW,EAAE;QACf;QACA,IAAI,CAACD,MAAM,EAAE;UACX;QACF;MACF;MACA,IAAIA,MAAM,EAAE;QACV,OAAO;UACLnH,MAAM,EAAEoH;QACV,CAAC;MACH,CAAC,MAAM;QACL,IAAIhB,YAAY,GAAG,KAAK;;QAExB;QACA,IAAIa,OAAO,CAACzB,KAAK,GAAGyB,OAAO,CAACO,WAAW,CAACxH,MAAM,GAAG,CAAC,EAAE;UAClDoG,YAAY,GAAGa,OAAO,CAACO,WAAW,CAACP,OAAO,CAACzB,KAAK,GAAG,CAAC,CAAC,CAAClL,IAAI,IAAImD,OAAO,CAACpC,cAAc;QACtF;QACA,OAAO;UACLoM,KAAK,EAAE1D,YAAY,CAACmC,UAAU,CAACc,KAAK,CAAC1M,IAAI,EAAE8L,YAAY,EAAE3I,OAAO;QAClE,CAAC;MACH;IACF;EACF,CAAC,CAAC;EACF,GAAG,EAAEhE,UAAU,CAAC6M,oBAAoB,CAAC;IACnCI,IAAI,EAAE,KAAK;IACXlI,MAAM,EAAE,SAAAA,CAAUqI,MAAM,EAAEC,KAAK,EAAEY,IAAI,EAAEjK,OAAO,EAAE;MAC9C,IAAIkK,IAAI,GAAGb,KAAK,CAACc,SAAS,CAAC,CAAC;MAC5B,IAAIf,MAAM,CAACgB,MAAM,IAAI,CAAC,EAAE;QACtB,OAAOpK,OAAO,CAAC2E,WAAW,CAACuF,IAAI,CAAC;MAClC,CAAC,MAAM,IAAId,MAAM,CAACgB,MAAM,KAAK,CAAC,EAAE;QAC9B,OAAOpK,OAAO,CAAC4E,SAAS,CAACsF,IAAI,CAAC;MAChC,CAAC,MAAM;QACL,OAAOlK,OAAO,CAACyE,WAAW,CAACyF,IAAI,CAAC;MAClC;IACF,CAAC;IACDhB,KAAK,EAAE,SAAAA,CAAUxC,MAAM,EAAE6C,KAAK,EAAEvJ,OAAO,EAAEwJ,OAAO,EAAE;MAChD,IAAIa,aAAa,GAAG,CAACrK,OAAO,CAAC4E,SAAS,EAAE5E,OAAO,CAAC2E,WAAW,EAAE3E,OAAO,CAACyE,WAAW,CAAC;MACjF,KAAK,IAAI6F,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,aAAa,CAAC9H,MAAM,EAAE+H,CAAC,EAAE,EAAE;QAC7C,IAAIC,SAAS,GAAGF,aAAa,CAACC,CAAC,CAAC;QAChC,IAAIE,MAAM,GAAGlE,YAAY,CAACgB,SAAS,CAACZ,MAAM,EAAE6D,SAAS,EAAEvK,OAAO,CAACxC,WAAW,CAACiN,aAAa,CAAC;QACzF,IAAID,MAAM,CAACzC,KAAK,KAAK,CAAC,CAAC,EAAE;UACvB,OAAO;YACL2C,GAAG,EAAEF,MAAM,CAACzC,KAAK;YACjBxF,MAAM,EAAEiI,MAAM,CAACjI;UACjB,CAAC;QACH;MACF;MACA,OAAO;QACLmI,GAAG,EAAE1K,OAAO,CAAC4E,SAAS,CAACrC,MAAM,GAAG,CAAC;QACjCyH,KAAK,EAAE1D,YAAY,CAACmC,UAAU,CAACc,KAAK,CAAC1M,IAAI,EAAE,IAAI,EAAEmD,OAAO;MAC1D,CAAC;IACH;EACF,CAAC,CAAC;EACF,GAAG,EAAEhE,UAAU,CAAC6M,oBAAoB,CAAC;IACnCI,IAAI,EAAE,MAAM;IACZlI,MAAM,EAAE,SAAAA,CAAUqI,MAAM,EAAEC,KAAK,EAAEY,IAAI,EAAEjK,OAAO,EAAE;MAC9C,IAAI2K,KAAK,GAAGtB,KAAK,CAACuB,cAAc,CAAC,CAAC;MAClC,IAAIC,KAAK,GAAGnO,MAAM,CAACiO,KAAK,CAAC;MACzB,IAAIjN,aAAa,GAAGsC,OAAO,CAAC1B,cAAc,CAACkC,YAAY;MACvD,IAAI4I,MAAM,CAACgB,MAAM,KAAK,CAAC,IAAIS,KAAK,CAACtI,MAAM,GAAG,CAAC,EAAE;QAC3CsI,KAAK,GAAGA,KAAK,CAACzM,MAAM,CAACyM,KAAK,CAACtI,MAAM,GAAG,CAAC,CAAC;MACxC;MACA;MACA;MACA,IAAI7E,aAAa,KAAKrC,YAAY,CAACyP,QAAQ,IAAI1B,MAAM,CAACgB,MAAM,KAAK,CAAC,IAAIO,KAAK,GAAG,GAAG,EAAE;QACjFE,KAAK,GAAGA,KAAK,CAACE,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC;MAChC;MACA,OAAOF,KAAK,CAACE,QAAQ,CAAC3B,MAAM,CAACgB,MAAM,EAAE,GAAG,CAAC;IAC3C,CAAC;IACDlB,KAAK,EAAE,SAAAA,CAAUxC,MAAM,EAAE6C,KAAK,EAAEvJ,OAAO,EAAEwJ,OAAO,EAAE;MAChD,IAAIwB,eAAe;QACjB5C,KAAK;QACLO,YAAY;QACZjL,aAAa,GAAGsC,OAAO,CAAC1B,cAAc,CAACkC,YAAY;MACrD,IAAI+I,KAAK,CAACa,MAAM,KAAK,CAAC,EAAE;QACtBY,eAAe,GAAG,CAAC;MACrB,CAAC,MAAM,IAAIzB,KAAK,CAACa,MAAM,KAAK,CAAC,EAAE;QAC7BY,eAAe,GAAG,CAAC;MACrB,CAAC,MAAM;QACLA,eAAe,GAAGzB,KAAK,CAACa,MAAM;MAChC;MACAhC,KAAK,GAAG9B,YAAY,CAACG,WAAW,CAACC,MAAM,EAAEsE,eAAe,CAAC;MACzDrC,YAAY,GAAGP,KAAK,KAAK,EAAE,IAAIoB,OAAO,CAACyB,WAAW,IAAI7C,KAAK,CAAC7F,MAAM,KAAKyI,eAAe;MACtF,IAAIL,KAAK,GAAGpC,QAAQ,CAACH,KAAK,CAAC;MAC3B;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;;MAEA;MACA;MACA;;MAEA;MACA;MACA;MACA,IAAI1K,aAAa,KAAKrC,YAAY,CAACyP,QAAQ,IAAI1C,KAAK,CAAC7F,MAAM,IAAI,CAAC,EAAE;QAChE,IAAI2I,YAAY,GAAGpP,aAAa,CAACwD,WAAW,CAACzD,OAAO,CAACyD,WAAW,CAAC,CAAC,EAAE5B,aAAa,CAAC;UAChFyN,YAAY,GAAGD,YAAY,CAACN,cAAc,CAAC,CAAC;UAC5CQ,eAAe,GAAGC,IAAI,CAACC,KAAK,CAACH,YAAY,GAAG,GAAG,CAAC;UAChDI,SAAS,GAAGH,eAAe,GAAG,GAAG,GAAGT,KAAK,GAAGQ,YAAY;QAC1D,IAAII,SAAS,GAAG,CAAC,EAAE,EAAE;UACnBZ,KAAK,IAAI,CAACS,eAAe,GAAG,CAAC,IAAI,GAAG;QACtC,CAAC,MAAM,IAAIG,SAAS,GAAG,EAAE,EAAE;UACzBZ,KAAK,IAAIS,eAAe,GAAG,GAAG;QAChC,CAAC,MAAM;UACLT,KAAK,IAAI,CAACS,eAAe,GAAG,CAAC,IAAI,GAAG;QACtC;MACF;MACA,OAAO;QACL7I,MAAM,EAAE6F,KAAK,CAAC7F,MAAM;QACpByH,KAAK,EAAE1D,YAAY,CAACmC,UAAU,CAACc,KAAK,CAAC1M,IAAI,EAAE8L,YAAY,EAAE3I,OAAO,CAAC;QACjEwL,IAAI,EAAEb;MACR,CAAC;IACH,CAAC;IACD3B,SAAS,EAAE;EACb,CAAC,CAAC;EACF,GAAG,EAAEhN,UAAU,CAAC6M,oBAAoB,CAAC;IACnCI,IAAI,EAAE,UAAU;IAChBlI,MAAM,EAAE,SAAAA,CAAUqI,MAAM,EAAEC,KAAK,EAAEY,IAAI,EAAEjK,OAAO,EAAE;MAC9C,IAAIyL,KAAK,GAAGpC,KAAK,CAACqC,UAAU,CAAC1L,OAAO,CAACT,OAAO,EAAEoM,wBAAwB,CAAC3L,OAAO,CAAC1B,cAAc,CAAC,CAAC;MAC/F,IAAIsN,SAAS,GAAGH,KAAK,CAACD,IAAI;MAC1B,IAAIK,SAAS,GAAGnP,MAAM,CAACkP,SAAS,CAAC;MACjC,IAAIlO,aAAa,GAAGsC,OAAO,CAAC1B,cAAc,CAACkC,YAAY;MACvD,IAAI4I,MAAM,CAACgB,MAAM,KAAK,CAAC,IAAIyB,SAAS,CAACtJ,MAAM,GAAG,CAAC,EAAE;QAC/CsJ,SAAS,GAAGA,SAAS,CAACzN,MAAM,CAACyN,SAAS,CAACtJ,MAAM,GAAG,CAAC,CAAC;MACpD;MACA;MACA;MACA,IAAI7E,aAAa,KAAKrC,YAAY,CAACyP,QAAQ,IAAI1B,MAAM,CAACgB,MAAM,KAAK,CAAC,IAAIwB,SAAS,GAAG,GAAG,EAAE;QACrFC,SAAS,GAAGA,SAAS,CAACd,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC;MACxC;MACA,OAAOc,SAAS,CAACd,QAAQ,CAAC3B,MAAM,CAACgB,MAAM,EAAE,GAAG,CAAC;IAC/C,CAAC;IACDlB,KAAK,EAAE,SAAAA,CAAUxC,MAAM,EAAE6C,KAAK,EAAEvJ,OAAO,EAAEwJ,OAAO,EAAE;MAChD,IAAIwB,eAAe;QACjB5C,KAAK;QACLO,YAAY;QACZjL,aAAa,GAAGsC,OAAO,CAAC1B,cAAc,CAACkC,YAAY;MACrD,IAAI+I,KAAK,CAACa,MAAM,KAAK,CAAC,EAAE;QACtBY,eAAe,GAAG,CAAC;MACrB,CAAC,MAAM,IAAIzB,KAAK,CAACa,MAAM,KAAK,CAAC,EAAE;QAC7BY,eAAe,GAAG,CAAC;MACrB,CAAC,MAAM;QACLA,eAAe,GAAGzB,KAAK,CAACa,MAAM;MAChC;MACAhC,KAAK,GAAG9B,YAAY,CAACG,WAAW,CAACC,MAAM,EAAEsE,eAAe,CAAC;MACzDrC,YAAY,GAAGP,KAAK,KAAK,EAAE,IAAIoB,OAAO,CAACyB,WAAW,IAAI7C,KAAK,CAAC7F,MAAM,KAAKyI,eAAe;MACtF,IAAIL,KAAK,GAAGpC,QAAQ,CAACH,KAAK,CAAC;MAC3B,IAAIwD,SAAS,GAAGjB,KAAK;MACrB;MACA,IAAIjN,aAAa,KAAKrC,YAAY,CAACyP,QAAQ,IAAI1C,KAAK,CAAC7F,MAAM,IAAI,CAAC,EAAE;QAChE,IAAI2I,YAAY,GAAGpP,aAAa,CAACwD,WAAW,CAACzD,OAAO,CAACyD,WAAW,CAAC,CAAC,EAAE5B,aAAa,CAAC;UAChFyN,YAAY,GAAGD,YAAY,CAACN,cAAc,CAAC,CAAC;UAC5CQ,eAAe,GAAGC,IAAI,CAACC,KAAK,CAACH,YAAY,GAAG,GAAG,CAAC;UAChDI,SAAS,GAAGH,eAAe,GAAG,GAAG,GAAGQ,SAAS,GAAGT,YAAY;QAC9D,IAAII,SAAS,GAAG,CAAC,EAAE,EAAE;UACnBK,SAAS,IAAI,CAACR,eAAe,GAAG,CAAC,IAAI,GAAG;QAC1C,CAAC,MAAM,IAAIG,SAAS,GAAG,EAAE,EAAE;UACzBK,SAAS,IAAIR,eAAe,GAAG,GAAG;QACpC,CAAC,MAAM;UACLQ,SAAS,IAAI,CAACR,eAAe,GAAG,CAAC,IAAI,GAAG;QAC1C;MACF;MACA,OAAO;QACL7I,MAAM,EAAE6F,KAAK,CAAC7F,MAAM;QACpByH,KAAK,EAAE1D,YAAY,CAACmC,UAAU,CAACc,KAAK,CAAC1M,IAAI,EAAE8L,YAAY,EAAE3I,OAAO,CAAC;QACjEwL,IAAI,EAAEb,KAAK;QACXmB,QAAQ,EAAEF;MACZ,CAAC;IACH,CAAC;IACD5C,SAAS,EAAE;EACb,CAAC,CAAC;EACF,GAAG,EAAEhN,UAAU,CAAC6M,oBAAoB,CAAC;IACnCI,IAAI,EAAE,OAAO;IACblI,MAAM,EAAE,SAAAA,CAAUqI,MAAM,EAAEC,KAAK,EAAEY,IAAI,EAAEjK,OAAO,EAAE;MAC9C,IAAI+L,MAAM,GAAG1C,KAAK,CAAC2C,WAAW,CAAC,CAAC;MAChC,IAAI5C,MAAM,CAACgB,MAAM,KAAK,CAAC,EAAE;QACvB,MAAM6B,KAAK,GAAGjM,OAAO,CAAC6C,aAAa,CAACkJ,MAAM,CAAC,CAAC,CAAC;QAC7C,OAAOrK,KAAK,CAACmG,OAAO,CAACoE,KAAK,CAAC,GAAGA,KAAK,CAAC,CAAC,CAAC,GAAGA,KAAK;MAChD,CAAC,MAAM,IAAI7C,MAAM,CAACgB,MAAM,KAAK,CAAC,EAAE;QAC9B,OAAOpK,OAAO,CAAC+C,WAAW,CAACgJ,MAAM,CAAC;MACpC,CAAC,MAAM,IAAI3C,MAAM,CAACgB,MAAM,GAAG,CAAC,EAAE;QAC5B,OAAOpK,OAAO,CAACiD,aAAa,CAAC8I,MAAM,CAAC;MACtC,CAAC,MAAM;QACL,OAAOrP,MAAM,CAACqP,MAAM,GAAG,CAAC,CAAC,CAAChB,QAAQ,CAAC3B,MAAM,CAACgB,MAAM,EAAE,GAAG,CAAC;MACxD;IACF,CAAC;IACDlB,KAAK,EAAE,SAAAA,CAAUxC,MAAM,EAAE6C,KAAK,EAAEvJ,OAAO,EAAEwJ,OAAO,EAAE;MAChD,IAAIuC,MAAM;QACR3D,KAAK;QACLO,YAAY;QACZe,MAAM;QACNwC,eAAe,GAAG,CAAClM,OAAO,CAAC+C,WAAW,EAAE/C,OAAO,CAACoD,aAAa,EAAEpD,OAAO,CAAC6C,aAAa,EAAE7C,OAAO,CAACkD,eAAe,EAAElD,OAAO,CAACiD,aAAa,EAAEjD,OAAO,CAACsD,eAAe,CAAC;MAChK,IAAIiG,KAAK,CAACa,MAAM,GAAG,CAAC,EAAE;QACpBhC,KAAK,GAAG9B,YAAY,CAACG,WAAW,CAACC,MAAM,EAAE2E,IAAI,CAACc,GAAG,CAAC5C,KAAK,CAACa,MAAM,EAAE,CAAC,CAAC,CAAC;QACnEzB,YAAY,GAAGP,KAAK,KAAK,EAAE,IAAIoB,OAAO,CAACyB,WAAW,IAAI7C,KAAK,CAAC7F,MAAM,GAAG,CAAC;QACtEmH,MAAM,GAAGpD,YAAY,CAACmC,UAAU,CAACc,KAAK,CAAC1M,IAAI,EAAE8L,YAAY,EAAE3I,OAAO,CAAC;QACnE+L,MAAM,GAAGxD,QAAQ,CAACH,KAAK,CAAC,GAAG,CAAC;QAC5B,IAAIoB,OAAO,CAAC4C,MAAM,KAAKL,MAAM,GAAG,EAAE,IAAIA,MAAM,GAAG,CAAC,CAAC,EAAE;UACjDrC,MAAM,GAAG,KAAK;QAChB;MACF,CAAC,MAAM;QACL,KAAK,IAAIY,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4B,eAAe,CAAC3J,MAAM,EAAE+H,CAAC,EAAE,EAAE;UAC/C,IAAIC,SAAS,GAAG2B,eAAe,CAAC5B,CAAC,CAAC;UAClC,IAAIE,MAAM,GAAGlE,YAAY,CAACgB,SAAS,CAACZ,MAAM,EAAE6D,SAAS,EAAEvK,OAAO,CAACxC,WAAW,CAACiN,aAAa,CAAC;UACzF,IAAID,MAAM,CAACzC,KAAK,KAAK,CAAC,CAAC,EAAE;YACvB,OAAO;cACLsE,KAAK,EAAE7B,MAAM,CAACzC,KAAK;cACnBxF,MAAM,EAAEiI,MAAM,CAACjI;YACjB,CAAC;UACH;QACF;QACAmH,MAAM,GAAGpD,YAAY,CAACmC,UAAU,CAACc,KAAK,CAAC1M,IAAI,EAAE,IAAI,EAAEmD,OAAO,CAAC;MAC7D;MACA,OAAO;QACLqM,KAAK,EAAEN,MAAM;QACbxJ,MAAM,EAAE6F,KAAK,GAAGA,KAAK,CAAC7F,MAAM,GAAG,CAAC;QAChCyH,KAAK,EAAEN;MACT,CAAC;IACH,CAAC;IACDV,SAAS,EAAE,SAAAA,CAAUsD,OAAO,EAAE;MAC5B,OAAOA,OAAO,GAAG,CAAC;IACpB;EACF,CAAC,CAAC;EACF,GAAG,EAAEtQ,UAAU,CAAC6M,oBAAoB,CAAC;IACnCI,IAAI,EAAE,iBAAiB;IACvBlI,MAAM,EAAE,SAAAA,CAAUqI,MAAM,EAAEC,KAAK,EAAEY,IAAI,EAAEjK,OAAO,EAAE;MAC9C,IAAI+L,MAAM,GAAG1C,KAAK,CAAC2C,WAAW,CAAC,CAAC;MAChC,IAAI5C,MAAM,CAACgB,MAAM,KAAK,CAAC,EAAE;QACvB,MAAM6B,KAAK,GAAGjM,OAAO,CAACkD,eAAe,CAAC6I,MAAM,CAAC,CAAC,CAAC;QAC/C,OAAOrK,KAAK,CAACmG,OAAO,CAACoE,KAAK,CAAC,GAAGA,KAAK,CAAC,CAAC,CAAC,GAAGA,KAAK;MAChD,CAAC,MAAM,IAAI7C,MAAM,CAACgB,MAAM,KAAK,CAAC,EAAE;QAC9B,OAAOpK,OAAO,CAACoD,aAAa,CAAC2I,MAAM,CAAC;MACtC,CAAC,MAAM,IAAI3C,MAAM,CAACgB,MAAM,GAAG,CAAC,EAAE;QAC5B,OAAOpK,OAAO,CAACsD,eAAe,CAACyI,MAAM,CAAC;MACxC,CAAC,MAAM;QACL,OAAOrP,MAAM,CAACqP,MAAM,GAAG,CAAC,CAAC,CAAChB,QAAQ,CAAC3B,MAAM,CAACgB,MAAM,EAAE,GAAG,CAAC;MACxD;IACF,CAAC;IACDlB,KAAK,EAAE,SAAAA,CAAUxC,MAAM,EAAE6C,KAAK,EAAEvJ,OAAO,EAAEwJ,OAAO,EAAE;MAChD,IAAIuC,MAAM;QACR3D,KAAK;QACLO,YAAY;QACZe,MAAM;QACNwC,eAAe,GAAG,CAAClM,OAAO,CAAC+C,WAAW,EAAE/C,OAAO,CAACoD,aAAa,EAAEpD,OAAO,CAAC6C,aAAa,EAAE7C,OAAO,CAACkD,eAAe,EAAElD,OAAO,CAACiD,aAAa,EAAEjD,OAAO,CAACsD,eAAe,CAAC;MAChK,IAAIiG,KAAK,CAACa,MAAM,GAAG,CAAC,EAAE;QACpBhC,KAAK,GAAG9B,YAAY,CAACG,WAAW,CAACC,MAAM,EAAE2E,IAAI,CAACc,GAAG,CAAC5C,KAAK,CAACa,MAAM,EAAE,CAAC,CAAC,CAAC;QACnEzB,YAAY,GAAGP,KAAK,KAAK,EAAE,IAAIoB,OAAO,CAACyB,WAAW,IAAI7C,KAAK,CAAC7F,MAAM,GAAG,CAAC;QACtEmH,MAAM,GAAGpD,YAAY,CAACmC,UAAU,CAACc,KAAK,CAAC1M,IAAI,EAAE8L,YAAY,EAAE3I,OAAO,CAAC;QACnE+L,MAAM,GAAGxD,QAAQ,CAACH,KAAK,CAAC,GAAG,CAAC;QAC5B,IAAIoB,OAAO,CAAC4C,MAAM,KAAKL,MAAM,GAAG,EAAE,IAAIA,MAAM,GAAG,CAAC,CAAC,EAAE;UACjDrC,MAAM,GAAG,KAAK;QAChB;MACF,CAAC,MAAM;QACL,KAAK,IAAIY,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4B,eAAe,CAAC3J,MAAM,EAAE+H,CAAC,EAAE,EAAE;UAC/C,IAAIC,SAAS,GAAG2B,eAAe,CAAC5B,CAAC,CAAC;UAClC,IAAIE,MAAM,GAAGlE,YAAY,CAACgB,SAAS,CAACZ,MAAM,EAAE6D,SAAS,EAAEvK,OAAO,CAACxC,WAAW,CAACiN,aAAa,CAAC;UACzF,IAAID,MAAM,CAACzC,KAAK,KAAK,CAAC,CAAC,EAAE;YACvB,OAAO;cACLsE,KAAK,EAAE7B,MAAM,CAACzC,KAAK;cACnBxF,MAAM,EAAEiI,MAAM,CAACjI;YACjB,CAAC;UACH;QACF;QACAmH,MAAM,GAAGpD,YAAY,CAACmC,UAAU,CAACc,KAAK,CAAC1M,IAAI,EAAE,IAAI,EAAEmD,OAAO,CAAC;MAC7D;MACA,OAAO;QACLqM,KAAK,EAAEN,MAAM;QACbxJ,MAAM,EAAE6F,KAAK,GAAGA,KAAK,CAAC7F,MAAM,GAAG,CAAC;QAChCyH,KAAK,EAAEN;MACT,CAAC;IACH,CAAC;IACDV,SAAS,EAAE,SAAAA,CAAUsD,OAAO,EAAE;MAC5B,OAAOA,OAAO,GAAG,CAAC;IACpB;EACF,CAAC,CAAC;EACF,GAAG,EAAEtQ,UAAU,CAAC6M,oBAAoB,CAAC;IACnCI,IAAI,EAAE,YAAY;IAClBlI,MAAM,EAAE,SAAAA,CAAUqI,MAAM,EAAEC,KAAK,EAAEY,IAAI,EAAEjK,OAAO,EAAE;MAC9C,IAAIyL,KAAK,GAAGpC,KAAK,CAACqC,UAAU,CAAC1L,OAAO,CAACT,OAAO,EAAEoM,wBAAwB,CAAC3L,OAAO,CAAC1B,cAAc,CAAC,CAAC;MAC/F,IAAIiO,KAAK,GAAGd,KAAK,CAACe,IAAI;MACtB,IAAIC,KAAK,GAAG/P,MAAM,CAAC6P,KAAK,GAAG,CAAC,CAAC;MAC7B,IAAInD,MAAM,CAACgB,MAAM,GAAG,CAAC,EAAE;QACrBqC,KAAK,GAAGA,KAAK,CAAC1B,QAAQ,CAAC3B,MAAM,CAACgB,MAAM,EAAE,GAAG,CAAC;MAC5C,CAAC,MAAM;QACLqC,KAAK,GAAGzM,OAAO,CAACxC,WAAW,CAACkP,eAAe,CAACtD,MAAM,CAACgB,MAAM,KAAK,CAAC,GAAG,QAAQ,GAAG,MAAM,EAAEqC,KAAK,CAAC1B,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;MAC9G;MACA,OAAO0B,KAAK;IACd,CAAC;IACDvD,KAAK,EAAE,SAAAA,CAAUxC,MAAM,EAAE6C,KAAK,EAAEvJ,OAAO,EAAEwJ,OAAO,EAAE;MAChD,IAAIpB,KAAK;QACPO,YAAY;QACZe,MAAM;QACN6C,KAAK;QACL3F,OAAO,GAAG,CAAC;MACb,IAAI2C,KAAK,CAACa,MAAM,GAAG,CAAC,EAAE;QACpBhC,KAAK,GAAG9B,YAAY,CAACG,WAAW,CAACC,MAAM,EAAE,CAAC,CAAC;QAC3CE,OAAO,GAAGwB,KAAK,CAAC7F,MAAM;QACtBgK,KAAK,GAAGhE,QAAQ,CAACH,KAAK,CAAC,GAAG,CAAC;QAC3BO,YAAY,GAAG,CAACP,KAAK,IAAIoB,OAAO,CAACyB,WAAW,IAAIrE,OAAO,GAAG,CAAC;QAC3D8C,MAAM,GAAGpD,YAAY,CAACmC,UAAU,CAACc,KAAK,CAAC1M,IAAI,EAAE8L,YAAY,EAAE3I,OAAO,CAAC;MACrE,CAAC,MAAM;QACLoI,KAAK,GAAGpI,OAAO,CAACxC,WAAW,CAACkP,eAAe,CAACnD,KAAK,CAACa,MAAM,KAAK,CAAC,GAAG,QAAQ,GAAG,MAAM,CAAC;QACnFhC,KAAK,GAAGA,KAAK,CAAC5G,OAAO,CAAC,KAAK,EAAE,UAAU,CAAC;QACxC,IAAImL,WAAW,GAAG,IAAIC,MAAM,CAACxE,KAAK,CAAC;UACjCyE,OAAO,GAAGF,WAAW,CAACG,IAAI,CAACpG,MAAM,CAAC;QACpC,IAAImG,OAAO,EAAE;UACX;UACA;UACAjG,OAAO,GAAGiG,OAAO,CAAC,CAAC,CAAC,CAACtK,MAAM;UAC3BgK,KAAK,GAAGhE,QAAQ,CAACsE,OAAO,CAACA,OAAO,CAACtK,MAAM,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC;QACnD,CAAC,MAAM;UACLmH,MAAM,GAAGpD,YAAY,CAACmC,UAAU,CAACc,KAAK,CAAC1M,IAAI,EAAE,IAAI,EAAEmD,OAAO,CAAC;QAC7D;MACF;MACA,OAAO;QACLuC,MAAM,EAAEqE,OAAO;QACfoD,KAAK,EAAEN,MAAM;QACb8C,IAAI,EAAED;MACR,CAAC;IACH,CAAC;IACDvD,SAAS,EAAE,SAAAA,CAAUsD,OAAO,EAAE;MAC5B,OAAOA,OAAO,GAAG,CAAC;IACpB;EACF,CAAC,CAAC;EACF,GAAG,EAAEtQ,UAAU,CAAC6M,oBAAoB,CAAC;IACnCI,IAAI,EAAE;EACR,CAAC,CAAC;EACF,GAAG,EAAEjN,UAAU,CAAC6M,oBAAoB,CAAC;IACnCI,IAAI,EAAE;EACR,CAAC,CAAC;EACF,GAAG,EAAEjN,UAAU,CAAC6M,oBAAoB,CAAC;IACnCI,IAAI,EAAE,KAAK;IACXlI,MAAM,EAAE,SAAAA,CAAUqI,MAAM,EAAEC,KAAK,EAAE;MAC/B,IAAI0D,KAAK,GAAG1D,KAAK,CAAC2D,UAAU,CAAC,CAAC;MAC9B,OAAOtQ,MAAM,CAACqQ,KAAK,CAAC,CAAChC,QAAQ,CAAC3B,MAAM,CAACgB,MAAM,EAAE,GAAG,CAAC;IACnD,CAAC;IACDlB,KAAK,EAAE,SAAAA,CAAUxC,MAAM,EAAE6C,KAAK,EAAEvJ,OAAO,EAAEwJ,OAAO,EAAE;MAChD,IAAIpB,KAAK,GAAG9B,YAAY,CAACG,WAAW,CAACC,MAAM,EAAE2E,IAAI,CAACc,GAAG,CAAC5C,KAAK,CAACa,MAAM,EAAE,CAAC,CAAC,CAAC;QACrEzB,YAAY,GAAGP,KAAK,KAAK,EAAE,IAAIoB,OAAO,CAACyB,WAAW,IAAI7C,KAAK,CAAC7F,MAAM,GAAG,CAAC;QACtEmH,MAAM,GAAGpD,YAAY,CAACmC,UAAU,CAACc,KAAK,CAAC1M,IAAI,EAAE8L,YAAY,EAAE3I,OAAO,CAAC;QACnEiN,IAAI,GAAG1E,QAAQ,CAACH,KAAK,CAAC;MACxB,IAAIoB,OAAO,CAAC4C,MAAM,KAAKa,IAAI,GAAG,EAAE,IAAIA,IAAI,GAAG,CAAC,CAAC,EAAE;QAC7CvD,MAAM,GAAG,KAAK;MAChB;MACA,OAAO;QACLwD,GAAG,EAAED,IAAI;QACT1K,MAAM,EAAE6F,KAAK,CAAC7F,MAAM;QACpByH,KAAK,EAAEN;MACT,CAAC;IACH,CAAC;IACDV,SAAS,EAAE;EACb,CAAC,CAAC;EACF,GAAG,EAAEhN,UAAU,CAAC6M,oBAAoB,CAAC;IACnCI,IAAI,EAAE,SAAS;IACflI,MAAM,EAAE,SAAAA,CAAUqI,MAAM,EAAEC,KAAK,EAAEY,IAAI,EAAEjK,OAAO,EAAE;MAC9C,IAAImN,QAAQ,GAAG9D,KAAK,CAAC+D,aAAa,CAAC,CAAC;MACpC,IAAIhE,MAAM,CAACgB,MAAM,KAAK,CAAC,EAAE;QACvB,OAAOpK,OAAO,CAACiE,eAAe,CAACkJ,QAAQ,CAAC;MAC1C,CAAC,MAAM,IAAI/D,MAAM,CAACgB,MAAM,KAAK,CAAC,EAAE;QAC9B,OAAOpK,OAAO,CAACmE,aAAa,CAACgJ,QAAQ,CAAC;MACxC,CAAC,MAAM,IAAI/D,MAAM,CAACgB,MAAM,GAAG,CAAC,EAAE;QAC5B,OAAOpK,OAAO,CAACoE,eAAe,CAAC+I,QAAQ,CAAC;MAC1C,CAAC,MAAM;QACL,OAAOzQ,MAAM,CAACyQ,QAAQ,GAAG,CAAC,CAAC,CAACpC,QAAQ,CAAC3B,MAAM,CAACgB,MAAM,EAAE,GAAG,CAAC;MAC1D;IACF,CAAC;IACDlB,KAAK,EAAE,SAAAA,CAAUxC,MAAM,EAAE6C,KAAK,EAAEvJ,OAAO,EAAEwJ,OAAO,EAAE;MAChD,IAAIpB,KAAK,EAAEO,YAAY,EAAEwE,QAAQ,EAAEzD,MAAM;MACzC,IAAI2D,iBAAiB,GAAG,CAACrN,OAAO,CAACmE,aAAa,EAAEnE,OAAO,CAACuE,eAAe,EAAEvE,OAAO,CAACiE,eAAe,EAAEjE,OAAO,CAACqE,iBAAiB,EAAErE,OAAO,CAACoE,eAAe,EAAEpE,OAAO,CAACwE,iBAAiB,CAAC;MAChL,IAAI+E,KAAK,CAACa,MAAM,GAAG,CAAC,EAAE;QACpBhC,KAAK,GAAG9B,YAAY,CAACG,WAAW,CAACC,MAAM,EAAE2E,IAAI,CAACc,GAAG,CAAC5C,KAAK,CAACa,MAAM,EAAE,CAAC,CAAC,CAAC;QACnEzB,YAAY,GAAGP,KAAK,KAAK,EAAE,IAAIoB,OAAO,CAACyB,WAAW,IAAI7C,KAAK,CAAC7F,MAAM,GAAG,CAAC;QACtEmH,MAAM,GAAGpD,YAAY,CAACmC,UAAU,CAACc,KAAK,CAAC1M,IAAI,EAAE8L,YAAY,EAAE3I,OAAO,CAAC;QACnEmN,QAAQ,GAAG5E,QAAQ,CAACH,KAAK,CAAC,GAAG,CAAC;QAC9B,IAAIoB,OAAO,CAAC4C,MAAM,IAAIe,QAAQ,GAAG,CAAC,EAAE;UAClCzD,MAAM,GAAG,KAAK;QAChB;MACF,CAAC,MAAM;QACL,KAAK,IAAIY,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+C,iBAAiB,CAAC9K,MAAM,EAAE+H,CAAC,EAAE,EAAE;UACjD,IAAIC,SAAS,GAAG8C,iBAAiB,CAAC/C,CAAC,CAAC;UACpC,IAAIE,MAAM,GAAGlE,YAAY,CAACgB,SAAS,CAACZ,MAAM,EAAE6D,SAAS,EAAEvK,OAAO,CAACxC,WAAW,CAACiN,aAAa,CAAC;UACzF,IAAID,MAAM,CAACzC,KAAK,KAAK,CAAC,CAAC,EAAE;YACvB,OAAO;cACLuF,OAAO,EAAE9C,MAAM,CAACzC,KAAK;cACrBxF,MAAM,EAAEiI,MAAM,CAACjI;YACjB,CAAC;UACH;QACF;QACAmH,MAAM,GAAGpD,YAAY,CAACmC,UAAU,CAACc,KAAK,CAAC1M,IAAI,EAAE,IAAI,EAAEmD,OAAO,CAAC;MAC7D;MACA,OAAO;QACLuC,MAAM,EAAE6F,KAAK,GAAGA,KAAK,CAAC7F,MAAM,GAAG,CAAC;QAChC+K,OAAO,EAAEH,QAAQ;QACjBnD,KAAK,EAAEN;MACT,CAAC;IACH,CAAC;IACDV,SAAS,EAAE,SAAAA,CAAUsD,OAAO,EAAE;MAC5B,OAAOA,OAAO,GAAG,CAAC;IACpB;EACF,CAAC,CAAC;EACF,GAAG,EAAEtQ,UAAU,CAAC6M,oBAAoB,CAAC;IACnCI,IAAI,EAAE,mBAAmB;IACzBlI,MAAM,EAAE,SAAAA,CAAUqI,MAAM,EAAEC,KAAK,EAAEY,IAAI,EAAEjK,OAAO,EAAE;MAC9C,IAAImN,QAAQ,GAAG9D,KAAK,CAAC+D,aAAa,CAAC,CAAC;MACpC,IAAIhE,MAAM,CAACgB,MAAM,KAAK,CAAC,EAAE;QACvB,OAAOpK,OAAO,CAACqE,iBAAiB,CAAC8I,QAAQ,CAAC;MAC5C,CAAC,MAAM,IAAI/D,MAAM,CAACgB,MAAM,KAAK,CAAC,EAAE;QAC9B,OAAOpK,OAAO,CAACuE,eAAe,CAAC4I,QAAQ,CAAC;MAC1C,CAAC,MAAM,IAAI/D,MAAM,CAACgB,MAAM,GAAG,CAAC,EAAE;QAC5B,OAAOpK,OAAO,CAACwE,iBAAiB,CAAC2I,QAAQ,CAAC;MAC5C,CAAC,MAAM;QACL,OAAOzQ,MAAM,CAACyQ,QAAQ,GAAG,CAAC,CAAC,CAACpC,QAAQ,CAAC3B,MAAM,CAACgB,MAAM,EAAE,GAAG,CAAC;MAC1D;IACF,CAAC;IACDlB,KAAK,EAAE,SAAAA,CAAUxC,MAAM,EAAE6C,KAAK,EAAEvJ,OAAO,EAAEwJ,OAAO,EAAE;MAChD,IAAIpB,KAAK,EAAEO,YAAY,EAAEwE,QAAQ,EAAEzD,MAAM;MACzC,IAAI2D,iBAAiB,GAAG,CAACrN,OAAO,CAACmE,aAAa,EAAEnE,OAAO,CAACuE,eAAe,EAAEvE,OAAO,CAACiE,eAAe,EAAEjE,OAAO,CAACqE,iBAAiB,EAAErE,OAAO,CAACoE,eAAe,EAAEpE,OAAO,CAACwE,iBAAiB,CAAC;MAChL,IAAI+E,KAAK,CAACa,MAAM,GAAG,CAAC,EAAE;QACpBhC,KAAK,GAAG9B,YAAY,CAACG,WAAW,CAACC,MAAM,EAAE2E,IAAI,CAACc,GAAG,CAAC5C,KAAK,CAACa,MAAM,EAAE,CAAC,CAAC,CAAC;QACnEzB,YAAY,GAAGP,KAAK,KAAK,EAAE,IAAIoB,OAAO,CAACyB,WAAW,IAAI7C,KAAK,CAAC7F,MAAM,GAAG,CAAC;QACtEmH,MAAM,GAAGpD,YAAY,CAACmC,UAAU,CAACc,KAAK,CAAC1M,IAAI,EAAE8L,YAAY,EAAE3I,OAAO,CAAC;QACnEmN,QAAQ,GAAG5E,QAAQ,CAACH,KAAK,CAAC,GAAG,CAAC;QAC9B,IAAIoB,OAAO,CAAC4C,MAAM,IAAIe,QAAQ,GAAG,CAAC,EAAE;UAClCzD,MAAM,GAAG,KAAK;QAChB;MACF,CAAC,MAAM;QACL,KAAK,IAAIY,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+C,iBAAiB,CAAC9K,MAAM,EAAE+H,CAAC,EAAE,EAAE;UACjD,IAAIC,SAAS,GAAG8C,iBAAiB,CAAC/C,CAAC,CAAC;UACpC,IAAIE,MAAM,GAAGlE,YAAY,CAACgB,SAAS,CAACZ,MAAM,EAAE6D,SAAS,EAAEvK,OAAO,CAACxC,WAAW,CAACiN,aAAa,CAAC;UACzF,IAAID,MAAM,CAACzC,KAAK,KAAK,CAAC,CAAC,EAAE;YACvB,OAAO;cACLuF,OAAO,EAAE9C,MAAM,CAACzC,KAAK;cACrBxF,MAAM,EAAEiI,MAAM,CAACjI;YACjB,CAAC;UACH;QACF;QACAmH,MAAM,GAAGpD,YAAY,CAACmC,UAAU,CAACc,KAAK,CAAC1M,IAAI,EAAE,IAAI,EAAEmD,OAAO,CAAC;MAC7D;MACA,OAAO;QACLuC,MAAM,EAAE6F,KAAK,GAAGA,KAAK,CAAC7F,MAAM,GAAG,CAAC;QAChC+K,OAAO,EAAEH,QAAQ;QACjBnD,KAAK,EAAEN;MACT,CAAC;IACH,CAAC;IACDV,SAAS,EAAE,SAAAA,CAAUsD,OAAO,EAAE;MAC5B,OAAOA,OAAO,GAAG,CAAC;IACpB;EACF,CAAC,CAAC;EACF,GAAG,EAAEtQ,UAAU,CAAC6M,oBAAoB,CAAC;IACnCI,IAAI,EAAE;EACR,CAAC,CAAC;EACF,GAAG,EAAEjN,UAAU,CAAC6M,oBAAoB,CAAC;IACnCI,IAAI,EAAE,eAAe;IACrB;IACAlI,MAAM,EAAE,SAAAA,CAAUqI,MAAM,EAAEC,KAAK,EAAEY,IAAI,EAAEjK,OAAO,EAAE;MAC9C,IAAIiN,IAAI,GAAG5D,KAAK,CAACkE,SAAS,CAAC,CAAC;MAC5B,IAAInE,MAAM,CAACgB,MAAM,GAAG,CAAC,EAAE;QACrB,OAAOpK,OAAO,CAACuD,WAAW,CAAC0J,IAAI,CAAC;MAClC,CAAC,MAAM,IAAI7D,MAAM,CAACgB,MAAM,KAAK,CAAC,EAAE;QAC9B,OAAOpK,OAAO,CAACyD,SAAS,CAACwJ,IAAI,CAAC;MAChC,CAAC,MAAM,IAAI7D,MAAM,CAACgB,MAAM,KAAK,CAAC,EAAE;QAC9B,OAAOpK,OAAO,CAAC0D,WAAW,CAACuJ,IAAI,CAAC;MAClC,CAAC,MAAM;QACL,OAAOjN,OAAO,CAAC2D,UAAU,CAACsJ,IAAI,CAAC;MACjC;IACF,CAAC;IACD/D,KAAK,EAAE,SAAAA,CAAUxC,MAAM,EAAE6C,KAAK,EAAEvJ,OAAO,EAAEwJ,OAAO,EAAE;MAChD,IAAIgE,aAAa,GAAG,CAACxN,OAAO,CAACyD,SAAS,EAAEzD,OAAO,CAAC8D,WAAW,EAAE9D,OAAO,CAACuD,WAAW,EAAEvD,OAAO,CAAC4D,aAAa,EAAE5D,OAAO,CAAC2D,UAAU,EAAE3D,OAAO,CAACgE,YAAY,EAAEhE,OAAO,CAAC0D,WAAW,EAAE1D,OAAO,CAAC+D,aAAa,CAAC;MAC9L,KAAK,IAAIuG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkD,aAAa,CAACjL,MAAM,EAAE+H,CAAC,EAAE,EAAE;QAC7C,IAAIC,SAAS,GAAGiD,aAAa,CAAClD,CAAC,CAAC;QAChC,IAAIE,MAAM,GAAGlE,YAAY,CAACgB,SAAS,CAACZ,MAAM,EAAE6D,SAAS,EAAEvK,OAAO,CAACxC,WAAW,CAACiN,aAAa,CAAC;QACzF,IAAID,MAAM,CAACzC,KAAK,KAAK,CAAC,CAAC,EAAE;UACvB,OAAO;YACL;YACA0F,SAAS,EAAEjD,MAAM,CAACzC,KAAK;YACvBxF,MAAM,EAAEiI,MAAM,CAACjI;UACjB,CAAC;QACH;MACF;IACF;EACF,CAAC,CAAC;EACF,GAAG,EAAEvG,UAAU,CAAC6M,oBAAoB,CAAC;IACnCI,IAAI,EAAE,yBAAyB;IAC/BlI,MAAM,EAAE,SAAAA,CAAUqI,MAAM,EAAEC,KAAK,EAAEY,IAAI,EAAEjK,OAAO,EAAE;MAC9C,IAAIiN,IAAI,GAAG5D,KAAK,CAACkE,SAAS,CAAC,CAAC;MAC5B,IAAInE,MAAM,CAACgB,MAAM,GAAG,CAAC,EAAE;QACrB,OAAOpK,OAAO,CAAC4D,aAAa,CAACqJ,IAAI,CAAC;MACpC,CAAC,MAAM,IAAI7D,MAAM,CAACgB,MAAM,KAAK,CAAC,EAAE;QAC9B,OAAOpK,OAAO,CAAC8D,WAAW,CAACmJ,IAAI,CAAC;MAClC,CAAC,MAAM,IAAI7D,MAAM,CAACgB,MAAM,KAAK,CAAC,EAAE;QAC9B,OAAOpK,OAAO,CAAC+D,aAAa,CAACkJ,IAAI,CAAC;MACpC,CAAC,MAAM;QACL,OAAOjN,OAAO,CAACgE,YAAY,CAACiJ,IAAI,CAAC;MACnC;IACF,CAAC;IACD/D,KAAK,EAAE,SAAAA,CAAUxC,MAAM,EAAE6C,KAAK,EAAEvJ,OAAO,EAAEwJ,OAAO,EAAE;MAChD,IAAIgE,aAAa,GAAG,CAACxN,OAAO,CAACyD,SAAS,EAAEzD,OAAO,CAAC8D,WAAW,EAAE9D,OAAO,CAACuD,WAAW,EAAEvD,OAAO,CAAC4D,aAAa,EAAE5D,OAAO,CAAC2D,UAAU,EAAE3D,OAAO,CAACgE,YAAY,EAAEhE,OAAO,CAAC0D,WAAW,EAAE1D,OAAO,CAAC+D,aAAa,CAAC;MAC9L,KAAK,IAAIuG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkD,aAAa,CAACjL,MAAM,EAAE+H,CAAC,EAAE,EAAE;QAC7C,IAAIC,SAAS,GAAGiD,aAAa,CAAClD,CAAC,CAAC;QAChC,IAAIE,MAAM,GAAGlE,YAAY,CAACgB,SAAS,CAACZ,MAAM,EAAE6D,SAAS,EAAEvK,OAAO,CAACxC,WAAW,CAACiN,aAAa,CAAC;QACzF,IAAID,MAAM,CAACzC,KAAK,KAAK,CAAC,CAAC,EAAE;UACvB,OAAO;YACLmF,GAAG,EAAE1C,MAAM,CAACzC,KAAK;YACjBxF,MAAM,EAAEiI,MAAM,CAACjI;UACjB,CAAC;QACH;MACF;IACF;EACF,CAAC,CAAC;EACF;EACA;EACA;EACA;EACA;EACA,GAAG,EAAEvG,UAAU,CAAC6M,oBAAoB,CAAC;IACnCI,IAAI,EAAE,iBAAiB;IACvBlI,MAAM,EAAE,SAAAA,CAAUqI,MAAM,EAAEC,KAAK,EAAEY,IAAI,EAAEjK,OAAO,EAAE;MAC9C,IAAIiN,IAAI,GAAG5D,KAAK,CAACkE,SAAS,CAAC,CAAC;MAC5B,OAAOvN,OAAO,CAAC0N,eAAe,CAACT,IAAI,CAAC;IACtC,CAAC;IACD/D,KAAK,EAAE,SAAAA,CAAUxC,MAAM,EAAE6C,KAAK,EAAEvJ,OAAO,EAAEwJ,OAAO,EAAE;MAChD,IAAIpB,KAAK,GAAG9B,YAAY,CAACG,WAAW,CAACC,MAAM,EAAE6C,KAAK,CAACa,MAAM,CAAC;QACxDzB,YAAY,GAAGa,OAAO,CAACyB,WAAW,IAAI7C,KAAK,CAAC7F,MAAM,KAAKgH,KAAK,CAACa,MAAM;MACrE,OAAO;QACLuD,eAAe,EAAEpF,QAAQ,CAACH,KAAK,CAAC;QAChC7F,MAAM,EAAE6F,KAAK,CAAC7F,MAAM;QACpByH,KAAK,EAAE1D,YAAY,CAACmC,UAAU,CAACc,KAAK,CAAC1M,IAAI,EAAE8L,YAAY,EAAE3I,OAAO;MAClE,CAAC;IACH,CAAC;IACDgJ,SAAS,EAAE;EACb,CAAC,CAAC;EACF,GAAG,EAAEhN,UAAU,CAAC6M,oBAAoB,CAAC;IACnCI,IAAI,EAAE,YAAY;IAClB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIlI,MAAM,EAAE,SAAAA,CAAUqI,MAAM,EAAEC,KAAK,EAAEY,IAAI,EAAEjK,OAAO,EAAE;MAC9C,IAAI4N,UAAU,GAAGvE,KAAK,CAACwE,eAAe,CAAC,CAAC;MACxC,IAAIzE,MAAM,CAACgB,MAAM,IAAI,CAAC,EAAE;QACtB,OAAOpK,OAAO,CAAC6E,iBAAiB,CAAC+I,UAAU,CAAC;MAC9C,CAAC,MAAM,IAAIxE,MAAM,CAACgB,MAAM,KAAK,CAAC,EAAE;QAC9B,OAAOpK,OAAO,CAACgF,eAAe,CAAC4I,UAAU,CAAC;MAC5C,CAAC,MAAM;QACL,OAAO5N,OAAO,CAAC+E,iBAAiB,CAAC6I,UAAU,CAAC;MAC9C;IACF,CAAC;IACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI1E,KAAK,EAAE,SAAAA,CAAUxC,MAAM,EAAE6C,KAAK,EAAEvJ,OAAO,EAAEwJ,OAAO,EAAE/M,SAAS,EAAE;MAC3D;MACA;MACA,IAAIqR,KAAK;QACPC,oBAAoB;QACpBC,MAAM;QACN1D,CAAC;QACD2D,MAAM;QACN1D,SAAS;QACT2D,mBAAmB,GAAG,CAAClO,OAAO,CAACgF,eAAe,EAAEhF,OAAO,CAAC6E,iBAAiB,EAAE7E,OAAO,CAAC+E,iBAAiB,CAAC;;MAEvG;MACA;MACA;MACA+I,KAAK,GAAG,qCAAqC;MAC7CG,MAAM,GAAGvH,MAAM,CAACyH,KAAK,CAACL,KAAK,CAAC;MAC5BC,oBAAoB,GAAGE,MAAM,IAAIA,MAAM,CAAClG,KAAK,KAAK,CAAC;MACnD,SAASqG,mBAAmBA,CAAC1H,MAAM,EAAE;QACnC;QACA,OAAOA,MAAM,CAAClF,OAAO,CAAC,aAAa,EAAE,EAAE,CAAC,CAACA,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC;MAC7D;MACA,IAAIuM,oBAAoB,EAAE;QACxBrH,MAAM,GAAG0H,mBAAmB,CAAC1H,MAAM,CAAC;MACtC;MACA,KAAK4D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4D,mBAAmB,CAAC3L,MAAM,EAAE+H,CAAC,IAAI,CAAC,EAAE;QAClDC,SAAS,GAAG2D,mBAAmB,CAAC5D,CAAC,CAAC,CAACxE,GAAG,CAACuI,UAAU,IAAI;UACnD,OAAOrS,UAAU,CAAC8N,UAAU,CAACuE,UAAU,CAAC;QAC1C,CAAC,CAAC;QACF,IAAIN,oBAAoB,EAAE;UACxB;UACAxD,SAAS,GAAGA,SAAS,CAACzE,GAAG,CAACsI,mBAAmB,CAAC;QAChD;QACA;QACAJ,MAAM,GAAG1H,YAAY,CAACgB,SAAS,CAACZ,MAAM,EAAE6D,SAAS,EAAEvK,OAAO,CAACxC,WAAW,CAACiN,aAAa,CAAC;QACrF,IAAIuD,MAAM,CAACjG,KAAK,KAAK,CAAC,CAAC,EAAE;UACvB,OAAO;YACLuG,EAAE,EAAEN,MAAM,CAACjG,KAAK,KAAK,CAAC;YACtB;YACA;YACA;YACAxF,MAAM,EAAEwL,oBAAoB,GAAGE,MAAM,CAAC,CAAC,CAAC,CAAC1L,MAAM,GAAGyL,MAAM,CAACzL;UAC3D,CAAC;QACH;MACF;MACA,OAAO;QACLyH,KAAK,EAAE;MACT,CAAC;IACH;EACF,CAAC,CAAC;EACF,GAAG,EAAEhO,UAAU,CAAC6M,oBAAoB,CAAC;IACnCI,IAAI,EAAE,mBAAmB;IACzB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIlI,MAAM,EAAE,SAAAA,CAAUqI,MAAM,EAAEC,KAAK,EAAEY,IAAI,EAAEjK,OAAO,EAAE;MAC9C;MACA;MACA;MACA;MACA,IAAIuO,aAAa,GAAGvO,OAAO,CAACyF,YAAY,CAACpD,IAAI,CAAC,UAAUmM,cAAc,EAAE;UACpE,OAAO,MAAM,CAAC1N,QAAQ,CAAC0N,cAAc,CAACC,MAAM,CAAC;QAC/C,CAAC,CAAC;QACFC,kBAAkB,GAAG1O,OAAO,CAACxC,WAAW,CAACmR,0BAA0B,CAACtF,KAAK,CAACuF,WAAW,CAAC,CAAC,EAAEvF,KAAK,CAACwF,aAAa,CAAC,CAAC,CAAC;MACjH,IAAIN,aAAa,EAAE;QACjB,IAAInF,MAAM,CAACgB,MAAM,IAAI,CAAC,EAAE;UACtB,OAAOpK,OAAO,CAACiF,yBAAyB,CAACyJ,kBAAkB,CAAC;QAC9D;QACA,IAAItF,MAAM,CAACgB,MAAM,KAAK,CAAC,EAAE;UACvB,OAAOpK,OAAO,CAACoF,uBAAuB,CAACsJ,kBAAkB,CAAC;QAC5D;QACA,OAAO1O,OAAO,CAACmF,yBAAyB,CAACuJ,kBAAkB,CAAC;MAC9D;MACA,IAAItF,MAAM,CAACgB,MAAM,IAAI,CAAC,EAAE;QACtB,OAAOpK,OAAO,CAACqF,2BAA2B,CAACqJ,kBAAkB,CAAC;MAChE;MACA,IAAItF,MAAM,CAACgB,MAAM,KAAK,CAAC,EAAE;QACvB,OAAOpK,OAAO,CAACwF,yBAAyB,CAACkJ,kBAAkB,CAAC;MAC9D;MACA,OAAO1O,OAAO,CAACuF,2BAA2B,CAACmJ,kBAAkB,CAAC;IAChE,CAAC;IACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIxF,KAAK,EAAE,SAAAA,CAAUxC,MAAM,EAAE6C,KAAK,EAAEvJ,OAAO,EAAEwJ,OAAO,EAAE;MAChD,IAAIc,CAAC;QACHE,MAAM;QACNsE,QAAQ;QACRP,aAAa,GAAGvO,OAAO,CAACyF,YAAY,CAACpD,IAAI,CAAC,UAAUmM,cAAc,EAAE;UAClE,OAAO,MAAM,CAAC1N,QAAQ,CAAC0N,cAAc,CAACC,MAAM,CAAC;QAC/C,CAAC,CAAC;QACF;QACA;QACAM,0BAA0B,GAAG,CAAC/O,OAAO,CAACoF,uBAAuB,EAAEpF,OAAO,CAACiF,yBAAyB,EAAEjF,OAAO,CAACmF,yBAAyB,CAAC;MACtI,IAAIoJ,aAAa,EAAE;QACjB,KAAKjE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyE,0BAA0B,CAACxM,MAAM,EAAE+H,CAAC,EAAE,EAAE;UACtDwE,QAAQ,GAAGC,0BAA0B,CAACzE,CAAC,CAAC;UACxCE,MAAM,GAAGlE,YAAY,CAACgB,SAAS,CAACZ,MAAM,EAAE1H,MAAM,CAAC6B,MAAM,CAACiO,QAAQ,CAAC,EAAE9O,OAAO,CAACxC,WAAW,CAACiN,aAAa,CAAC;UACnG,IAAID,MAAM,CAACzC,KAAK,KAAK,CAAC,CAAC,EAAE;YACvB,OAAO;cACLiH,aAAa,EAAEhQ,MAAM,CAACmD,IAAI,CAAC2M,QAAQ,CAAC,CAACtE,MAAM,CAACzC,KAAK,CAAC;cAClDxF,MAAM,EAAEiI,MAAM,CAACjI;YACjB,CAAC;UACH;QACF;MACF;MACA,OAAO;QACLyH,KAAK,EAAE;MACT,CAAC;IACH;EACF,CAAC,CAAC;EACF,GAAG,EAAEhO,UAAU,CAAC6M,oBAAoB,CAAC;IACnCI,IAAI,EAAE,UAAU;IAChBlI,MAAM,EAAE,SAAAA,CAAUqI,MAAM,EAAEC,KAAK,EAAE;MAC/B,IAAI4F,MAAM,GAAG5F,KAAK,CAACuF,WAAW,CAAC,CAAC;MAChC,OAAOlS,MAAM,CAACuS,MAAM,CAAC,CAAClE,QAAQ,CAAC3B,MAAM,CAACgB,MAAM,EAAE,GAAG,CAAC;IACpD,CAAC;IACDlB,KAAK,EAAE,SAAAA,CAAUxC,MAAM,EAAE6C,KAAK,EAAEvJ,OAAO,EAAEwJ,OAAO,EAAE;MAChD,IAAIpB,KAAK,GAAG9B,YAAY,CAACG,WAAW,CAACC,MAAM,EAAE2E,IAAI,CAACc,GAAG,CAAC5C,KAAK,CAACa,MAAM,EAAE,CAAC,CAAC,CAAC;QACrE6E,MAAM,GAAG1G,QAAQ,CAACH,KAAK,CAAC;QACxBO,YAAY,GAAGP,KAAK,KAAK,EAAE,IAAIoB,OAAO,CAACyB,WAAW,IAAI7C,KAAK,CAAC7F,MAAM,GAAG,CAAC;QACtEmH,MAAM,GAAGpD,YAAY,CAACmC,UAAU,CAACc,KAAK,CAAC1M,IAAI,EAAE8L,YAAY,EAAE3I,OAAO,CAAC;MACrE,IAAIwJ,OAAO,CAAC4C,MAAM,IAAI6C,MAAM,GAAG,EAAE,EAAE;QACjCvF,MAAM,GAAG,KAAK;MAChB;MACA,OAAO;QACLwF,IAAI,EAAED,MAAM;QACZ1M,MAAM,EAAE6F,KAAK,CAAC7F,MAAM;QACpByH,KAAK,EAAEN;MACT,CAAC;IACH,CAAC;IACDV,SAAS,EAAE;EACb,CAAC,CAAC;EACF,GAAG,EAAEhN,UAAU,CAAC6M,oBAAoB,CAAC;IACnCI,IAAI,EAAE,UAAU;IAChBlI,MAAM,EAAE,SAAAA,CAAUqI,MAAM,EAAEC,KAAK,EAAE;MAC/B,IAAI4F,MAAM,GAAG5F,KAAK,CAACuF,WAAW,CAAC,CAAC;MAChC,IAAIO,MAAM,GAAGF,MAAM,KAAK,CAAC,GAAG,IAAI,GAAGvS,MAAM,CAACuS,MAAM,CAAC;MACjD,OAAOE,MAAM,CAACpE,QAAQ,CAAC3B,MAAM,CAACgB,MAAM,EAAE,GAAG,CAAC;IAC5C,CAAC;IACDlB,KAAK,EAAE,SAAAA,CAAUxC,MAAM,EAAE6C,KAAK,EAAEvJ,OAAO,EAAEwJ,OAAO,EAAE;MAChD,IAAIpB,KAAK,GAAG9B,YAAY,CAACG,WAAW,CAACC,MAAM,EAAE2E,IAAI,CAACc,GAAG,CAAC5C,KAAK,CAACa,MAAM,EAAE,CAAC,CAAC,CAAC;QACrE6E,MAAM,GAAG1G,QAAQ,CAACH,KAAK,CAAC;QACxBO,YAAY,GAAGP,KAAK,KAAK,EAAE,IAAIoB,OAAO,CAACyB,WAAW,IAAI7C,KAAK,CAAC7F,MAAM,GAAG,CAAC;QACtEmH,MAAM,GAAGpD,YAAY,CAACmC,UAAU,CAACc,KAAK,CAAC1M,IAAI,EAAE8L,YAAY,EAAE3I,OAAO,CAAC;MACrE,IAAIiP,MAAM,KAAK,EAAE,EAAE;QACjBA,MAAM,GAAG,CAAC;MACZ;MACA,IAAIzF,OAAO,CAAC4C,MAAM,IAAI6C,MAAM,GAAG,EAAE,EAAE;QACjCvF,MAAM,GAAG,KAAK;MAChB;MACA,OAAO;QACLwF,IAAI,EAAED,MAAM;QACZ1M,MAAM,EAAE6F,KAAK,CAAC7F,MAAM;QACpByH,KAAK,EAAEN;MACT,CAAC;IACH,CAAC;IACDV,SAAS,EAAE;EACb,CAAC,CAAC;EACF,GAAG,EAAEhN,UAAU,CAAC6M,oBAAoB,CAAC;IACnCI,IAAI,EAAE,UAAU;IAChBlI,MAAM,EAAE,SAAAA,CAAUqI,MAAM,EAAEC,KAAK,EAAE;MAC/B,IAAI4F,MAAM,GAAG5F,KAAK,CAACuF,WAAW,CAAC,CAAC;MAChC,IAAIO,MAAM,GAAGzS,MAAM,CAACuS,MAAM,GAAG,EAAE,GAAGA,MAAM,GAAG,EAAE,GAAGA,MAAM,CAAC;MACvD,OAAOE,MAAM,CAACpE,QAAQ,CAAC3B,MAAM,CAACgB,MAAM,EAAE,GAAG,CAAC;IAC5C,CAAC;IACDlB,KAAK,EAAE,SAAAA,CAAUxC,MAAM,EAAE6C,KAAK,EAAEvJ,OAAO,EAAEwJ,OAAO,EAAE;MAChD,IAAIpB,KAAK,GAAG9B,YAAY,CAACG,WAAW,CAACC,MAAM,EAAE2E,IAAI,CAACc,GAAG,CAAC5C,KAAK,CAACa,MAAM,EAAE,CAAC,CAAC,CAAC;QACrE6E,MAAM,GAAG1G,QAAQ,CAACH,KAAK,CAAC;QACxBO,YAAY,GAAGP,KAAK,KAAK,EAAE,IAAIoB,OAAO,CAACyB,WAAW,IAAI7C,KAAK,CAAC7F,MAAM,GAAG,CAAC;QACtEmH,MAAM,GAAGpD,YAAY,CAACmC,UAAU,CAACc,KAAK,CAAC1M,IAAI,EAAE8L,YAAY,EAAE3I,OAAO,CAAC;MACrE,IAAIwJ,OAAO,CAAC4C,MAAM,IAAI6C,MAAM,GAAG,EAAE,EAAE;QACjCvF,MAAM,GAAG,KAAK;MAChB;MACA,OAAO;QACLwF,IAAI,EAAED,MAAM;QACZ1M,MAAM,EAAE6F,KAAK,CAAC7F,MAAM;QACpByH,KAAK,EAAEN;MACT,CAAC;IACH,CAAC;IACDV,SAAS,EAAE;EACb,CAAC,CAAC;EACF,GAAG,EAAEhN,UAAU,CAAC6M,oBAAoB,CAAC;IACnCI,IAAI,EAAE,UAAU;IAChBlI,MAAM,EAAE,SAAAA,CAAUqI,MAAM,EAAEC,KAAK,EAAE;MAC/B,IAAI4F,MAAM,GAAG5F,KAAK,CAACuF,WAAW,CAAC,CAAC;MAChC,IAAIO,MAAM;MACV,IAAIF,MAAM,GAAG,EAAE,EAAE;QACfE,MAAM,GAAGzS,MAAM,CAACuS,MAAM,GAAG,EAAE,CAAC;MAC9B,CAAC,MAAM,IAAIA,MAAM,KAAK,CAAC,EAAE;QACvBE,MAAM,GAAG,IAAI;MACf,CAAC,MAAM;QACLA,MAAM,GAAGzS,MAAM,CAACuS,MAAM,CAAC;MACzB;MACA,OAAOE,MAAM,CAACpE,QAAQ,CAAC3B,MAAM,CAACgB,MAAM,EAAE,GAAG,CAAC;IAC5C,CAAC;IACDlB,KAAK,EAAE,SAAAA,CAAUxC,MAAM,EAAE6C,KAAK,EAAEvJ,OAAO,EAAEwJ,OAAO,EAAE;MAChD,IAAI4F,GAAG,GAAG5F,OAAO,CAAC6F,SAAS,CAACf,EAAE;QAC5BlG,KAAK,GAAG9B,YAAY,CAACG,WAAW,CAACC,MAAM,EAAE2E,IAAI,CAACc,GAAG,CAAC5C,KAAK,CAACa,MAAM,EAAE,CAAC,CAAC,CAAC;QACnE6E,MAAM,GAAG1G,QAAQ,CAACH,KAAK,CAAC;QACxBO,YAAY,GAAGP,KAAK,KAAK,EAAE,IAAIoB,OAAO,CAACyB,WAAW,IAAI7C,KAAK,CAAC7F,MAAM,GAAG,CAAC;QACtEmH,MAAM,GAAGpD,YAAY,CAACmC,UAAU,CAACc,KAAK,CAAC1M,IAAI,EAAE8L,YAAY,EAAE3I,OAAO,CAAC;MACrE,IAAIiP,MAAM,KAAK,EAAE,EAAE;QACjBA,MAAM,GAAG,CAAC;QACV;QACA;QACAG,GAAG,GAAGA,GAAG,KAAK3Q,SAAS,GAAG,IAAI,GAAG2Q,GAAG;MACtC;MACA,IAAI5F,OAAO,CAAC4C,MAAM,IAAI6C,MAAM,GAAG,EAAE,EAAE;QACjCvF,MAAM,GAAG,KAAK;MAChB;MACA,OAAO;QACLwF,IAAI,EAAED,MAAM;QACZ1M,MAAM,EAAE6F,KAAK,CAAC7F,MAAM;QACpB+L,EAAE,EAAEc,GAAG;QACPpF,KAAK,EAAEN;MACT,CAAC;IACH,CAAC;IACDV,SAAS,EAAE;EACb,CAAC,CAAC;EACF,GAAG,EAAEhN,UAAU,CAAC6M,oBAAoB,CAAC;IACnCI,IAAI,EAAE,QAAQ;IACdlI,MAAM,EAAE,SAAAA,CAAUqI,MAAM,EAAEC,KAAK,EAAE;MAC/B,IAAIiG,QAAQ,GAAGjG,KAAK,CAACwF,aAAa,CAAC,CAAC;MACpC,OAAOnS,MAAM,CAAC4S,QAAQ,CAAC,CAACvE,QAAQ,CAAC3B,MAAM,CAACgB,MAAM,EAAE,GAAG,CAAC;IACtD,CAAC;IACDlB,KAAK,EAAE,SAAAA,CAAUxC,MAAM,EAAE6C,KAAK,EAAEvJ,OAAO,EAAEwJ,OAAO,EAAE;MAChD,IAAIpB,KAAK,GAAG9B,YAAY,CAACG,WAAW,CAACC,MAAM,EAAE2E,IAAI,CAACc,GAAG,CAAC5C,KAAK,CAACa,MAAM,EAAE,CAAC,CAAC,CAAC;QACrEkF,QAAQ,GAAG/G,QAAQ,CAACH,KAAK,CAAC;QAC1BO,YAAY,GAAGP,KAAK,KAAK,EAAE,IAAIoB,OAAO,CAACyB,WAAW,IAAI7C,KAAK,CAAC7F,MAAM,GAAG,CAAC;QACtEmH,MAAM,GAAGpD,YAAY,CAACmC,UAAU,CAACc,KAAK,CAAC1M,IAAI,EAAE8L,YAAY,EAAE3I,OAAO,CAAC;MACrE,IAAIwJ,OAAO,CAAC4C,MAAM,IAAIkD,QAAQ,GAAG,EAAE,EAAE;QACnC5F,MAAM,GAAG,KAAK;MAChB;MACA,OAAO;QACLnH,MAAM,EAAE6F,KAAK,CAAC7F,MAAM;QACpBgN,MAAM,EAAED,QAAQ;QAChBtF,KAAK,EAAEN;MACT,CAAC;IACH,CAAC;IACDV,SAAS,EAAE;EACb,CAAC,CAAC;EACF,GAAG,EAAEhN,UAAU,CAAC6M,oBAAoB,CAAC;IACnCI,IAAI,EAAE,QAAQ;IACdlI,MAAM,EAAE,SAAAA,CAAUqI,MAAM,EAAEC,KAAK,EAAE;MAC/B,IAAImG,QAAQ,GAAGnG,KAAK,CAACoG,aAAa,CAAC,CAAC;MACpC,OAAO/S,MAAM,CAAC8S,QAAQ,CAAC,CAACzE,QAAQ,CAAC3B,MAAM,CAACgB,MAAM,EAAE,GAAG,CAAC;IACtD,CAAC;IACDlB,KAAK,EAAE,SAAAA,CAAUxC,MAAM,EAAE6C,KAAK,EAAEvJ,OAAO,EAAEwJ,OAAO,EAAE;MAChD,IAAIwB,eAAe,GAAGK,IAAI,CAACc,GAAG,CAAC5C,KAAK,CAACa,MAAM,EAAE,CAAC,CAAC;QAC7ChC,KAAK,GAAG9B,YAAY,CAACG,WAAW,CAACC,MAAM,EAAEsE,eAAe,CAAC;QACzDrC,YAAY,GAAGP,KAAK,KAAK,EAAE,IAAIoB,OAAO,CAACyB,WAAW,IAAI7C,KAAK,CAAC7F,MAAM,GAAGyI,eAAe;QACpFwE,QAAQ,GAAGjH,QAAQ,CAACH,KAAK,CAAC;QAC1BsB,MAAM,GAAGpD,YAAY,CAACmC,UAAU,CAACc,KAAK,CAAC1M,IAAI,EAAE8L,YAAY,EAAE3I,OAAO,CAAC;MACrE,IAAIwJ,OAAO,CAAC4C,MAAM,IAAIoD,QAAQ,GAAG,EAAE,EAAE;QACnC9F,MAAM,GAAG,KAAK;MAChB;MACA,OAAO;QACLnH,MAAM,EAAE6F,KAAK,CAAC7F,MAAM;QACpBmN,MAAM,EAAEF,QAAQ;QAChBxF,KAAK,EAAEN;MACT,CAAC;IACH,CAAC;IACDV,SAAS,EAAE;EACb,CAAC,CAAC;EACF,GAAG,EAAEhN,UAAU,CAAC6M,oBAAoB,CAAC;IACnCI,IAAI,EAAE,kBAAkB;IACxBlI,MAAM,EAAE,SAAAA,CAAUqI,MAAM,EAAEC,KAAK,EAAE;MAC/B,IAAIsG,aAAa,GAAGtG,KAAK,CAACuG,kBAAkB,CAAC,CAAC;MAC9C,IAAIC,aAAa,GAAGnT,MAAM,CAACiT,aAAa,CAAC;MACzC,IAAIG,kBAAkB,GAAGD,aAAa,CAAC9E,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC;MACvD+E,kBAAkB,GAAGA,kBAAkB,CAAC1R,MAAM,CAAC,CAAC,EAAEgL,MAAM,CAACgB,MAAM,CAAC;MAChE0F,kBAAkB,GAAGA,kBAAkB,CAACC,MAAM,CAAC3G,MAAM,CAACgB,MAAM,EAAE,GAAG,CAAC;MAClE,OAAO0F,kBAAkB;IAC3B,CAAC;IACD5G,KAAK,EAAE,SAAAA,CAAUxC,MAAM,EAAE6C,KAAK,EAAEvJ,OAAO,EAAEwJ,OAAO,EAAE;MAChD,IAAIpB,KAAK,GAAG9B,YAAY,CAACG,WAAW,CAACC,MAAM,EAAE6C,KAAK,CAACa,MAAM,CAAC;QACxDxD,OAAO,GAAGwB,KAAK,CAAC7F,MAAM;QACtBoG,YAAY,GAAGa,OAAO,CAACyB,WAAW,IAAIrE,OAAO,GAAG2C,KAAK,CAACa,MAAM;MAC9DhC,KAAK,GAAGA,KAAK,CAAChK,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC;MAC1BgK,KAAK,GAAGA,KAAK,CAAC2H,MAAM,CAAC,CAAC,EAAE,GAAG,CAAC;MAC5B,IAAIJ,aAAa,GAAGpH,QAAQ,CAACH,KAAK,CAAC;MACnC,OAAO;QACL7F,MAAM,EAAEqE,OAAO;QACfoJ,WAAW,EAAEL,aAAa;QAC1B3F,KAAK,EAAE1D,YAAY,CAACmC,UAAU,CAACc,KAAK,CAAC1M,IAAI,EAAE8L,YAAY,EAAE3I,OAAO;MAClE,CAAC;IACH,CAAC;IACDgJ,SAAS,EAAE;EACb,CAAC,CAAC;EACF,GAAG,EAAEhN,UAAU,CAAC6M,oBAAoB,CAAC;IACnCI,IAAI,EAAE,iBAAiB;IACvBlI,MAAM,EAAE,SAAAA,CAAUqI,MAAM,EAAEC,KAAK,EAAEY,IAAI,EAAEjK,OAAO,EAAEvD,SAAS,EAAE;MACzD;MACA;MACA,IAAI2M,MAAM,CAACgB,MAAM,GAAG,CAAC,IAAIf,KAAK,CAAC4G,eAAe,IAAI5G,KAAK,CAAC4G,eAAe,CAAC,CAAC,EAAE;QACzE,OAAO5G,KAAK,CAAC4G,eAAe,CAAC,CAAC;MAChC,CAAC,MAAM,IAAI5G,KAAK,CAAC6G,gBAAgB,IAAI7G,KAAK,CAAC6G,gBAAgB,CAAC,CAAC,EAAE;QAC7D,OAAO7G,KAAK,CAAC6G,gBAAgB,CAAC,CAAC;MACjC;;MAEA;MACA,IAAIC,eAAe,GAAGpU,YAAY,CAACqU,eAAe,CAAC/G,KAAK,EAAE5M,SAAS,CAAC;MACpE,IAAI4T,SAAS,GAAG,KAAK;MACrB,IAAIC,SAAS,GAAGjF,IAAI,CAACkF,GAAG,CAACJ,eAAe,GAAG,EAAE,CAAC;MAC9C,IAAIK,eAAe,GAAGL,eAAe,GAAG,CAAC;MACzC,IAAIM,WAAW,GAAGpF,IAAI,CAACC,KAAK,CAACgF,SAAS,GAAG,EAAE,CAAC;MAC5C,IAAII,aAAa,GAAGrF,IAAI,CAACC,KAAK,CAACgF,SAAS,GAAG,EAAE,CAAC;MAC9C,IAAI,CAACrG,IAAI,IAAIqG,SAAS,KAAK,CAAC,EAAE;QAC5BD,SAAS,IAAIG,eAAe,GAAG,GAAG,GAAG,GAAG;QACxCH,SAAS,IAAI3T,MAAM,CAAC+T,WAAW,CAAC,CAAC1F,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC;QACjDsF,SAAS,IAAI,GAAG;QAChBA,SAAS,IAAI3T,MAAM,CAACgU,aAAa,CAAC,CAAC3F,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC;MACrD,CAAC,MAAM;QACLsF,SAAS,IAAI,GAAG;MAClB;MACA,OAAOA,SAAS;IAClB,CAAC;IACDnH,KAAK,EAAE,SAAAA,CAAUxC,MAAM,EAAE6C,KAAK,EAAEvJ,OAAO,EAAEwJ,OAAO,EAAE;MAChD,IAAI5C,OAAO,GAAG,CAAC;MACf,IAAI4B,OAAO;MACX,IAAImI,GAAG,GAAGjK,MAAM,CAACkK,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC;MAChC,IAAID,GAAG,KAAK,KAAK,IAAIA,GAAG,KAAK,KAAK,EAAE;QAClC/J,OAAO,GAAG,CAAC;MACb,CAAC,MAAM,IAAIF,MAAM,CAACkK,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,IAAI,EAAE;QAC1ChK,OAAO,GAAG,CAAC;MACb,CAAC,MAAM,IAAIF,MAAM,CAACyB,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QACnCvB,OAAO,GAAG,CAAC;QACX4B,OAAO,GAAG,CAAC;MACb,CAAC,MAAM;QACL,OAAO;UACLqI,KAAK,EAAE;QACT,CAAC;MACH;MACA,IAAInK,MAAM,CAACyB,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QAC5B,IAAI2I,SAAS,GAAGxK,YAAY,CAAC0B,OAAO,CAACtB,MAAM,CAACtI,MAAM,CAACwI,OAAO,CAAC,EAAE,IAAI,CAAC;QAClEA,OAAO,IAAIkK,SAAS,CAACvO,MAAM;QAC3BiG,OAAO,GAAGsI,SAAS,CAACzI,MAAM;MAC5B;MACA,OAAO;QACL9F,MAAM,EAAEqE,OAAO;QACfyB,MAAM,EAAEG;MACV,CAAC;IACH;EACF,CAAC,CAAC;EACF,GAAG,EAAExM,UAAU,CAAC6M,oBAAoB,CAAC;IACnCI,IAAI,EAAE,gBAAgB;IACtBlI,MAAM,EAAE,SAAAA,CAAUqI,MAAM,EAAEC,KAAK,EAAEY,IAAI,EAAEjK,OAAO,EAAEvD,SAAS,EAAE;MACzD,IAAI0T,eAAe,GAAGpU,YAAY,CAACqU,eAAe,CAAC/G,KAAK,EAAE5M,SAAS,CAAC;MACpE,IAAI6T,SAAS,GAAGjF,IAAI,CAACkF,GAAG,CAACJ,eAAe,GAAG,EAAE,CAAC;MAC9C,IAAIK,eAAe,GAAGL,eAAe,GAAG,CAAC;MACzC,IAAIM,WAAW,GAAGpF,IAAI,CAACC,KAAK,CAACgF,SAAS,GAAG,EAAE,CAAC;MAC5C,IAAII,aAAa,GAAGrF,IAAI,CAACC,KAAK,CAACgF,SAAS,GAAG,EAAE,CAAC;MAC9C,IAAID,SAAS,GAAG,EAAE;;MAElB;MACA;MACA;MACA;MACA;MACA;MACA,IAAI,CAACpG,IAAI,EAAE;QACToG,SAAS,IAAIG,eAAe,GAAG,GAAG,GAAG,GAAG;QACxCH,SAAS,IAAI3T,MAAM,CAAC+T,WAAW,CAAC,CAAC1F,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC;QACjDsF,SAAS,IAAI3T,MAAM,CAACgU,aAAa,CAAC,CAAC3F,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC;MACrD;MACA,OAAOsF,SAAS;IAClB,CAAC;IACDnH,KAAK,EAAE,SAAAA,CAAUxC,MAAM,EAAE6C,KAAK,EAAEvJ,OAAO,EAAEwJ,OAAO,EAAE;MAChD,OAAOlD,YAAY,CAAC0B,OAAO,CAACtB,MAAM,EAAE,KAAK,CAAC;IAC5C;EACF,CAAC,CAAC;EACF,GAAG,EAAE1K,UAAU,CAAC6M,oBAAoB,CAAC;IACnCI,IAAI,EAAE,iBAAiB;IACvBlI,MAAM,EAAE,SAAAA,CAAUqI,MAAM,EAAEC,KAAK,EAAEY,IAAI,EAAEjK,OAAO,EAAEvD,SAAS,EAAE;MACzD;AACN;AACA;AACA;AACA;AACA;;MAEM;AACN;AACA;AACA;AACA;AACA;;MAEM;AACN;AACA;AACA;AACA;AACA;;MAEM;AACN;AACA;AACA;AACA;AACA;;MAEM;MACA,IAAI0T,eAAe,GAAGpU,YAAY,CAACqU,eAAe,CAAC/G,KAAK,EAAE5M,SAAS,CAAC;MACpE,IAAI6T,SAAS,GAAGjF,IAAI,CAACkF,GAAG,CAACJ,eAAe,GAAG,EAAE,CAAC;MAC9C,IAAIK,eAAe,GAAGL,eAAe,GAAG,CAAC;MACzC,IAAIM,WAAW,GAAGpF,IAAI,CAACC,KAAK,CAACgF,SAAS,GAAG,EAAE,CAAC;MAC5C,IAAII,aAAa,GAAGrF,IAAI,CAACC,KAAK,CAACgF,SAAS,GAAG,EAAE,CAAC;MAC9C,IAAID,SAAS,GAAG,EAAE;MAClB,IAAI,CAACpG,IAAI,IAAIqG,SAAS,KAAK,CAAC,EAAE;QAC5BD,SAAS,IAAIG,eAAe,GAAG,GAAG,GAAG,GAAG;QACxCH,SAAS,IAAI3T,MAAM,CAAC+T,WAAW,CAAC,CAAC1F,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC;QACjD,IAAI3B,MAAM,CAACgB,MAAM,GAAG,CAAC,IAAIsG,aAAa,GAAG,CAAC,EAAE;UAC1C,IAAItH,MAAM,CAACgB,MAAM,KAAK,CAAC,IAAIhB,MAAM,CAACgB,MAAM,KAAK,CAAC,EAAE;YAC9CiG,SAAS,IAAI,GAAG;UAClB;UACAA,SAAS,IAAI3T,MAAM,CAACgU,aAAa,CAAC,CAAC3F,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC;QACrD;MACF,CAAC,MAAM;QACLsF,SAAS,IAAI,GAAG;MAClB;MACA,OAAOA,SAAS;IAClB,CAAC;IACDnH,KAAK,EAAE,SAAAA,CAAUxC,MAAM,EAAE6C,KAAK,EAAEvJ,OAAO,EAAEwJ,OAAO,EAAE;MAChD,IAAI9C,MAAM,CAACyB,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QAC5B,OAAO;UACL5F,MAAM,EAAE,CAAC;UACT8F,MAAM,EAAE;QACV,CAAC;MACH,CAAC,MAAM;QACL,OAAO/B,YAAY,CAAC0B,OAAO,CAACtB,MAAM,EAAE6C,KAAK,CAACa,MAAM,KAAK,CAAC,IAAIb,KAAK,CAACa,MAAM,KAAK,CAAC,CAAC;MAC/E;IACF;EACF,CAAC,CAAC;EACF,GAAG,EAAEpO,UAAU,CAAC6M,oBAAoB,CAAC;IACnCI,IAAI,EAAE,YAAY;IAClBlI,MAAM,EAAE,SAAAA,CAAUqI,MAAM,EAAEC,KAAK,EAAEY,IAAI,EAAEjK,OAAO,EAAEvD,SAAS,EAAE;MACzD;MACA;MACA;MACA;MACA,IAAI,CAACwN,IAAI,IAAIb,MAAM,CAACgB,MAAM,KAAK,CAAC,EAAE;QAChC;QACA;QACA;QACA,OAAOpK,OAAO,CAACxC,WAAW,CAACuT,uBAAuB,CAAC,CAAC,CAACtU,SAAS,CAAC,IAAIA,SAAS;MAC9E;MACA,OAAO,EAAE;IACX,CAAC;IACDyM,KAAK,EAAE,SAAAA,CAAUxC,MAAM,EAAE6C,KAAK,EAAEvJ,OAAO,EAAEwJ,OAAO,EAAE/M,SAAS,EAAE;MAC3D,IAAIuU,eAAe,GAAG;QACpBC,QAAQ,EAAE,EAAE;QACZ1O,MAAM,EAAE;MACV,CAAC;;MAED;MACA,IAAIgH,KAAK,CAACa,MAAM,KAAK,CAAC,EAAE;QACtB,IAAI8G,qBAAqB,GAAGlR,OAAO,CAACxC,WAAW,CAACuT,uBAAuB,CAAC,CAAC;;QAEzE;QACA,IAAIrK,MAAM,KAAKwK,qBAAqB,CAACzU,SAAS,CAAC,EAAE;UAC/C,OAAO;YACLwU,QAAQ,EAAExU,SAAS;YACnB8F,MAAM,EAAEmE,MAAM,CAACnE;UACjB,CAAC;QACH;QACA,IAAI4O,qBAAqB,GAAGnS,MAAM,CAAC6B,MAAM,CAACqQ,qBAAqB,CAAC;QAChE,IAAIE,eAAe,GAAG9K,YAAY,CAACgB,SAAS,CAACZ,MAAM,EAAEyK,qBAAqB,EAAEnR,OAAO,CAACxC,WAAW,CAACiN,aAAa,CAAC;QAC9G,IAAI2G,eAAe,CAACrJ,KAAK,KAAK,CAAC,CAAC,EAAE;UAChC,OAAO;YACLkJ,QAAQ,EAAEjS,MAAM,CAACmD,IAAI,CAAC+O,qBAAqB,CAAC,CAACE,eAAe,CAACrJ,KAAK,CAAC;YACnExF,MAAM,EAAE6O,eAAe,CAAC7O;UAC1B,CAAC;QACH;;QAEA;QACA,IAAI8O,aAAa,GAAG,EAAE;QACtB;QACA,KAAK,IAAI/G,CAAC,GAAG5D,MAAM,CAACnE,MAAM,EAAE+H,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAE;UACzC+G,aAAa,GAAG3K,MAAM,CAAC4K,KAAK,CAAC,CAAC,EAAEhH,CAAC,CAAC;UAClC,IAAIvO,YAAY,CAACwV,eAAe,CAACF,aAAa,CAAC,EAAE;YAC/CL,eAAe,CAACC,QAAQ,GAAGI,aAAa;YACxCL,eAAe,CAACzO,MAAM,GAAG8O,aAAa,CAAC9O,MAAM;YAC7C;UACF;QACF;MACF;MACA,OAAOyO,eAAe;IACxB;EACF,CAAC;AACH,CAAC;AACDhV,UAAU,CAACkE,SAAS,CAACsR,OAAO,GAAG,UAAUC,OAAO,EAAExH,IAAI,EAAExN,SAAS,EAAE;EACjE,IAAI,IAAI,CAAC6B,cAAc,CAACoT,QAAQ,EAAE;IAChC,IAAIC,IAAI,GAAG,IAAI,CAACC,cAAc,CAACH,OAAO,EAAExH,IAAI,EAAE,IAAI,CAAC3L,cAAc,CAACuT,aAAa,EAAEpV,SAAS,CAAC;IAC3F,IAAIkV,IAAI,EAAE;MACR;MACA,OAAOA,IAAI;IACb;EACF;EACA,IAAIjU,aAAa,GAAG,IAAI,CAACY,cAAc,CAACkC,YAAY;EACpD,IAAI6I,KAAK,GAAGvN,aAAa,CAACwD,WAAW,CAACmS,OAAO,EAAE/T,aAAa,CAAC;EAC7D,IAAIoU,OAAO,GAAG,EAAE;IACdvI,KAAK;IACLwI,OAAO;IACPC,OAAO;EACT,KAAK,IAAI1H,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAC7E,YAAY,CAAClD,MAAM,EAAE+H,CAAC,EAAE,EAAE;IACjDf,KAAK,GAAG,IAAI,CAAC9D,YAAY,CAAC6E,CAAC,CAAC;IAC5B0H,OAAO,GAAGzI,KAAK,CAACkF,MAAM,IAAI,EAAE;IAC5BqD,OAAO,CAACxQ,IAAI,CAAC,IAAI,CAAC6H,QAAQ,CAAC6I,OAAO,CAAC,CAACjR,MAAM,CAACwI,KAAK,EAAEF,KAAK,EAAEY,IAAI,EAAE,IAAI,EAAExN,SAAS,CAAC,CAAC;EAClF;EACAsV,OAAO,GAAGD,OAAO,CAACG,IAAI,CAAC,EAAE,CAAC;EAC1B,IAAIvW,cAAc,CAACwW,iBAAiB,CAAC,CAAC,EAAE;IACtC;IACA;IACAH,OAAO,GAAG,IAAIrV,MAAM,CAACqV,OAAO,CAAC;IAC7BA,OAAO,CAACI,UAAU,GAAG;MACnBC,MAAM,EAAE,+BAA+B;MACvCC,MAAM,EAAE,IAAI,CAAC9S,OAAO,CAAC+S,QAAQ,CAAC,CAAC;MAC/BvV,KAAK,EAAE,IAAI,CAACuB,cAAc,CAACvB,KAAK;MAChCI,OAAO,EAAE,IAAI,CAACmB,cAAc,CAACnB;IAC/B,CAAC;EACH;EACA,OAAO4U,OAAO;AAChB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA/V,UAAU,CAACkE,SAAS,CAACa,MAAM,GAAG,UAAUwR,OAAO,EAAEtI,IAAI,EAAE;EACrD,IAAIxN,SAAS;EACb,IAAI,IAAI,CAACI,IAAI,KAAKX,gBAAgB,CAACI,sBAAsB,EAAE;IACzD;IACAG,SAAS,GAAGwN,IAAI;IAChBA,IAAI,GAAG,KAAK;IACZzN,0BAA0B,CAACC,SAAS,CAAC;IACrC,IAAIA,SAAS,IAAI,CAACV,YAAY,CAACwV,eAAe,CAAC9U,SAAS,CAAC,EAAE;MACzDxB,GAAG,CAAC4V,KAAK,CAAC,iCAAiC,CAAC;MAC5C,OAAO,EAAE;IACX;EACF;EACA,IAAInT,aAAa,GAAG,IAAI,CAACY,cAAc,CAACkC,YAAY;IAClDuR,OAAO;EACT,IAAI9H,IAAI,KAAKxL,SAAS,EAAE;IACtBwL,IAAI,GAAG,IAAI,CAAC3L,cAAc,CAACiC,GAAG;EAChC;;EAEA;EACA9D,SAAS,GAAGA,SAAS,IAAInB,aAAa,CAACkX,WAAW,CAAC,CAAC;EACpD,IAAI9Q,KAAK,CAACmG,OAAO,CAAC0K,OAAO,CAAC,EAAE;IAC1B,IAAI,CAAC,IAAI,CAACjU,cAAc,CAAC+B,QAAQ,EAAE;MACjCpF,GAAG,CAAC4V,KAAK,CAAC,mEAAmE,CAAC;MAC9E,OAAO,EAAE;IACX;IACA,IAAI0B,OAAO,CAAChQ,MAAM,KAAK,CAAC,EAAE;MACxBtH,GAAG,CAAC4V,KAAK,CAAC,gEAAgE,GAAG0B,OAAO,CAAChQ,MAAM,GAAG,YAAY,CAAC;MAC3G,OAAO,EAAE;IACX;IACAgQ,OAAO,GAAGA,OAAO,CAACzM,GAAG,CAAC,UAAU2L,OAAO,EAAE;MACvC,OAAOgB,iBAAiB,CAAChB,OAAO,EAAEhV,SAAS,EAAEwN,IAAI,CAAC;IACpD,CAAC,CAAC;IACF,IAAI,IAAI,CAAC3L,cAAc,CAACgC,mBAAmB,EAAE;MAC3C,IAAIiS,OAAO,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE;QACvBtX,GAAG,CAAC4V,KAAK,CAAC,mFAAmF,CAAC;QAC9F,OAAO,EAAE;MACX;MACA,IAAI0B,OAAO,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE;QACvBR,OAAO,GAAG,IAAI,CAACP,OAAO,CAACe,OAAO,CAAC,CAAC,CAAC,EAAEtI,IAAI,EAAExN,SAAS,CAAC;MACrD;IACF;IACA,IAAIsV,OAAO,KAAKtT,SAAS,EAAE;MACzB,IAAI,CAAC8T,OAAO,CAAC/P,KAAK,CAACkQ,iBAAiB,CAAC,EAAE;QACrCzX,GAAG,CAAC4V,KAAK,CAAC,oFAAoF,CAAC;QAC/F,OAAO,EAAE;MACX;MACAkB,OAAO,GAAG,IAAI,CAACY,eAAe,CAACJ,OAAO,EAAEtI,IAAI,CAAC;IAC/C;EACF,CAAC,MAAM;IACL,IAAI,CAACyI,iBAAiB,CAACH,OAAO,CAAC,EAAE;MAC/B;MACA;MACA,IAAI,IAAI,CAAC1V,IAAI,KAAKX,gBAAgB,CAACI,sBAAsB,IAAI,IAAI,CAACgC,cAAc,CAACnB,OAAO,CAAC2D,QAAQ,CAAC,IAAI,CAAC,EAAE;QACvG,OAAO,IAAI,CAACtD,WAAW,CAACuT,uBAAuB,CAAC,CAAC,CAACtU,SAAS,CAAC,IAAIA,SAAS;MAC3E;MACAxB,GAAG,CAAC4V,KAAK,CAAC,sCAAsC,CAAC;MACjD,OAAO,EAAE;IACX;IACA,IAAI,IAAI,CAACvS,cAAc,CAAC+B,QAAQ,EAAE;MAChCpF,GAAG,CAAC4V,KAAK,CAAC,wGAAwG,CAAC;MACnH,OAAO,EAAE;IACX;IACA0B,OAAO,GAAGE,iBAAiB,CAACF,OAAO,EAAE9V,SAAS,EAAEwN,IAAI,CAAC;IACrD8H,OAAO,GAAG,IAAI,CAACP,OAAO,CAACe,OAAO,EAAEtI,IAAI,EAAExN,SAAS,CAAC;EAClD;;EAEA;EACA,IAAIiB,aAAa,KAAKrC,YAAY,CAACyP,QAAQ,IAAI,IAAI,CAACvL,OAAO,CAACqT,WAAW,CAAC,CAAC,KAAK,IAAI,EAAE;IAClFb,OAAO,GAAGA,OAAO,CAACvQ,OAAO,CAAC,cAAc,EAAE,MAAM,CAAC;EACnD;EACA,OAAOuQ,OAAO;AAChB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA/V,UAAU,CAACkE,SAAS,CAAC2S,2BAA2B,GAAG,UAAUC,WAAW,EAAE;EACxE,IAAIC,OAAO;EACX,IAAI,CAAC,IAAI,CAACzU,cAAc,CAAC6C,iBAAiB,EAAE;IAC1C,OAAO,KAAK;EACd;EACA;EACA;EACA,IAAI,IAAI,CAAC7C,cAAc,CAACyC,MAAM,EAAE;IAC9BgS,OAAO,GAAG,IAAI,CAACvV,WAAW,CAACwV,oBAAoB,CAAC,IAAI,CAAC1U,cAAc,CAACyC,MAAM,CAAC;IAC3E,OAAOgS,OAAO,CAAC1Q,IAAI,CAAC,UAAU4Q,MAAM,EAAE;MACpC,OAAOH,WAAW,CAACG,MAAM,CAACC,KAAK,CAAC;IAClC,CAAC,CAAC;EACJ;EACA,OAAO,IAAI;AACb,CAAC;AACDlX,UAAU,CAACkE,SAAS,CAACyS,eAAe,GAAG,UAAUQ,QAAQ,EAAElJ,IAAI,EAAE;EAC/D,IAAIZ,KAAK;IACPE,KAAK;IACLpK,QAAQ;IACR6S,OAAO;IACPF,OAAO,GAAG,EAAE;IACZpU,aAAa,GAAG,IAAI,CAACY,cAAc,CAACkC,YAAY;IAChDiF,YAAY,GAAG,EAAE;IACjB2N,SAAS,GAAGtX,aAAa,CAACwD,WAAW,CAAC6T,QAAQ,CAAC,CAAC,CAAC,EAAEzV,aAAa,CAAC;IACjE2V,OAAO,GAAGvX,aAAa,CAACwD,WAAW,CAAC6T,QAAQ,CAAC,CAAC,CAAC,EAAEzV,aAAa,CAAC;IAC/DoV,WAAW,GAAG,IAAI,CAACQ,cAAc,CAAC,CAACF,SAAS,EAAEC,OAAO,CAAC,CAAC;EACzD,IAAI,CAACP,WAAW,EAAE;IAChB,OAAO,IAAI,CAACtB,OAAO,CAAC2B,QAAQ,CAAC,CAAC,CAAC,EAAElJ,IAAI,CAAC;EACxC;EACA,IAAI,IAAI,CAAC4I,2BAA2B,CAACC,WAAW,CAAC,EAAE;IACjD3T,QAAQ,GAAG,IAAI,CAACiC,gBAAgB,CAAC,CAAC,CAAC;EACrC,CAAC,MAAM,IAAI,IAAI,CAAC9C,cAAc,CAACyC,MAAM,EAAE;IACrC;IACA5B,QAAQ,GAAG,IAAI,CAAC3B,WAAW,CAAC6D,wBAAwB,CAAC,IAAI,CAAC/C,cAAc,CAACyC,MAAM,EAAE+R,WAAW,EAAEpV,aAAa,CAAC;EAC9G,CAAC,MAAM;IACLyB,QAAQ,GAAG,IAAI,CAAC3B,WAAW,CAAC+D,0BAA0B,CAAC,IAAI,CAACjD,cAAc,CAACnB,OAAO,EAAEO,aAAa,CAAC;EACpG;EACA+H,YAAY,GAAG,IAAI,CAACC,oBAAoB,CAACvG,QAAQ,CAAC;EAClDkK,KAAK,GAAG+J,SAAS;EACjB,KAAK,IAAI9I,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7E,YAAY,CAAClD,MAAM,EAAE+H,CAAC,EAAE,EAAE;IAC5Cf,KAAK,GAAG9D,YAAY,CAAC6E,CAAC,CAAC;IACvB0H,OAAO,GAAGzI,KAAK,CAACkF,MAAM,IAAI,EAAE;IAC5B,IAAIlF,KAAK,CAACgK,MAAM,EAAE;MAChBlK,KAAK,GAAGgK,OAAO;IACjB;IACAvB,OAAO,CAACxQ,IAAI,CAAC,IAAI,CAAC6H,QAAQ,CAAC6I,OAAO,CAAC,CAACjR,MAAM,CAACwI,KAAK,EAAEF,KAAK,EAAEY,IAAI,EAAE,IAAI,CAAC,CAAC;EACvE;EACA,OAAO6H,OAAO,CAACG,IAAI,CAAC,EAAE,CAAC;AACzB,CAAC;AACD,IAAIuB,aAAa,GAAG;EAClBC,GAAG,EAAE,KAAK;EACVC,QAAQ,EAAE,MAAM;EAChBC,OAAO,EAAE,SAAS;EAClBC,KAAK,EAAE,OAAO;EACdC,IAAI,EAAE,MAAM;EACZC,IAAI,EAAE,KAAK;EACXC,SAAS,EAAE,WAAW;EACtBC,KAAK,EAAE,MAAM;EACbC,OAAO,EAAE,QAAQ;EACjBC,OAAO,EAAE;AACX,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAlY,UAAU,CAACkE,SAAS,CAACoT,cAAc,GAAG,UAAUa,MAAM,EAAE;EACtD,IAAIC,UAAU,GAAG,KAAK;IACpBC,KAAK,GAAG,CAAC,CAAC;EACZ,IAAI,CAACtW,sBAAsB,CAAC2J,OAAO,CAAC,UAAU4M,MAAM,EAAE;IACpD,IAAIC,aAAa,GAAG,QAAQ;MAC1BC,WAAW,GAAGD,aAAa,GAAGD,MAAM;MACpCG,WAAW,GAAGjB,aAAa,CAACc,MAAM,CAAC;MACnCI,UAAU,GAAGP,MAAM,CAAC,CAAC,CAAC,CAACK,WAAW,CAAC,CAACG,KAAK,CAACR,MAAM,CAAC,CAAC,CAAC,CAAC;MACpDS,QAAQ,GAAGT,MAAM,CAAC,CAAC,CAAC,CAACK,WAAW,CAAC,CAACG,KAAK,CAACR,MAAM,CAAC,CAAC,CAAC,CAAC;IACpD,IAAI,CAAChZ,SAAS,CAACuZ,UAAU,EAAEE,QAAQ,CAAC,EAAE;MACpCR,UAAU,GAAG,IAAI;MACjBC,KAAK,CAACI,WAAW,CAAC,GAAG,IAAI;IAC3B;EACF,CAAC,CAAC;EACF,IAAIL,UAAU,EAAE;IACd,OAAOC,KAAK;EACd;EACA,OAAO,IAAI;AACb,CAAC;AACDrY,UAAU,CAACkE,SAAS,CAAC2U,MAAM,GAAG,UAAUnO,MAAM,EAAEjB,YAAY,EAAEwE,IAAI,EAAE6K,OAAO,EAAErY,SAAS,EAAE;EACtF,IAAIiS,kBAAkB;IACpBqG,SAAS;IACTxL,KAAK;IACL6F,GAAG;IACH4F,SAAS;IACTnI,OAAO;IACPoI,SAAS;IACTC,UAAU,GAAG;MACXlL,KAAK,EAAE,IAAI;MACXmL,yBAAyB,EAAE;IAC7B,CAAC;IACDC,MAAM,GAAG,CAAC;IACVC,UAAU,GAAG;MACXtL,WAAW,EAAEtE,YAAY;MACzB4J,SAAS,EAAE6F,UAAU;MACrB9I,MAAM,EAAE0I;IACV,CAAC;IACDQ,IAAI,GAAG,IAAI;EACb,SAASC,SAASA,CAACC,MAAM,EAAE;IACzB,OAAOF,IAAI,CAACnM,QAAQ,CAACqM,MAAM,CAAC/G,MAAM,IAAI,EAAE,CAAC;EAC3C;EACA,SAASzF,SAASA,CAACwM,MAAM,EAAE;IACzB,OAAO,CAAC,CAACA,MAAM,IAAID,SAAS,CAACC,MAAM,CAAC,CAACxM,SAAS,CAACwM,MAAM,CAACpL,MAAM,CAAC;EAC/D;EACA,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7E,YAAY,CAAClD,MAAM,EAAE+H,CAAC,EAAE,EAAE;IAC5C2K,SAAS,GAAGvO,MAAM,CAACtI,MAAM,CAACgX,MAAM,CAAC;IACjC7L,KAAK,GAAG9D,YAAY,CAAC6E,CAAC,CAAC;IACvB0K,SAAS,GAAGvP,YAAY,CAAC6E,CAAC,GAAG,CAAC,CAAC;IAC/ByK,SAAS,GAAGtP,YAAY,CAAC6E,CAAC,GAAG,CAAC,CAAC;IAC/B+K,UAAU,CAACtN,KAAK,GAAGuC,CAAC;IACpB+K,UAAU,CAACpK,WAAW,GAAGjC,SAAS,CAACO,KAAK,CAAC,KAAKP,SAAS,CAACgM,SAAS,CAAC,IAAIhM,SAAS,CAAC+L,SAAS,CAAC,CAAC;IAC3FlI,OAAO,GAAG0I,SAAS,CAAChM,KAAK,CAAC,CAACL,KAAK,CAAC+L,SAAS,EAAE1L,KAAK,EAAE,IAAI,EAAE8L,UAAU,EAAE5Y,SAAS,CAAC,IAAI,CAAC,CAAC;IACrF;IACA,IAAIoQ,OAAO,CAACxE,MAAM,KAAK5J,SAAS,IAAIoO,OAAO,CAACoE,QAAQ,EAAE;MACpDpE,OAAO,CAACsI,yBAAyB,GAAG5L,KAAK,CAACkF,MAAM;IAClD;IACAyG,UAAU,GAAG9Z,MAAM,CAAC8Z,UAAU,EAAErI,OAAO,CAAC;IACxC,IAAIA,OAAO,CAAC7C,KAAK,KAAK,KAAK,EAAE;MAC3B;IACF;IACAoL,MAAM,IAAIvI,OAAO,CAACtK,MAAM,IAAI,CAAC;EAC/B;EACA2S,UAAU,CAACnN,KAAK,GAAGqN,MAAM;EACzBhG,GAAG,GAAG8F,UAAU,CAAC5G,EAAE;EACnB;EACA;EACA,IAAI4G,UAAU,CAAClG,aAAa,IAAIkG,UAAU,CAAChG,IAAI,GAAG,EAAE,IAAIgG,UAAU,CAAC3F,MAAM,IAAI,CAAC,CAAC,GAAG,GAAG,EAAE;IACrFb,kBAAkB,GAAG,IAAI,CAAClR,WAAW,CAACmR,0BAA0B,CAACuG,UAAU,CAAChG,IAAI,GAAG,EAAE,EAAEgG,UAAU,CAAC3F,MAAM,IAAI,CAAC,CAAC;IAC9GH,GAAG,GAAG8F,UAAU,CAAClG,aAAa,KAAKN,kBAAkB;EACvD;EACA,IAAIU,GAAG,EAAE;IACP8F,UAAU,CAAChG,IAAI,IAAI,EAAE;EACvB;;EAEA;EACA,IAAIgG,UAAU,CAACvH,eAAe,KAAKlP,SAAS,IAAIyW,UAAU,CAACzH,SAAS,KAAKhP,SAAS,EAAE;IAClFyW,UAAU,CAACvH,eAAe,GAAG,IAAI,CAACD,eAAe,CAACwH,UAAU,CAACzH,SAAS,CAAC;EACzE;EACA,IAAIyH,UAAU,CAAC5H,OAAO,KAAK7O,SAAS,IAAIyW,UAAU,CAAC7I,KAAK,KAAK5N,SAAS,IAAIyW,UAAU,CAAChI,GAAG,KAAKzO,SAAS,EAAE;IACtGyW,UAAU,CAAC7I,KAAK,GAAG,CAAC,GAAG6I,UAAU,CAAC5H,OAAO;IACzC4H,UAAU,CAAChI,GAAG,GAAG,CAAC;EACpB;EACA,OAAOgI,UAAU;AACnB,CAAC;AACDlZ,UAAU,CAACkE,SAAS,CAACuV,cAAc,GAAG,UAAU/O,MAAM,EAAEhJ,aAAa,EAAEuM,IAAI,EAAE6K,OAAO,EAAErY,SAAS,EAAE;EAC/F,IAAIiZ,WAAW,EAAEC,OAAO,EAAET,UAAU;;EAEpC;EACA,IAAI,CAAC9T,gBAAgB,CAACiB,IAAI,CAAC,UAAUlD,QAAQ,EAAE;IAC7C,IAAIsG,YAAY,GAAG,IAAI,CAACC,oBAAoB,CAACvG,QAAQ,CAAC;IACtDwW,OAAO,GAAGlX,SAAS;;IAEnB;IACA,KAAK,IAAI6L,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7E,YAAY,CAAClD,MAAM,EAAE+H,CAAC,EAAE,EAAE;MAC5C,IAAI7E,YAAY,CAAC6E,CAAC,CAAC,CAACiJ,MAAM,EAAE;QAC1BoC,OAAO,GAAGrL,CAAC;QACX;MACF;IACF;IACA,IAAIqL,OAAO,KAAKlX,SAAS,EAAE;MACzB;MACAyW,UAAU,GAAG,IAAI,CAACL,MAAM,CAACnO,MAAM,EAAEjB,YAAY,EAAEwE,IAAI,EAAE6K,OAAO,EAAErY,SAAS,CAAC;;MAExE;MACA,IAAIyY,UAAU,CAACnN,KAAK,KAAK,CAAC,IAAImN,UAAU,CAACnN,KAAK,GAAGrB,MAAM,CAACnE,MAAM,EAAE;QAC9D2S,UAAU,CAAClL,KAAK,GAAG,KAAK;MAC1B;MACA,IAAIkL,UAAU,CAAClL,KAAK,KAAK,KAAK,EAAE;QAC9B;MACF;MACA0L,WAAW,GAAG,CAACR,UAAU,EAAEA,UAAU,CAAC;MACtC,OAAO,IAAI;IACb,CAAC,MAAM;MACLQ,WAAW,GAAG,EAAE;;MAEhB;MACAR,UAAU,GAAG,IAAI,CAACL,MAAM,CAACnO,MAAM,EAAEjB,YAAY,CAAC6L,KAAK,CAAC,CAAC,EAAEqE,OAAO,CAAC,EAAE1L,IAAI,EAAE6K,OAAO,EAAErY,SAAS,CAAC;MAC1F,IAAIyY,UAAU,CAAClL,KAAK,KAAK,KAAK,EAAE;QAC9B;MACF;MACA0L,WAAW,CAACpU,IAAI,CAAC4T,UAAU,CAAC;MAC5B,IAAItO,OAAO,GAAGsO,UAAU,CAACnN,KAAK;;MAE9B;MACAmN,UAAU,GAAG,IAAI,CAACL,MAAM,CAACnO,MAAM,CAACkK,SAAS,CAAChK,OAAO,CAAC,EAAEnB,YAAY,CAAC6L,KAAK,CAACqE,OAAO,CAAC,EAAE1L,IAAI,EAAE6K,OAAO,EAAErY,SAAS,CAAC;;MAE1G;MACA,IAAIyY,UAAU,CAACnN,KAAK,KAAK,CAAC,IAAImN,UAAU,CAACnN,KAAK,GAAGnB,OAAO,GAAGF,MAAM,CAACnE,MAAM,EAAE;QACxE2S,UAAU,CAAClL,KAAK,GAAG,KAAK;MAC1B;MACA,IAAIkL,UAAU,CAAClL,KAAK,KAAK,KAAK,EAAE;QAC9B;MACF;MACA0L,WAAW,CAACpU,IAAI,CAAC4T,UAAU,CAAC;MAC5B,OAAO,IAAI;IACb;EACF,CAAC,CAACU,IAAI,CAAC,IAAI,CAAC,CAAC;EACb,OAAOF,WAAW;AACpB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS/J,wBAAwBA,CAACrN,cAAc,EAAE;EAChD,IAAIA,cAAc,CAACsC,qBAAqB,EAAE;IACxC,OAAOtC,cAAc,CAACsC,qBAAqB;IAC3C;EACF,CAAC,MAAM,IAAItC,cAAc,CAACoC,cAAc,KAAKjC,SAAS,IAAIH,cAAc,CAACqC,sBAAsB,KAAKlC,SAAS,EAAE;IAC7G,OAAO;MACLiC,cAAc,EAAEpC,cAAc,CAACoC,cAAc;MAC7CC,sBAAsB,EAAErC,cAAc,CAACqC;IACzC,CAAC;EACH;EACA,OAAOlC,SAAS;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIgU,iBAAiB,GAAG,SAAAA,CAAUhB,OAAO,EAAEhV,SAAS,EAAEwN,IAAI,EAAE;EAC1D;EACA,IAAI,CAACA,IAAI,IAAIyI,iBAAiB,CAACjB,OAAO,CAAC,EAAE;IACvC;IACA,OAAO1V,YAAY,CAAC0W,iBAAiB,CAAChB,OAAO,EAAEhV,SAAS,CAAC;EAC3D;EACA,OAAOgV,OAAO;AAChB,CAAC;;AAED;AACA;AACA,IAAIoE,YAAY,GAAG,SAAAA,CAAUX,UAAU,EAAExX,aAAa,EAAEuM,IAAI,EAAE6K,OAAO,EAAErY,SAAS,EAAE6B,cAAc,EAAEiB,OAAO,EAAE;EACzG,IAAI,CAAC2V,UAAU,CAAClL,KAAK,EAAE;IACrB,OAAO,IAAI;EACb;EACA,IAAIX,KAAK;IACPsB,KAAK,GAAG,OAAOuK,UAAU,CAAC1J,IAAI,KAAK,QAAQ,GAAG0J,UAAU,CAAC1J,IAAI,GAAG,IAAI;;EAEtE;EACAnC,KAAK,GAAGvN,aAAa,CAACwD,WAAW,CAAC,IAAIwU,IAAI,CAAC,CAAC,CAAC,EAAEpW,aAAa,CAAC;EAC7D2L,KAAK,CAACyM,SAAS,CAACZ,UAAU,CAACxK,GAAG,IAAI5O,aAAa,CAACia,aAAa,CAACrY,aAAa,CAAC,CAAC;EAC7E;EACA;EACA2L,KAAK,CAAC2M,cAAc,CAACrL,KAAK,EAAEuK,UAAU,CAAC7I,KAAK,IAAI,CAAC,EAAE6I,UAAU,CAAChI,GAAG,IAAI,CAAC,CAAC;EACvE7D,KAAK,CAAC4M,WAAW,CAACf,UAAU,CAAChG,IAAI,IAAI,CAAC,CAAC;EACvC7F,KAAK,CAAC6M,aAAa,CAAChB,UAAU,CAAC3F,MAAM,IAAI,CAAC,CAAC;EAC3ClG,KAAK,CAAC8M,aAAa,CAACjB,UAAU,CAACxF,MAAM,IAAI,CAAC,CAAC;EAC3CrG,KAAK,CAAC+M,kBAAkB,CAAClB,UAAU,CAAClF,WAAW,IAAI,CAAC,CAAC;EACrD,IAAI8E,OAAO,IAAI,CAACI,UAAU,CAAChI,GAAG,IAAI,CAAC,MAAM7D,KAAK,CAAC2D,UAAU,CAAC,CAAC,EAAE;IAC3D;IACA,OAAO,IAAI;EACb;EACA,IAAIkI,UAAU,CAAC1I,IAAI,KAAK/N,SAAS,KAAKyW,UAAU,CAAC7I,KAAK,KAAK5N,SAAS,IAAIyW,UAAU,CAAChI,GAAG,KAAKzO,SAAS,CAAC,EAAE;IACrG;IACA4K,KAAK,CAACgN,UAAU,CAAC;MACf7K,IAAI,EAAE0J,UAAU,CAACpJ,QAAQ,IAAIoJ,UAAU,CAAC1J,IAAI;MAC5CgB,IAAI,EAAE0I,UAAU,CAAC1I;IACnB,CAAC,EAAEjN,OAAO,EAAEoM,wBAAwB,CAACrN,cAAc,CAAC,CAAC;;IAErD;IACA,IAAI4W,UAAU,CAACvH,eAAe,KAAKlP,SAAS,EAAE;MAC5C4K,KAAK,CAACiN,UAAU,CAACjN,KAAK,CAAC2D,UAAU,CAAC,CAAC,GAAGkI,UAAU,CAACvH,eAAe,GAAG,CAAC,CAAC;IACvE;EACF;EACAtE,KAAK,GAAGA,KAAK,CAACkN,SAAS,CAAC,CAAC;;EAEzB;EACA,IAAI,CAACtM,IAAI,KAAKiL,UAAU,CAACC,yBAAyB,KAAK,GAAG,IAAID,UAAU,CAACjE,QAAQ,IAAIiE,UAAU,CAAC7M,MAAM,KAAK5J,SAAS,CAAC,EAAE;IACrH;IACA;IACA,IAAIyW,UAAU,CAACjE,QAAQ,EAAE;MACvBxU,SAAS,GAAGyY,UAAU,CAACjE,QAAQ;IACjC;IACA,IAAIxU,SAAS,EAAE;MACbyY,UAAU,CAAC7M,MAAM,GAAGtM,YAAY,CAACqU,eAAe,CAAC/G,KAAK,EAAE5M,SAAS,CAAC;IACpE;EACF;EACA,IAAIyY,UAAU,CAAC7M,MAAM,EAAE;IACrB;IACA;IACA;IACAgB,KAAK,CAAC8M,aAAa,CAAC9M,KAAK,CAACoG,aAAa,CAAC,CAAC,GAAGyF,UAAU,CAAC7M,MAAM,CAAC;EAChE;EACA,OAAOgB,KAAK;AACd,CAAC;;AAED;AACA;AACA,SAASmN,qBAAqBA,CAACC,OAAO,EAAEC,OAAO,EAAE;EAC/C,IAAID,OAAO,KAAKC,OAAO,EAAE;IACvB,OAAOD,OAAO;EAChB;EACA,IAAIE,aAAa,GAAG,CAAC,CAAC;;EAEtB;EACA3X,MAAM,CAACmD,IAAI,CAACsU,OAAO,CAAC,CAAC/O,OAAO,CAAC,UAAUjF,IAAI,EAAE;IAC3CkU,aAAa,CAAClU,IAAI,CAAC,GAAGgU,OAAO,CAAChU,IAAI,CAAC;EACrC,CAAC,CAAC;;EAEF;EACAzD,MAAM,CAACmD,IAAI,CAACuU,OAAO,CAAC,CAAChP,OAAO,CAAC,UAAUjF,IAAI,EAAE;IAC3C,IAAI,CAACkU,aAAa,CAACC,cAAc,CAACnU,IAAI,CAAC,EAAE;MACvCkU,aAAa,CAAClU,IAAI,CAAC,GAAGiU,OAAO,CAACjU,IAAI,CAAC;IACrC;EACF,CAAC,CAAC;EACF,OAAOkU,aAAa;AACtB;;AAEA;AACA,SAASE,gBAAgBA,CAACC,UAAU,EAAEC,QAAQ,EAAE;EAC9C,IAAID,UAAU,CAACE,OAAO,CAAC,CAAC,GAAGD,QAAQ,CAACC,OAAO,CAAC,CAAC,EAAE;IAC7C,OAAO,KAAK;EACd;EACA,OAAO,IAAI;AACb;;AAEA;AACA,SAAStE,iBAAiBA,CAACrJ,KAAK,EAAE;EAChC,OAAOA,KAAK,IAAI,OAAOA,KAAK,CAAC2N,OAAO,KAAK,UAAU,IAAI,CAACC,KAAK,CAAC5N,KAAK,CAAC2N,OAAO,CAAC,CAAC,CAAC;AAChF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAhb,UAAU,CAACkE,SAAS,CAACgJ,KAAK,GAAG,UAAUxC,MAAM,EAAEuD,IAAI,EAAE6K,OAAO,EAAE;EAC5D;EACA;EACA;EACA;EACA,IAAIvW,SAAS,GAAG,IAAI,CAACD,cAAc,CAACE,QAAQ,KAAKC,SAAS,IAAI,IAAI,CAACH,cAAc,CAACE,QAAQ;EAC1F,IAAIE,SAAS,GAAG,IAAI,CAACJ,cAAc,CAACK,QAAQ,KAAKF,SAAS,IAAI,IAAI,CAACH,cAAc,CAACK,QAAQ;EAC1F,IAAI,IAAI,CAAC9B,IAAI,KAAKX,gBAAgB,CAACI,sBAAsB,KAAKiC,SAAS,IAAI,CAACG,SAAS,IAAI,CAACH,SAAS,IAAIG,SAAS,CAAC,EAAE;IACjH,MAAM,IAAI/B,SAAS,CAAC,+EAA+E,CAAC;EACtG;EACA,IAAIF,SAAS;EACb,IAAIwN,IAAI,KAAKxL,SAAS,IAAI,IAAI,CAAC5B,IAAI,KAAKX,gBAAgB,CAACI,sBAAsB,EAAE;IAC/E2N,IAAI,GAAG,IAAI,CAAC3L,cAAc,CAACiC,GAAG;EAChC;EACA;EACA,IAAI2W,kBAAkB,GAAGjN,IAAI;EAC7B,IAAI,IAAI,CAACpN,IAAI,KAAKX,gBAAgB,CAACI,sBAAsB,EAAE;IACzD;IACAG,SAAS,GAAGwN,IAAI;IAChBA,IAAI,GAAG,KAAK;IACZzN,0BAA0B,CAACC,SAAS,CAAC;IACrC,IAAIA,SAAS,IAAI,CAACV,YAAY,CAACwV,eAAe,CAAC9U,SAAS,CAAC,EAAE;MACzDxB,GAAG,CAAC4V,KAAK,CAAC,iCAAiC,CAAC;MAC5C,OAAO,IAAI;IACb;EACF;EACAnK,MAAM,GAAGA,MAAM,IAAI,IAAI,GAAG,EAAE,GAAGhK,MAAM,CAACgK,MAAM,CAAC,CAACyQ,IAAI,CAAC,CAAC;EACpD;EACA;EACAzQ,MAAM,GAAG1K,UAAU,CAAC8N,UAAU,CAACpD,MAAM,CAAC;EACtC,IAAIwO,UAAU;EACd,IAAIxX,aAAa,GAAG,IAAI,CAACY,cAAc,CAACkC,YAAY;;EAEpD;EACA/D,SAAS,GAAGA,SAAS,IAAInB,aAAa,CAACkX,WAAW,CAAC,CAAC;EACpD,IAAIsC,OAAO,KAAKrW,SAAS,EAAE;IACzBqW,OAAO,GAAG,IAAI,CAACxW,cAAc,CAAClB,aAAa;EAC7C;;EAEA;EACA,IAAIM,aAAa,KAAKrC,YAAY,CAACyP,QAAQ,IAAI,IAAI,CAACvL,OAAO,CAACqT,WAAW,CAAC,CAAC,KAAK,IAAI,EAAE;IAClFlM,MAAM,GAAGA,MAAM,CAAClF,OAAO,CAAC,KAAK,EAAE,IAAI,CAAC;EACtC;EACA,IAAI,CAAC,IAAI,CAAClD,cAAc,CAAC+B,QAAQ,EAAE;IACjC,IAAIoR,OAAO,GAAG,IAAI,CAAC2F,aAAa,CAAC1Q,MAAM,EAAEuD,IAAI,CAAC;IAC9C,IAAIwH,OAAO,EAAE;MACX;MACA,OAAOA,OAAO;IAChB;IACAyD,UAAU,GAAG,IAAI,CAACL,MAAM,CAACnO,MAAM,EAAE,IAAI,CAACjB,YAAY,EAAEwE,IAAI,EAAE6K,OAAO,EAAErY,SAAS,CAAC;;IAE7E;IACA,IAAIyY,UAAU,CAACnN,KAAK,KAAK,CAAC,IAAImN,UAAU,CAACnN,KAAK,GAAGrB,MAAM,CAACnE,MAAM,EAAE;MAC9D2S,UAAU,CAAClL,KAAK,GAAG,KAAK;IAC1B;IACAyH,OAAO,GAAGoE,YAAY,CAACX,UAAU,EAAExX,aAAa,EAAEuM,IAAI,EAAE6K,OAAO,EAAErY,SAAS,EAAE,IAAI,CAAC6B,cAAc,EAAE,IAAI,CAACiB,OAAO,CAAC;IAC9G,IAAIkS,OAAO,EAAE;MACX,IAAI,IAAI,CAAC5U,IAAI,KAAKX,gBAAgB,CAACI,sBAAsB,EAAE;QACzD,IAAIsC,aAAa,GAAG,IAAI,CAACN,cAAc,CAACO,YAAY,KAAKJ,SAAS,IAAI,IAAI,CAACH,cAAc,CAACO,YAAY;QACtG;QACA,IAAI,CAACD,aAAa,IAAIL,SAAS,IAAIG,SAAS,EAAE;UAC5C,OAAO,CAAC+S,OAAO,EAAEhT,SAAS,CAAC;QAC7B,CAAC,MAAM,IAAIG,aAAa,IAAI,CAACL,SAAS,IAAI,CAACG,SAAS,EAAE;UACpD,OAAO,CAACD,SAAS,EAAEyW,UAAU,CAACjE,QAAQ,CAAC;QACzC;QACA,OAAO,CAACQ,OAAO,EAAEyD,UAAU,CAACjE,QAAQ,IAAIxS,SAAS,CAAC;MACpD;MACA,OAAOgT,OAAO;IAChB;EACF,CAAC,MAAM;IACL,IAAIiE,WAAW,GAAG,IAAI,CAACD,cAAc,CAAC/O,MAAM,EAAEhJ,aAAa,EAAEuM,IAAI,EAAE6K,OAAO,EAAErY,SAAS,CAAC;IACtF,IAAI4a,QAAQ,EAAEC,QAAQ;IACtB,IAAI5B,WAAW,IAAIA,WAAW,CAACnT,MAAM,KAAK,CAAC,EAAE;MAC3C,IAAIgV,WAAW,GAAGf,qBAAqB,CAACd,WAAW,CAAC,CAAC,CAAC,EAAEA,WAAW,CAAC,CAAC,CAAC,CAAC;MACvE,IAAI8B,WAAW,GAAGhB,qBAAqB,CAACd,WAAW,CAAC,CAAC,CAAC,EAAEA,WAAW,CAAC,CAAC,CAAC,CAAC;MACvE2B,QAAQ,GAAGxB,YAAY,CAAC0B,WAAW,EAAE7Z,aAAa,EAAEuM,IAAI,EAAE6K,OAAO,EAAErY,SAAS,EAAE,IAAI,CAAC6B,cAAc,EAAE,IAAI,CAACiB,OAAO,CAAC;MAChH+X,QAAQ,GAAGzB,YAAY,CAAC2B,WAAW,EAAE9Z,aAAa,EAAEuM,IAAI,EAAE6K,OAAO,EAAErY,SAAS,EAAE,IAAI,CAAC6B,cAAc,EAAE,IAAI,CAACiB,OAAO,CAAC;MAChH,IAAI8X,QAAQ,IAAIC,QAAQ,EAAE;QACxB,IAAI,IAAI,CAAChZ,cAAc,CAACgC,mBAAmB,IAAI+W,QAAQ,CAACL,OAAO,CAAC,CAAC,KAAKM,QAAQ,CAACN,OAAO,CAAC,CAAC,EAAE;UACxF,OAAO,CAACK,QAAQ,EAAE,IAAI,CAAC;QACzB;QACA,IAAI3N,MAAM,GAAGmN,gBAAgB,CAACQ,QAAQ,EAAEC,QAAQ,CAAC;QACjD,IAAIxC,OAAO,IAAI,CAACpL,MAAM,EAAE;UACtBzO,GAAG,CAAC4V,KAAK,CAAC,iFAAiF,CAAC;UAC5F,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC;QACrB;QACA,OAAO,CAACwG,QAAQ,EAAEC,QAAQ,CAAC;MAC7B;IACF;EACF;EACA,IAAI,IAAI,CAAC5U,gBAAgB,EAAE;IACzB,IAAI+U,KAAK;IACT,IAAI,CAAC/U,gBAAgB,CAACF,KAAK,CAAC,UAAUkV,eAAe,EAAE;MACrDD,KAAK,GAAGC,eAAe,CAACxO,KAAK,CAACxC,MAAM,EAAEwQ,kBAAkB,EAAEpC,OAAO,CAAC;MAClE,IAAIpT,KAAK,CAACmG,OAAO,CAAC4P,KAAK,CAAC,EAAE;QACxB,IAAIC,eAAe,CAAC7a,IAAI,KAAKX,gBAAgB,CAACI,sBAAsB,EAAE;UACpE,OAAO,KAAK;QACd;QACA,OAAO,EAAEmb,KAAK,CAAC,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC,CAAC;MAChC,CAAC,MAAM;QACL,OAAO,CAACA,KAAK;MACf;IACF,CAAC,CAAC;IACF,OAAOA,KAAK;EACd;EACA,IAAI,CAAC,IAAI,CAACnZ,cAAc,CAAC+B,QAAQ,EAAE;IACjC,OAAO,IAAI;EACb,CAAC,MAAM;IACL,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC;EACrB;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACArE,UAAU,CAACkE,SAAS,CAACwF,oBAAoB,GAAG,UAAUvG,QAAQ,EAAE;EAC9D,IAAI5C,gBAAgB,CAAC4C,QAAQ,CAAC,EAAE;IAC9B,OAAO5C,gBAAgB,CAAC4C,QAAQ,CAAC;EACnC;EACA,IAAIsG,YAAY,GAAG,EAAE;IACnB6E,CAAC;IACDqN,OAAO,GAAG,KAAK;IACfC,cAAc,GAAG,IAAI;IACrBC,MAAM,GAAG,EAAE;IACXC,SAAS,GAAG,EAAE;IACdC,SAAS,GAAG,CAAC,CAAC;IACdC,mBAAmB,GAAG,KAAK;EAC7B,KAAK1N,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGnL,QAAQ,CAACoD,MAAM,EAAE+H,CAAC,EAAE,EAAE;IACpC,IAAI2N,QAAQ,GAAG9Y,QAAQ,CAACgJ,MAAM,CAACmC,CAAC,CAAC;MAC/B4N,SAAS;MACTC,SAAS;MACTC,aAAa;IACf,IAAIT,OAAO,EAAE;MACX,IAAIM,QAAQ,KAAK,GAAG,EAAE;QACpBE,SAAS,GAAGhZ,QAAQ,CAACgJ,MAAM,CAACmC,CAAC,GAAG,CAAC,CAAC;QAClC8N,aAAa,GAAGjZ,QAAQ,CAACgJ,MAAM,CAACmC,CAAC,GAAG,CAAC,CAAC;QACtC4N,SAAS,GAAG/Y,QAAQ,CAACgJ,MAAM,CAACmC,CAAC,GAAG,CAAC,CAAC;QAClC;QACA,IAAI6N,SAAS,KAAK,GAAG,IAAIC,aAAa,KAAK,GAAG,EAAE;UAC9CT,OAAO,GAAG,KAAK;QACjB,CAAC,MAAM,IAAIO,SAAS,KAAK,GAAG,EAAE;UAC5B;;UAEA5N,CAAC,IAAI,CAAC;QACR,CAAC,MAAM;UACL;UACAqN,OAAO,GAAG,KAAK;UACf;QACF;MACF;MACA,IAAIE,MAAM,KAAK,MAAM,EAAE;QACrBD,cAAc,CAACtO,KAAK,IAAI2O,QAAQ;MAClC,CAAC,MAAM;QACLL,cAAc,GAAG;UACf/a,IAAI,EAAE,MAAM;UACZyM,KAAK,EAAE2O;QACT,CAAC;QACDxS,YAAY,CAACnE,IAAI,CAACsW,cAAc,CAAC;QACjCC,MAAM,GAAG,MAAM;MACjB;IACF,CAAC,MAAM;MACL,IAAII,QAAQ,KAAK,GAAG,EAAE;QACpBN,OAAO,GAAG,IAAI;MAChB,CAAC,MAAM,IAAI,IAAI,CAACxO,QAAQ,CAAC8O,QAAQ,CAAC,EAAE;QAClCH,SAAS,GAAG,IAAI,CAAC3O,QAAQ,CAAC8O,QAAQ,CAAC,CAAChP,IAAI;QACxC,IAAI4O,MAAM,KAAKC,SAAS,EAAE;UACxBF,cAAc,CAACxN,MAAM,EAAE;QACzB,CAAC,MAAM;UACLwN,cAAc,GAAG;YACf/a,IAAI,EAAEib,SAAS;YACfrJ,MAAM,EAAEwJ,QAAQ;YAChB7N,MAAM,EAAE;UACV,CAAC;UACD3E,YAAY,CAACnE,IAAI,CAACsW,cAAc,CAAC;UACjCC,MAAM,GAAGC,SAAS;UAClB,IAAI,CAACE,mBAAmB,EAAE;YACxB,IAAID,SAAS,CAACD,SAAS,CAAC,EAAE;cACxBF,cAAc,CAACrE,MAAM,GAAG,IAAI;cAC5ByE,mBAAmB,GAAG,IAAI;YAC5B,CAAC,MAAM;cACLD,SAAS,CAACD,SAAS,CAAC,GAAG,IAAI;YAC7B;UACF;QACF;MACF,CAAC,MAAM;QACL,IAAID,MAAM,KAAK,MAAM,EAAE;UACrBD,cAAc,CAACtO,KAAK,IAAI2O,QAAQ;QAClC,CAAC,MAAM;UACLL,cAAc,GAAG;YACf/a,IAAI,EAAE,MAAM;YACZyM,KAAK,EAAE2O;UACT,CAAC;UACDxS,YAAY,CAACnE,IAAI,CAACsW,cAAc,CAAC;UACjCC,MAAM,GAAG,MAAM;QACjB;MACF;IACF;EACF;EACAtb,gBAAgB,CAAC4C,QAAQ,CAAC,GAAGsG,YAAY;EACzC,OAAOA,YAAY;AACrB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAzJ,UAAU,CAACkE,SAAS,CAACkX,aAAa,GAAG,UAAU1Q,MAAM,EAAEuD,IAAI,EAAE;EAC3D,IAAIoO,SAAS,EAAErK,MAAM,EAAEsK,QAAQ,EAAEzL,OAAO,EAAE0L,MAAM;EAChD,IAAI,CAAC7R,MAAM,EAAE;IACX,OAAO,IAAI;EACb;EACA2R,SAAS,GAAG,IAAI,CAAC7a,WAAW,CAACgb,mBAAmB,CAAC,IAAI,CAAC1a,oBAAoB,EAAE,IAAI,CAACQ,cAAc,CAACrB,aAAa,CAAC;EAC9G,KAAK,IAAIqN,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+N,SAAS,CAAC9V,MAAM,EAAE+H,CAAC,EAAE,EAAE;IACzC0D,MAAM,GAAGqK,SAAS,CAAC/N,CAAC,CAAC;IACrBgO,QAAQ,GAAG,IAAI1L,MAAM,CAAC,OAAO,GAAGoB,MAAM,CAAC7Q,OAAO,CAACqE,OAAO,CAAC,OAAO,EAAE,QAAQ,CAAC,GAAG,OAAO,EAAE,GAAG,CAAC;IACzFqL,OAAO,GAAGyL,QAAQ,CAACxL,IAAI,CAACpG,MAAM,CAAC;IAC/B,IAAImG,OAAO,EAAE;MACX,IAAImB,MAAM,CAAC1E,KAAK,KAAK7K,SAAS,EAAE;QAC9B,OAAOga,mBAAmB,CAACzK,MAAM,CAAC1E,KAAK,EAAE0E,MAAM,CAAC0K,KAAK,CAAC;MACxD,CAAC,MAAM;QACLH,MAAM,GAAGhQ,QAAQ,CAACsE,OAAO,CAAC,CAAC,CAAC,CAAC;QAC7B,OAAO4L,mBAAmB,CAACF,MAAM,GAAGvK,MAAM,CAAC2K,IAAI,EAAE3K,MAAM,CAAC0K,KAAK,CAAC;MAChE;IACF;EACF;EACA,SAASD,mBAAmBA,CAACG,KAAK,EAAEC,MAAM,EAAE;IAC1C,IAAIhM,OAAO,GAAGhR,OAAO,CAACyD,WAAW,CAAC,CAAC;IACnC,IAAI2K,IAAI,EAAE;MACR;MACA4C,OAAO,CAACmJ,cAAc,CAACnJ,OAAO,CAACiM,WAAW,CAAC,CAAC,EAAEjM,OAAO,CAACkM,QAAQ,CAAC,CAAC,EAAElM,OAAO,CAACmM,OAAO,CAAC,CAAC,CAAC;MACpFnM,OAAO,CAACoJ,WAAW,CAACpJ,OAAO,CAACoM,QAAQ,CAAC,CAAC,EAAEpM,OAAO,CAACqM,UAAU,CAAC,CAAC,EAAErM,OAAO,CAACsM,UAAU,CAAC,CAAC,EAAEtM,OAAO,CAACuM,eAAe,CAAC,CAAC,CAAC;MAC9G;MACA,QAAQP,MAAM;QACZ,KAAK,QAAQ;UACXhM,OAAO,CAACsJ,aAAa,CAACtJ,OAAO,CAAC4C,aAAa,CAAC,CAAC,GAAGmJ,KAAK,CAAC;UACtD;QACF,KAAK,QAAQ;UACX/L,OAAO,CAACqJ,aAAa,CAACrJ,OAAO,CAACgC,aAAa,CAAC,CAAC,GAAG+J,KAAK,CAAC;UACtD;QACF,KAAK,MAAM;UACT/L,OAAO,CAACoJ,WAAW,CAACpJ,OAAO,CAAC+B,WAAW,CAAC,CAAC,GAAGgK,KAAK,CAAC;UAClD;QACF,KAAK,KAAK;UACR/L,OAAO,CAACyJ,UAAU,CAACzJ,OAAO,CAACG,UAAU,CAAC,CAAC,GAAG4L,KAAK,CAAC;UAChD;QACF,KAAK,MAAM;UACT/L,OAAO,CAACyJ,UAAU,CAACzJ,OAAO,CAACG,UAAU,CAAC,CAAC,GAAG4L,KAAK,GAAG,CAAC,CAAC;UACpD;QACF,KAAK,OAAO;UACV/L,OAAO,CAACwM,WAAW,CAACxM,OAAO,CAACb,WAAW,CAAC,CAAC,GAAG4M,KAAK,CAAC;UAClD;QACF,KAAK,SAAS;UACZ/L,OAAO,CAACwM,WAAW,CAACxM,OAAO,CAACb,WAAW,CAAC,CAAC,GAAG4M,KAAK,GAAG,CAAC,CAAC;UACtD;QACF,KAAK,MAAM;UACT/L,OAAO,CAACmJ,cAAc,CAACnJ,OAAO,CAACjC,cAAc,CAAC,CAAC,GAAGgO,KAAK,CAAC;UACxD;MACJ;IACF,CAAC,MAAM;MACL;MACA,QAAQC,MAAM;QACZ,KAAK,QAAQ;UACXhM,OAAO,CAACyM,UAAU,CAACzM,OAAO,CAACsM,UAAU,CAAC,CAAC,GAAGP,KAAK,CAAC;UAChD;QACF,KAAK,QAAQ;UACX/L,OAAO,CAAC0M,UAAU,CAAC1M,OAAO,CAACqM,UAAU,CAAC,CAAC,GAAGN,KAAK,CAAC;UAChD;QACF,KAAK,MAAM;UACT/L,OAAO,CAAC2M,QAAQ,CAAC3M,OAAO,CAACoM,QAAQ,CAAC,CAAC,GAAGL,KAAK,CAAC;UAC5C;QACF,KAAK,KAAK;UACR/L,OAAO,CAAC4M,OAAO,CAAC5M,OAAO,CAACmM,OAAO,CAAC,CAAC,GAAGJ,KAAK,CAAC;UAC1C;QACF,KAAK,MAAM;UACT/L,OAAO,CAAC4M,OAAO,CAAC5M,OAAO,CAACmM,OAAO,CAAC,CAAC,GAAGJ,KAAK,GAAG,CAAC,CAAC;UAC9C;QACF,KAAK,OAAO;UACV/L,OAAO,CAAC6M,QAAQ,CAAC7M,OAAO,CAACkM,QAAQ,CAAC,CAAC,GAAGH,KAAK,CAAC;UAC5C;QACF,KAAK,SAAS;UACZ/L,OAAO,CAAC6M,QAAQ,CAAC7M,OAAO,CAACkM,QAAQ,CAAC,CAAC,GAAGH,KAAK,GAAG,CAAC,CAAC;UAChD;QACF,KAAK,MAAM;UACT/L,OAAO,CAAC8M,WAAW,CAAC9M,OAAO,CAACiM,WAAW,CAAC,CAAC,GAAGF,KAAK,CAAC;UAClD;MACJ;IACF;IACA,OAAO/L,OAAO;EAChB;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA7Q,UAAU,CAACkE,SAAS,CAAC0R,cAAc,GAAG,UAAUH,OAAO,EAAExH,IAAI,EAAE2P,MAAM,EAAEnd,SAAS,EAAE;EAChF,IAAIod,QAAQ;IACVjB,KAAK;IACLkB,YAAY;IACZ3a,QAAQ;IACR;IACA4a,MAAM,GAAGtH,iBAAiB,CAAC,IAAIqB,IAAI,CAAC,CAAC,EAAErX,SAAS,CAAC;IACjDoc,MAAM,GAAG,IAAI,CAACva,cAAc,CAACtB,aAAa,IAAI,KAAK;EACrD8c,YAAY,GAAG,CAACrI,OAAO,CAACuF,OAAO,CAAC,CAAC,GAAG+C,MAAM,CAAC/C,OAAO,CAAC,CAAC,IAAI,IAAI;EAC5D,IAAI,IAAI,CAAC1Y,cAAc,CAACtB,aAAa,KAAK,MAAM,EAAE;IAChD6b,MAAM,GAAG,IAAI,CAACmB,SAAS,CAACF,YAAY,EAAE,IAAI,CAACjc,eAAe,CAAC;IAC3Dgb,MAAM,GAAGoB,iBAAiB,CAACxI,OAAO,EAAEsI,MAAM,EAAElB,MAAM,EAAEiB,YAAY,CAAC;EACnE;EACA,IAAI,CAACF,MAAM,EAAE;IACXA,MAAM,GAAG,IAAI,CAACM,QAAQ,CAACrB,MAAM,CAAC;EAChC;;EAEA;EACA,IAAIA,MAAM,KAAK,MAAM,IAAIA,MAAM,KAAK,OAAO,IAAIA,MAAM,KAAK,KAAK,EAAE;IAC/D;IACAkB,MAAM,GAAG,IAAIjG,IAAI,CAACA,IAAI,CAACvT,GAAG,CAACwZ,MAAM,CAACnP,cAAc,CAAC,CAAC,EAAEmP,MAAM,CAAC/N,WAAW,CAAC,CAAC,EAAE+N,MAAM,CAAC/M,UAAU,CAAC,CAAC,CAAC,CAAC;;IAE/F;IACA6M,QAAQ,GAAG,IAAI/F,IAAI,CAAC,CAAC,CAAC;;IAEtB;IACA;IACA+F,QAAQ,CAAC7D,cAAc,CAACvE,OAAO,CAAC7G,cAAc,CAAC,CAAC,EAAE6G,OAAO,CAACzF,WAAW,CAAC,CAAC,EAAEyF,OAAO,CAACzE,UAAU,CAAC,CAAC,CAAC;IAC9FyE,OAAO,GAAGoI,QAAQ;EACpB;EACAjB,KAAK,GAAG,IAAI,CAACuB,cAAc,CAACtB,MAAM,EAAE,CAACkB,MAAM,EAAEtI,OAAO,CAAC,CAAC;EACtD,IAAI,IAAI,CAACnT,cAAc,CAACtB,aAAa,KAAK,MAAM,KAAK4b,KAAK,GAAGgB,MAAM,CAAC,CAAC,CAAC,IAAIhB,KAAK,GAAGgB,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE;IAC5F;IACA,OAAO,IAAI;EACb;EACAza,QAAQ,GAAG,IAAI,CAAC3B,WAAW,CAAC4c,kBAAkB,CAACvB,MAAM,EAAED,KAAK,EAAEkB,YAAY,GAAG,CAAC,EAAE,IAAI,CAACxb,cAAc,CAACrB,aAAa,CAAC;EAClH,OAAO/B,aAAa,CAACiE,QAAQ,EAAE,CAACkM,IAAI,CAACkF,GAAG,CAACqI,KAAK,CAAC,CAAC,CAAC;AACnD,CAAC;AACD5c,UAAU,CAACkE,SAAS,CAACga,QAAQ,GAAG;EAC9BxK,MAAM,EAAE,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC;EACjBH,MAAM,EAAE,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC;EACjBL,IAAI,EAAE,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC;EACfhC,GAAG,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;EACZV,IAAI,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;EACbH,KAAK,EAAE,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC;EAChBb,IAAI,EAAE,CAAC,CAAC,EAAE,EAAE,EAAE;AAChB,CAAC;AACDxP,UAAU,CAACkE,SAAS,CAACma,QAAQ,GAAG;EAC9B3K,MAAM,EAAE,CAAC;EACT;EACAH,MAAM,EAAE,EAAE;EACV;EACAL,IAAI,EAAE,IAAI;EACV;EACAhC,GAAG,EAAE,KAAK;EACV;EACAV,IAAI,EAAE,MAAM;EACZ;EACAH,KAAK,EAAE,OAAO;EACd;EACAiB,OAAO,EAAE,OAAO;EAChB;EACA9B,IAAI,EAAE,QAAQ,CAAC;AACjB,CAAC;AACDxP,UAAU,CAACkE,SAAS,CAAC8Z,SAAS,GAAG,UAAUF,YAAY,EAAEQ,OAAO,EAAE;EAChE;EACA,IAAIzB,MAAM,EAAE0B,UAAU;EACtBT,YAAY,GAAGzO,IAAI,CAACkF,GAAG,CAACuJ,YAAY,CAAC;EACrC,KAAK,IAAIxP,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgQ,OAAO,CAAC/X,MAAM,EAAE+H,CAAC,EAAE,EAAE;IACvCiQ,UAAU,GAAGD,OAAO,CAAChQ,CAAC,CAAC;IACvB,IAAIwP,YAAY,IAAI,IAAI,CAACO,QAAQ,CAACE,UAAU,CAAC,EAAE;MAC7C1B,MAAM,GAAG0B,UAAU;MACnB;IACF;EACF;EACA,IAAI,CAAC1B,MAAM,EAAE;IACXA,MAAM,GAAGyB,OAAO,CAACA,OAAO,CAAC/X,MAAM,GAAG,CAAC,CAAC;EACtC;EACA,OAAOsW,MAAM;AACf,CAAC;;AAED;AACA;AACA,SAASoB,iBAAiBA,CAACxI,OAAO,EAAEsI,MAAM,EAAElB,MAAM,EAAEiB,YAAY,EAAE;EAChE,IAAIU,UAAU,GAAGnP,IAAI,CAACkF,GAAG,CAACkB,OAAO,CAACzF,WAAW,CAAC,CAAC,GAAG+N,MAAM,CAAC/N,WAAW,CAAC,CAAC,CAAC;EACvE,IAAI6M,MAAM,KAAK,MAAM,IAAI2B,UAAU,KAAK,CAAC,EAAE;IACzC;IACA;IACA,OAAO,OAAO;EAChB,CAAC,MAAM,IAAI3B,MAAM,KAAK,MAAM,IAAI2B,UAAU,KAAK,CAAC,EAAE;IAChD;IACA;IACA,IAAI/I,OAAO,CAACzE,UAAU,CAAC,CAAC,KAAK+M,MAAM,CAAC/M,UAAU,CAAC;IAC/C;IACA;IAAA,GACG8M,YAAY,GAAG,CAAC,IAAIrI,OAAO,CAACzE,UAAU,CAAC,CAAC,GAAG+M,MAAM,CAAC/M,UAAU,CAAC;IAChE;IACA;IAAA,GACG8M,YAAY,GAAG,CAAC,IAAIrI,OAAO,CAACzE,UAAU,CAAC,CAAC,GAAG+M,MAAM,CAAC/M,UAAU,CAAC,CAAC,EAAE;MACjE,OAAO,OAAO;IAChB;EACF,CAAC,MAAM,IAAI6L,MAAM,KAAK,OAAO,IAAI2B,UAAU,KAAK,CAAC,EAAE;IACjD;IACA;IACA,IAAIV,YAAY,GAAG,CAAC,IAAIrI,OAAO,CAACzE,UAAU,CAAC,CAAC,GAAG+M,MAAM,CAAC/M,UAAU,CAAC;IACjE;IACA;IAAA,GACG8M,YAAY,GAAG,CAAC,IAAIrI,OAAO,CAACzE,UAAU,CAAC,CAAC,GAAG+M,MAAM,CAAC/M,UAAU,CAAC,CAAC,EAAE;MACjE,OAAO,MAAM;IACf;EACF;EACA,OAAO6L,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS4B,aAAaA,CAACpR,KAAK,EAAEqR,WAAW,EAAE;EACzC,IAAIlG,WAAW;IACbmG,OAAO,GAAG,CAAC,UAAU,EAAE,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,EAAE,cAAc,CAAC;IACtF;IACAC,SAAS,GAAG,IAAI9G,IAAI,CAACzK,KAAK,CAAC2N,OAAO,CAAC,CAAC,CAAC;EACvC,KAAK,IAAI1M,CAAC,GAAGoQ,WAAW,EAAEpQ,CAAC,GAAGqQ,OAAO,CAACpY,MAAM,EAAE+H,CAAC,EAAE,EAAE;IACjDkK,WAAW,GAAG,QAAQ,GAAGmG,OAAO,CAACD,WAAW,CAAC;IAC7CE,SAAS,CAACpG,WAAW,CAAC,CAACG,KAAK,CAACiG,SAAS,EAAE,CAAC,CAAC,CAAC,CAAC;EAC9C;EACA,OAAOA,SAAS;AAClB;AACA,IAAIC,cAAc,GAAG;EACnBrP,IAAI,EAAE,SAAAA,CAAU4H,SAAS,EAAEC,OAAO,EAAE;IAClC,OAAOA,OAAO,CAACzI,cAAc,CAAC,CAAC,GAAGwI,SAAS,CAACxI,cAAc,CAAC,CAAC;EAC9D,CAAC;EACDyB,KAAK,EAAE,SAAAA,CAAU+G,SAAS,EAAEC,OAAO,EAAE;IACnC,OAAOA,OAAO,CAACrH,WAAW,CAAC,CAAC,GAAGoH,SAAS,CAACpH,WAAW,CAAC,CAAC,GAAG,IAAI,CAACR,IAAI,CAAC4H,SAAS,EAAEC,OAAO,CAAC,GAAG,EAAE;EAC7F,CAAC;EACD7G,IAAI,EAAE,SAAAA,CAAU4G,SAAS,EAAEC,OAAO,EAAErT,OAAO,EAAE;IAC3C,IAAI8a,QAAQ,GAAG9a,OAAO,CAAC0N,eAAe,CAAC0F,SAAS,CAAC7F,SAAS,CAAC,CAAC,CAAC;IAC7D,IAAIwN,MAAM,GAAG/a,OAAO,CAAC0N,eAAe,CAAC2F,OAAO,CAAC9F,SAAS,CAAC,CAAC,CAAC;IACzD6F,SAAS,GAAGqH,aAAa,CAACrH,SAAS,EAAE,CAAC,CAAC;IACvCC,OAAO,GAAGoH,aAAa,CAACpH,OAAO,EAAE,CAAC,CAAC;IACnC,OAAO,CAACA,OAAO,CAAC2D,OAAO,CAAC,CAAC,GAAG5D,SAAS,CAAC4D,OAAO,CAAC,CAAC,GAAG,CAAC+D,MAAM,GAAGD,QAAQ,IAAI9a,OAAO,CAACqa,QAAQ,CAACnN,GAAG,GAAG,IAAI,KAAKlN,OAAO,CAACqa,QAAQ,CAAC7N,IAAI,GAAG,IAAI,CAAC;EACvI,CAAC;EACDU,GAAG,EAAE,SAAAA,CAAUkG,SAAS,EAAEC,OAAO,EAAErT,OAAO,EAAE;IAC1CoT,SAAS,GAAGqH,aAAa,CAACrH,SAAS,EAAE,CAAC,CAAC;IACvCC,OAAO,GAAGoH,aAAa,CAACpH,OAAO,EAAE,CAAC,CAAC;IACnC,OAAO,CAACA,OAAO,CAAC2D,OAAO,CAAC,CAAC,GAAG5D,SAAS,CAAC4D,OAAO,CAAC,CAAC,KAAKhX,OAAO,CAACqa,QAAQ,CAACnN,GAAG,GAAG,IAAI,CAAC;EAClF,CAAC;EACDgC,IAAI,EAAE,SAAAA,CAAUkE,SAAS,EAAEC,OAAO,EAAErT,OAAO,EAAE;IAC3CoT,SAAS,GAAGqH,aAAa,CAACrH,SAAS,EAAE,CAAC,CAAC;IACvCC,OAAO,GAAGoH,aAAa,CAACpH,OAAO,EAAE,CAAC,CAAC;IACnC,OAAO,CAACA,OAAO,CAAC2D,OAAO,CAAC,CAAC,GAAG5D,SAAS,CAAC4D,OAAO,CAAC,CAAC,KAAKhX,OAAO,CAACqa,QAAQ,CAACnL,IAAI,GAAG,IAAI,CAAC;EACnF,CAAC;EACDK,MAAM,EAAE,SAAAA,CAAU6D,SAAS,EAAEC,OAAO,EAAErT,OAAO,EAAE;IAC7CoT,SAAS,GAAGqH,aAAa,CAACrH,SAAS,EAAE,CAAC,CAAC;IACvCC,OAAO,GAAGoH,aAAa,CAACpH,OAAO,EAAE,CAAC,CAAC;IACnC,OAAO,CAACA,OAAO,CAAC2D,OAAO,CAAC,CAAC,GAAG5D,SAAS,CAAC4D,OAAO,CAAC,CAAC,KAAKhX,OAAO,CAACqa,QAAQ,CAAC9K,MAAM,GAAG,IAAI,CAAC;EACrF,CAAC;EACDG,MAAM,EAAE,SAAAA,CAAU0D,SAAS,EAAEC,OAAO,EAAErT,OAAO,EAAE;IAC7CoT,SAAS,GAAGqH,aAAa,CAACrH,SAAS,EAAE,CAAC,CAAC;IACvCC,OAAO,GAAGoH,aAAa,CAACpH,OAAO,EAAE,CAAC,CAAC;IACnC,OAAO,CAACA,OAAO,CAAC2D,OAAO,CAAC,CAAC,GAAG5D,SAAS,CAAC4D,OAAO,CAAC,CAAC,KAAKhX,OAAO,CAACqa,QAAQ,CAAC3K,MAAM,GAAG,IAAI,CAAC;EACrF;AACF,CAAC;AACD1T,UAAU,CAACkE,SAAS,CAACwN,eAAe,GAAG,UAAUsN,UAAU,EAAE;EAC3D;EACA;EACA,IAAIC,sBAAsB,GAAGtP,wBAAwB,CAAC,IAAI,CAACrN,cAAc,CAAC;IACxE4c,eAAe;EACjB,IAAI,OAAOD,sBAAsB,KAAK,QAAQ,EAAE;IAC9CC,eAAe,GAAGD,sBAAsB,CAACva,cAAc;EACzD,CAAC,MAAM;IACLwa,eAAe,GAAGvf,aAAa,CAACwf,0BAA0B,CAACF,sBAAsB,EAAE,IAAI,CAAC1b,OAAO,CAAC,CAACmB,cAAc;EACjH;EACA,IAAI0a,gBAAgB,GAAGJ,UAAU,IAAIE,eAAe,GAAG,CAAC,CAAC;EACzD,IAAIE,gBAAgB,IAAI,CAAC,EAAE;IACzBA,gBAAgB,IAAI,CAAC;EACvB;EACA,OAAOA,gBAAgB;AACzB,CAAC;AACDpf,UAAU,CAACkE,SAAS,CAACia,cAAc,GAAG,UAAUtB,MAAM,EAAE1E,MAAM,EAAE;EAC9D,IAAIf,SAAS,GAAGe,MAAM,CAAC,CAAC,CAAC;EACzB,IAAId,OAAO,GAAGc,MAAM,CAAC,CAAC,CAAC;EACvB,OAAO9I,IAAI,CAACgQ,KAAK,CAACR,cAAc,CAAChC,MAAM,CAAC,CAACzF,SAAS,EAAEC,OAAO,EAAE,IAAI,CAAC,CAAC;AACrE,CAAC;AACDrX,UAAU,CAACkE,SAAS,CAAC0F,oBAAoB,GAAG,UAAUH,YAAY,EAAE;EAClE,IAAI,IAAI,CAACnH,cAAc,CAACoT,QAAQ,EAAE;IAChC,OAAO,EAAE,CAAC,CAAC;EACb;EACA,IAAI/L,kBAAkB,GAAG,EAAE;EAC3B,IAAI2V,QAAQ,GAAG,KAAK;EACpB,IAAIC,IAAI,GAAG,KAAK;EAChB,IAAIhS,KAAK;EACT,KAAK,IAAIe,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7E,YAAY,CAAClD,MAAM,EAAE+H,CAAC,EAAE,EAAE;IAC5Cf,KAAK,GAAG9D,YAAY,CAAC6E,CAAC,CAAC;IACvB,QAAQf,KAAK,CAAC1M,IAAI;MAChB,KAAK,MAAM;QACT,IAAI8I,kBAAkB,CAACzH,OAAO,CAACqL,KAAK,CAACD,KAAK,CAAC,GAAG,CAAC,EAAE;UAC/C3D,kBAAkB,IAAI4D,KAAK,CAACD,KAAK;QACnC;QACA;MACF,KAAK,KAAK;MACV,KAAK,MAAM;MACX,KAAK,UAAU;MACf,KAAK,iBAAiB;MACtB,KAAK,YAAY;MACjB,KAAK,UAAU;MACf,KAAK,UAAU;MACf,KAAK,UAAU;MACf,KAAK,UAAU;MACf,KAAK,QAAQ;MACb,KAAK,QAAQ;MACb,KAAK,kBAAkB;QACrB,IAAI,CAACgS,QAAQ,EAAE;UACb3V,kBAAkB,IAAI,YAAY;UAClC2V,QAAQ,GAAG,IAAI;QACjB;QACA;MACF,KAAK,OAAO;MACZ,KAAK,iBAAiB;QACpB,IAAI/R,KAAK,CAACa,MAAM,GAAG,CAAC,EAAE;UACpB,IAAI,CAACkR,QAAQ,EAAE;YACb3V,kBAAkB,IAAI,YAAY;YAClC2V,QAAQ,GAAG,IAAI;UACjB;QACF,CAAC,MAAM;UACLC,IAAI,GAAG,IAAI;QACb;QACA;MACF;QACEA,IAAI,GAAG,IAAI;QACX;IACJ;EACF;EACA,IAAIA,IAAI,EAAE;IACR5V,kBAAkB,GAAG,EAAE;EACzB;EACA,OAAOA,kBAAkB;AAC3B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA3J,UAAU,CAACkE,SAAS,CAACsb,kBAAkB,GAAG,YAAY;EACpD,IAAIC,eAAe,GAAGlgB,IAAI,CAACmgB,wBAAwB,CAAC,CAAC;EACrD,OAAOD,eAAe,CAACE,OAAO,CAAC,kBAAkB,EAAE,CAAC,IAAI,CAAC5a,MAAM,CAAC4T,KAAK,CAAC,IAAI,EAAE,IAAI,CAACiH,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;AACtG,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA5f,UAAU,CAACkE,SAAS,CAAC0b,cAAc,GAAG,YAAY;EAChD,IAAIvS,KAAK;IACPwS,SAAS,GAAGhgB,OAAO,CAACyD,WAAW,CAAC,CAAC,CAACwZ,WAAW,CAAC,CAAC;IAC/C7O,IAAI,GAAG,IAAI,CAAC3L,cAAc,CAACiC,GAAG;EAChC,SAASyY,OAAOA,CAACrO,KAAK,EAAEoB,MAAM,EAAEkB,IAAI,EAAEgC,MAAM,EAAEK,QAAQ,EAAEE,QAAQ,EAAEG,aAAa,EAAE;IAC/E,OAAO1F,IAAI,GAAGpO,OAAO,CAACyD,WAAW,CAACwU,IAAI,CAACvT,GAAG,CAACoK,KAAK,EAAEoB,MAAM,EAAEkB,IAAI,EAAEgC,MAAM,EAAEK,QAAQ,EAAEE,QAAQ,EAAEG,aAAa,CAAC,CAAC,GAAG9T,OAAO,CAACyD,WAAW,CAACqL,KAAK,EAAEoB,MAAM,EAAEkB,IAAI,EAAEgC,MAAM,EAAEK,QAAQ,EAAEE,QAAQ,EAAEG,aAAa,CAAC;EACnM;EACAtG,KAAK,GAAG2P,OAAO,CAAC6C,SAAS,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,CAAC;EACnD,IAAI,IAAI,CAAChf,IAAI,KAAKX,gBAAgB,CAACI,sBAAsB,EAAE;IACzD,OAAO,CAAC+M,KAAK,EAAE/N,aAAa,CAACkX,WAAW,CAAC,CAAC,CAAC;EAC7C;EACA,IAAI,IAAI,CAAClU,cAAc,CAAC+B,QAAQ,EAAE;IAChC,OAAO,CAAC,CAAC2Y,OAAO,CAAC6C,SAAS,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,CAAC,EAAExS,KAAK,CAAC,CAAC;EAC9D;EACA,OAAO,CAACA,KAAK,CAAC;AAChB,CAAC;AACD,MAAMyS,iBAAiB,GAAG,mCAAmC;AAC7D,MAAMC,UAAU,GAAG,KAAK;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA/f,UAAU,CAAC8N,UAAU,GAAG,UAAUpD,MAAM,EAAE;EACxC,OAAOA,MAAM,CAAClF,OAAO,CAACsa,iBAAiB,EAAE,EAAE,CAAC,CAACta,OAAO,CAACua,UAAU,EAAE,GAAG,CAAC;AACvE,CAAC;AACD,eAAe/f,UAAU","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
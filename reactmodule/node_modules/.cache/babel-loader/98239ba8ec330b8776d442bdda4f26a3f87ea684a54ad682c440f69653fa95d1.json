{"ast":null,"code":"\"use strict\";\n\nimport s from \"../../types/MovePlacement.js\";\nimport M from \"../../types/Orientation.js\";\nconst P = (t, r, l, i) => {\n    const e = Math.abs(t - r),\n      c = Math.abs(t - l),\n      o = Math.abs(t - i),\n      a = Math.min(e, c, o);\n    let n = [];\n    switch (a) {\n      case e:\n        n = [s.Before];\n        break;\n      case c:\n        n = [s.On, e < o ? s.Before : s.After];\n        break;\n      case o:\n        n = [s.After];\n        break;\n    }\n    return n;\n  },\n  I = (t, r, l) => {\n    let i = Number.POSITIVE_INFINITY,\n      e = null;\n    for (let f = 0; f < t.length; f++) {\n      const u = t[f],\n        {\n          left: T,\n          width: C,\n          top: A,\n          height: B\n        } = u.getBoundingClientRect();\n      let h;\n      l === M.Vertical ? h = A + B / 2 : h = T + C / 2;\n      const d = Math.abs(r - h);\n      d < i && (i = d, e = u);\n    }\n    if (!e) return null;\n    const {\n      width: c,\n      height: o,\n      left: a,\n      right: n,\n      top: b,\n      bottom: g\n    } = e.getBoundingClientRect();\n    let m;\n    return l === M.Vertical ? m = P(r, b, b + o / 2, g) : m = P(r, a, a + c / 2, n), {\n      element: e,\n      placements: m\n    };\n  };\nexport default I;","map":{"version":3,"names":["s","M","P","closestPlacement","t","r","l","i","e","Math","abs","c","o","a","min","n","Before","On","After","I","findClosestPosition","Number","POSITIVE_INFINITY","f","length","u","left","T","width","C","top","A","height","B","getBoundingClientRect","h","Vertical","d","right","b","bottom","g","m","element","placements"],"sources":["/home/user/projects/reactproj/node_modules/@ui5/webcomponents-base/src/util/dragAndDrop/findClosestPosition.ts"],"sourcesContent":["import MovePlacement from \"../../types/MovePlacement.js\";\nimport Orientation from \"../../types/Orientation.js\";\n\nconst closestPlacement = (point: number, beforePoint: number, centerPoint: number, afterPoint: number) => {\n\tconst distToBeforePoint = Math.abs(point - beforePoint);\n\tconst distToCenterPoint = Math.abs(point - centerPoint);\n\tconst distToAfterPoint = Math.abs(point - afterPoint);\n\tconst closestPoint = Math.min(\n\t\tdistToBeforePoint,\n\t\tdistToCenterPoint,\n\t\tdistToAfterPoint,\n\t);\n\tlet placements: Array<MovePlacement> = [];\n\n\tswitch (closestPoint) {\n\tcase distToBeforePoint:\n\t\tplacements = [MovePlacement.Before];\n\t\tbreak;\n\tcase distToCenterPoint:\n\t\tplacements = [MovePlacement.On, distToBeforePoint < distToAfterPoint ? MovePlacement.Before : MovePlacement.After];\n\t\tbreak;\n\tcase distToAfterPoint:\n\t\tplacements = [MovePlacement.After];\n\t\tbreak;\n\t}\n\n\treturn placements;\n};\n\nconst findClosestPosition = (elements: Array<HTMLElement>, point: number, layoutOrientation: Orientation) => {\n\tlet shortestDist = Number.POSITIVE_INFINITY;\n\tlet closestElement: HTMLElement | null = null;\n\n\t// determine which element is most closest to the point\n\tfor (let i = 0; i < elements.length; i++) {\n\t\tconst el = elements[i];\n\t\tconst {\n\t\t\tleft, width, top, height,\n\t\t} = el.getBoundingClientRect();\n\n\t\tlet elemCenter;\n\t\tif (layoutOrientation === Orientation.Vertical) {\n\t\t\telemCenter = top + height / 2;\n\t\t} else { // Horizontal\n\t\t\telemCenter = left + width / 2;\n\t\t}\n\n\t\tconst distanceToCenter = Math.abs(point - elemCenter);\n\n\t\tif (distanceToCenter < shortestDist) {\n\t\t\tshortestDist = distanceToCenter;\n\t\t\tclosestElement = el;\n\t\t}\n\t}\n\n\tif (!closestElement) {\n\t\treturn null;\n\t}\n\n\tconst {\n\t\twidth, height, left, right, top, bottom,\n\t} = closestElement.getBoundingClientRect();\n\tlet placements;\n\n\tif (layoutOrientation === Orientation.Vertical) {\n\t\tplacements = closestPlacement(point, top, top + height / 2, bottom);\n\t} else { // Horizontal\n\t\tplacements = closestPlacement(point, left, left + width / 2, right);\n\t}\n\n\treturn {\n\t\telement: closestElement,\n\t\tplacements,\n\t};\n};\n\nexport default findClosestPosition;\n"],"mappings":";;AAAA,OAAOA,CAAA,MAAmB;AAC1B,OAAOC,CAAA,MAAiB;AAExB,MAAMC,CAAA,GAAmBC,CAACC,CAAA,EAAeC,CAAA,EAAqBC,CAAA,EAAqBC,CAAA,KAAuB;IACzG,MAAMC,CAAA,GAAoBC,IAAA,CAAKC,GAAA,CAAIN,CAAA,GAAQC,CAAW;MAChDM,CAAA,GAAoBF,IAAA,CAAKC,GAAA,CAAIN,CAAA,GAAQE,CAAW;MAChDM,CAAA,GAAmBH,IAAA,CAAKC,GAAA,CAAIN,CAAA,GAAQG,CAAU;MAC9CM,CAAA,GAAeJ,IAAA,CAAKK,GAAA,CACzBN,CAAA,EACAG,CAAA,EACAC,CACD;IACA,IAAIG,CAAA,GAAmC,EAAC;IAExC,QAAQF,CAAA;MACR,KAAKL,CAAA;QACJO,CAAA,GAAa,CAACf,CAAA,CAAcgB,MAAM;QAClC;MACD,KAAKL,CAAA;QACJI,CAAA,GAAa,CAACf,CAAA,CAAciB,EAAA,EAAIT,CAAA,GAAoBI,CAAA,GAAmBZ,CAAA,CAAcgB,MAAA,GAAShB,CAAA,CAAckB,KAAK;QACjH;MACD,KAAKN,CAAA;QACJG,CAAA,GAAa,CAACf,CAAA,CAAckB,KAAK;QACjC;IACD;IAEA,OAAOH,CACR;EAAA;EAEMI,CAAA,GAAsBC,CAAChB,CAAA,EAA8BC,CAAA,EAAeC,CAAA,KAAmC;IAC5G,IAAIC,CAAA,GAAec,MAAA,CAAOC,iBAAA;MACtBd,CAAA,GAAqC;IAGzC,SAASe,CAAA,GAAI,GAAGA,CAAA,GAAInB,CAAA,CAASoB,MAAA,EAAQD,CAAA,IAAK;MACzC,MAAME,CAAA,GAAKrB,CAAA,CAASmB,CAAC;QACf;UACLG,IAAA,EAAAC,CAAA;UAAMC,KAAA,EAAAC,CAAA;UAAOC,GAAA,EAAAC,CAAA;UAAKC,MAAA,EAAAC;QACnB,IAAIR,CAAA,CAAGS,qBAAA,CAAsB;MAE7B,IAAIC,CAAA;MACA7B,CAAA,KAAsBL,CAAA,CAAYmC,QAAA,GACrCD,CAAA,GAAaJ,CAAA,GAAME,CAAA,GAAS,IAE5BE,CAAA,GAAaR,CAAA,GAAOE,CAAA,GAAQ;MAG7B,MAAMQ,CAAA,GAAmB5B,IAAA,CAAKC,GAAA,CAAIL,CAAA,GAAQ8B,CAAU;MAEhDE,CAAA,GAAmB9B,CAAA,KACtBA,CAAA,GAAe8B,CAAA,EACf7B,CAAA,GAAiBiB,CAAA,CAEnB;IAAA;IAEA,IAAI,CAACjB,CAAA,EACJ,OAAO;IAGR,MAAM;MACLoB,KAAA,EAAAjB,CAAA;MAAOqB,MAAA,EAAApB,CAAA;MAAQc,IAAA,EAAAb,CAAA;MAAMyB,KAAA,EAAAvB,CAAA;MAAOe,GAAA,EAAAS,CAAA;MAAKC,MAAA,EAAAC;IAClC,IAAIjC,CAAA,CAAe0B,qBAAA,CAAsB;IACzC,IAAIQ,CAAA;IAEJ,OAAIpC,CAAA,KAAsBL,CAAA,CAAYmC,QAAA,GACrCM,CAAA,GAAaxC,CAAA,CAAiBG,CAAA,EAAOkC,CAAA,EAAKA,CAAA,GAAM3B,CAAA,GAAS,GAAG6B,CAAM,IAElEC,CAAA,GAAaxC,CAAA,CAAiBG,CAAA,EAAOQ,CAAA,EAAMA,CAAA,GAAOF,CAAA,GAAQ,GAAGI,CAAK,GAG5D;MACN4B,OAAA,EAASnC,CAAA;MACToC,UAAA,EAAAF;IACD,CACD;EAAA;AAEA,eAAevB,CAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
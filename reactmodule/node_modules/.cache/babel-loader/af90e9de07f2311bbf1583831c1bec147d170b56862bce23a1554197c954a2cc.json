{"ast":null,"code":"\"use strict\";\n\nimport o from \"./isElementHidden.js\";\nimport E from \"./isElementClickable.js\";\nimport { instanceOfUI5Element as f } from \"../UI5Element.js\";\nconst r = e => e.hasAttribute(\"data-ui5-focus-trap\"),\n  c = async (e, t) => !e || o(e) ? null : m(e, !0, t),\n  d = async (e, t) => !e || o(e) ? null : m(e, !1, t),\n  T = e => e.hasAttribute(\"data-ui5-focus-redirect\") || !o(e),\n  m = async (e, t, a) => {\n    let l,\n      n,\n      s = -1;\n    e.shadowRoot ? l = t ? e.shadowRoot.firstChild : e.shadowRoot.lastChild : e instanceof HTMLSlotElement && e.assignedNodes() ? (n = e.assignedNodes(), s = t ? 0 : n.length - 1, l = n[s]) : a ? l = e : l = t ? e.firstElementChild : e.lastElementChild;\n    let i;\n    for (; l;) {\n      const u = l;\n      if (f(l) && (l = await l.getFocusDomRefAsync()), !l) return null;\n      if (l.nodeType === 1 && T(l) && !r(l)) {\n        if (E(l)) return l && typeof l.focus == \"function\" ? l : null;\n        if (i = await m(l, t), i) return i && typeof i.focus == \"function\" ? i : null;\n      }\n      l = t ? u.nextSibling : u.previousSibling, n && !n[s].contains(l) && (s = t ? s + 1 : s - 1, l = n[s]);\n    }\n    return null;\n  };\nexport { c as getFirstFocusableElement, d as getLastFocusableElement };","map":{"version":3,"names":["o","E","instanceOfUI5Element","f","r","e","hasAttribute","c","getFirstFocusableElement","t","m","d","getLastFocusableElement","T","findFocusableElement","a","l","n","s","shadowRoot","firstChild","lastChild","HTMLSlotElement","assignedNodes","length","firstElementChild","lastElementChild","i","u","getFocusDomRefAsync","nodeType","focus","nextSibling","previousSibling","contains"],"sources":["/home/user/projects/reactproj/node_modules/@ui5/webcomponents-base/src/util/FocusableElements.ts"],"sourcesContent":["import isElementHidden from \"./isElementHidden.js\";\nimport isElementClickable from \"./isElementClickable.js\";\nimport { instanceOfUI5Element } from \"../UI5Element.js\";\n\ntype FocusableElementPromise = Promise<HTMLElement | null>;\n\nconst isFocusTrap = (el: HTMLElement) => {\n\treturn el.hasAttribute(\"data-ui5-focus-trap\");\n};\n\nconst getFirstFocusableElement = async (container: HTMLElement, startFromContainer?: boolean): FocusableElementPromise => {\n\tif (!container || isElementHidden(container)) {\n\t\treturn null;\n\t}\n\n\treturn findFocusableElement(container, true, startFromContainer);\n};\n\nconst getLastFocusableElement = async (container: HTMLElement, startFromContainer?: boolean): FocusableElementPromise => {\n\tif (!container || isElementHidden(container)) {\n\t\treturn null;\n\t}\n\n\treturn findFocusableElement(container, false, startFromContainer);\n};\n\nconst isElemFocusable = (el: HTMLElement) => {\n\treturn el.hasAttribute(\"data-ui5-focus-redirect\") || !isElementHidden(el);\n};\n\nconst findFocusableElement = async (container: HTMLElement, forward: boolean, startFromContainer?: boolean): FocusableElementPromise => {\n\tlet child: HTMLElement | undefined;\n\tlet assignedElements;\n\tlet currentIndex = -1;\n\n\tif (container.shadowRoot) {\n\t\tchild = forward ? container.shadowRoot.firstChild as HTMLElement : container.shadowRoot.lastChild as HTMLElement;\n\t} else if (container instanceof HTMLSlotElement && container.assignedNodes()) {\n\t\tassignedElements = container.assignedNodes();\n\t\tcurrentIndex = forward ? 0 : assignedElements.length - 1;\n\t\tchild = assignedElements[currentIndex] as HTMLElement;\n\t} else if (startFromContainer) {\n\t\tchild = container;\n\t} else {\n\t\tchild = forward ? container.firstElementChild as HTMLElement : container.lastElementChild as HTMLElement;\n\t}\n\n\tlet focusableDescendant;\n\n\t/* eslint-disable no-await-in-loop */\n\n\twhile (child) {\n\t\tconst originalChild: HTMLElement | undefined = child;\n\n\t\tif (instanceOfUI5Element(child)) {\n\t\t\tchild = await child.getFocusDomRefAsync();\n\t\t}\n\n\t\tif (!child) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (child.nodeType === 1 && isElemFocusable(child) && !isFocusTrap(child)) {\n\t\t\tif (isElementClickable(child)) {\n\t\t\t\treturn (child && typeof child.focus === \"function\") ? child : null;\n\t\t\t}\n\n\t\t\tfocusableDescendant = await findFocusableElement(child, forward);\n\t\t\tif (focusableDescendant) {\n\t\t\t\treturn (focusableDescendant && typeof focusableDescendant.focus === \"function\") ? focusableDescendant : null;\n\t\t\t}\n\t\t}\n\n\t\tchild = forward ? originalChild.nextSibling as HTMLElement : originalChild.previousSibling as HTMLElement;\n\n\t\t// If the child element is not part of the currently assigned element,\n\t\t// we have to check the next/previous element assigned to the slot or continue with the next/previous sibling of the slot,\n\t\t// otherwise, the nextSibling/previousSibling is the next element inside the light DOM\n\t\tif (assignedElements && !assignedElements[currentIndex].contains(child)) {\n\t\t\tcurrentIndex = forward ? currentIndex + 1 : currentIndex - 1;\n\n\t\t\tchild = assignedElements[currentIndex] as HTMLElement;\n\t\t}\n\t}\n\n\t/* eslint-enable no-await-in-loop */\n\n\treturn null;\n};\n\nexport {\n\tgetFirstFocusableElement,\n\tgetLastFocusableElement,\n};\n"],"mappings":";;AAAA,OAAOA,CAAA,MAAqB;AAC5B,OAAOC,CAAA,MAAwB;AAC/B,SAASC,oBAAA,IAAAC,CAAA,QAA4B;AAIrC,MAAMC,CAAA,GAAeC,CAAA,IACbA,CAAA,CAAGC,YAAA,CAAa,qBAAqB;EAGvCC,CAAA,GAA2B,MAAAC,CAAOH,CAAA,EAAwBI,CAAA,KAC3D,CAACJ,CAAA,IAAaL,CAAA,CAAgBK,CAAS,IACnC,OAGDK,CAAA,CAAqBL,CAAA,EAAW,IAAMI,CAAkB;EAG1DE,CAAA,GAA0B,MAAAC,CAAOP,CAAA,EAAwBI,CAAA,KAC1D,CAACJ,CAAA,IAAaL,CAAA,CAAgBK,CAAS,IACnC,OAGDK,CAAA,CAAqBL,CAAA,EAAW,IAAOI,CAAkB;EAG3DI,CAAA,GAAmBR,CAAA,IACjBA,CAAA,CAAGC,YAAA,CAAa,yBAAyB,KAAK,CAACN,CAAA,CAAgBK,CAAE;EAGnEK,CAAA,GAAuB,MAAAI,CAAOT,CAAA,EAAwBI,CAAA,EAAkBM,CAAA,KAA0D;IACvI,IAAIC,CAAA;MACAC,CAAA;MACAC,CAAA,GAAe;IAEfb,CAAA,CAAUc,UAAA,GACbH,CAAA,GAAQP,CAAA,GAAUJ,CAAA,CAAUc,UAAA,CAAWC,UAAA,GAA4Bf,CAAA,CAAUc,UAAA,CAAWE,SAAA,GAC9EhB,CAAA,YAAqBiB,eAAA,IAAmBjB,CAAA,CAAUkB,aAAA,CAAc,KAC1EN,CAAA,GAAmBZ,CAAA,CAAUkB,aAAA,CAAc,GAC3CL,CAAA,GAAeT,CAAA,GAAU,IAAIQ,CAAA,CAAiBO,MAAA,GAAS,GACvDR,CAAA,GAAQC,CAAA,CAAiBC,CAAY,KAC3BH,CAAA,GACVC,CAAA,GAAQX,CAAA,GAERW,CAAA,GAAQP,CAAA,GAAUJ,CAAA,CAAUoB,iBAAA,GAAmCpB,CAAA,CAAUqB,gBAAA;IAG1E,IAAIC,CAAA;IAIJ,OAAOX,CAAA,GAAO;MACb,MAAMY,CAAA,GAAyCZ,CAAA;MAM/C,IAJIb,CAAA,CAAqBa,CAAK,MAC7BA,CAAA,GAAQ,MAAMA,CAAA,CAAMa,mBAAA,CAAoB,IAGrC,CAACb,CAAA,EACJ,OAAO;MAGR,IAAIA,CAAA,CAAMc,QAAA,KAAa,KAAKjB,CAAA,CAAgBG,CAAK,KAAK,CAACZ,CAAA,CAAYY,CAAK,GAAG;QAC1E,IAAIf,CAAA,CAAmBe,CAAK,GAC3B,OAAQA,CAAA,IAAS,OAAOA,CAAA,CAAMe,KAAA,IAAU,aAAcf,CAAA,GAAQ;QAI/D,IADAW,CAAA,GAAsB,MAAMjB,CAAA,CAAqBM,CAAA,EAAOP,CAAO,GAC3DkB,CAAA,EACH,OAAQA,CAAA,IAAuB,OAAOA,CAAA,CAAoBI,KAAA,IAAU,aAAcJ,CAAA,GAAsB,IAE1G;MAAA;MAEAX,CAAA,GAAQP,CAAA,GAAUmB,CAAA,CAAcI,WAAA,GAA6BJ,CAAA,CAAcK,eAAA,EAKvEhB,CAAA,IAAoB,CAACA,CAAA,CAAiBC,CAAY,EAAEgB,QAAA,CAASlB,CAAK,MACrEE,CAAA,GAAeT,CAAA,GAAUS,CAAA,GAAe,IAAIA,CAAA,GAAe,GAE3DF,CAAA,GAAQC,CAAA,CAAiBC,CAAY,EAEvC;IAAA;IAIA,OAAO,IACR;EAAA;AAEA,SACCX,CAAA,IAAAC,wBAAA,EACAG,CAAA,IAAAC,uBAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar RangeSlider_1;\nimport customElement from \"@ui5/webcomponents-base/dist/decorators/customElement.js\";\nimport property from \"@ui5/webcomponents-base/dist/decorators/property.js\";\nimport { getI18nBundle } from \"@ui5/webcomponents-base/dist/i18nBundle.js\";\nimport { isEscape, isHome, isEnd } from \"@ui5/webcomponents-base/dist/Keys.js\";\nimport SliderBase from \"./SliderBase.js\";\nimport Icon from \"./Icon.js\";\nimport RangeSliderTemplate from \"./generated/templates/RangeSliderTemplate.lit.js\";\n// Texts\nimport { RANGE_SLIDER_ARIA_DESCRIPTION, RANGE_SLIDER_START_HANDLE_DESCRIPTION, RANGE_SLIDER_END_HANDLE_DESCRIPTION } from \"./generated/i18n/i18n-defaults.js\";\n// Styles\nimport rangeSliderStyles from \"./generated/themes/RangeSlider.css.js\";\n/**\n * @class\n *\n * ### Overview\n * Represents a numerical interval and two handles (grips) to select a sub-range within it.\n * The purpose of the component to enable visual selection of sub-ranges within a given interval.\n *\n * ### Structure\n * The most important properties of the Range Slider are:\n *\n * - min - The minimum value of the slider range.\n * - max - The maximum value of the slider range.\n * - value - The current value of the slider.\n * - step - Determines the increments in which the slider will move.\n * - showTooltip - Determines if a tooltip should be displayed above the handle.\n * - showTickmarks - Displays a visual divider between the step values.\n * - labelInterval - Labels some or all of the tickmarks with their values.\n *\n * #### Notes:\n *\n * - The right and left handle can be moved individually and their positions could therefore switch.\n * - The entire range can be moved along the interval.\n *\n * ### Usage\n * The most common use case is to select and move sub-ranges on a continuous numerical scale.\n *\n * ### Responsive Behavior\n * You can move the currently selected range by clicking on it and dragging it along the interval.\n *\n * ### Keyboard Handling\n *\n * - `Left or Down Arrow` - Moves a component's handle or the entire selection one step to the left;\n * - `Right or Up Arrow` - Moves a component's handle or the entire selection one step to the right;\n * - `Left or Down Arrow + Ctrl/Cmd` - Moves a component's handle to the left or the entire range with step equal to 1/10th of the entire range;\n * - `Right or Up Arrow + Ctrl/Cmd` - Moves a component's handle to the right or the entire range with step equal to 1/10th of the entire range;\n * - `Plus` - Same as `Right or Up Arrow`;\n * - `Minus` - Same as `Left or Down Arrow`;\n * - `Home` - Moves the entire selection or the selected handle to the beginning of the component's range;\n * - `End` - Moves the entire selection or the selected handle to the end of the component's range;\n * - `Page Up` - Same as `Right or Up Arrow + Ctrl/Cmd`;\n * - `Page Down` - Same as `Left or Down Arrow + Ctrl/Cmd`;\n * - `Escape` - Resets the `startValue` and `endValue` properties to the values prior the component focusing;\n *\n * ### ES6 Module Import\n *\n * `import \"@ui5/webcomponents/dist/RangeSlider.js\";`\n * @constructor\n * @extends SliderBase\n * @since 1.0.0-rc.11\n * @public\n * @csspart progress-container - Used to style the progress container, the horizontal bar that visually represents the range between the minimum and maximum values, of the `ui5-range-slider`.\n * @csspart progress-bar - Used to style the progress bar, which shows the progress of the `ui5-range-slider`.\n * @csspart handle - Used to style the handles of the `ui5-range-slider`.\n */\nlet RangeSlider = RangeSlider_1 = class RangeSlider extends SliderBase {\n  get formFormattedValue() {\n    const formData = new FormData();\n    if (!this.name) {\n      return formData;\n    }\n    formData.append(this.name, this.startValue.toString());\n    formData.append(this.name, this.endValue.toString());\n    return formData;\n  }\n  constructor() {\n    super();\n    /**\n     * Defines start point of a selection - position of a first handle on the slider.\n     * @default 0\n     * @formEvents change input\n     * @formProperty\n     * @public\n     */\n    this.startValue = 0;\n    /**\n     * Defines end point of a selection - position of a second handle on the slider.\n     * @default 100\n     * @formEvents change input\n     * @formProperty\n     * @public\n     */\n    this.endValue = 100;\n    this.rangePressed = false;\n    this._isPressInCurrentRange = false;\n    this._handeIsPressed = false;\n    this._reversedValues = false;\n    this._stateStorage.startValue = undefined;\n    this._stateStorage.endValue = undefined;\n  }\n  get tooltipStartValue() {\n    const ctor = this.constructor;\n    const stepPrecision = ctor._getDecimalPrecisionOfNumber(this._effectiveStep);\n    return this.startValue.toFixed(stepPrecision);\n  }\n  get tooltipEndValue() {\n    const ctor = this.constructor;\n    const stepPrecision = ctor._getDecimalPrecisionOfNumber(this._effectiveStep);\n    return this.endValue.toFixed(stepPrecision);\n  }\n  get _ariaDisabled() {\n    return this.disabled || undefined;\n  }\n  get _ariaLabelledByText() {\n    return RangeSlider_1.i18nBundle.getText(RANGE_SLIDER_ARIA_DESCRIPTION);\n  }\n  get _ariaHandlesText() {\n    const isRTL = this.effectiveDir === \"rtl\";\n    const isReversed = this._areValuesReversed();\n    const ariaHandlesText = {};\n    if (isRTL && !isReversed || !isRTL && isReversed) {\n      ariaHandlesText.startHandleText = RangeSlider_1.i18nBundle.getText(RANGE_SLIDER_END_HANDLE_DESCRIPTION);\n      ariaHandlesText.endHandleText = RangeSlider_1.i18nBundle.getText(RANGE_SLIDER_START_HANDLE_DESCRIPTION);\n    } else {\n      ariaHandlesText.startHandleText = RangeSlider_1.i18nBundle.getText(RANGE_SLIDER_START_HANDLE_DESCRIPTION);\n      ariaHandlesText.endHandleText = RangeSlider_1.i18nBundle.getText(RANGE_SLIDER_END_HANDLE_DESCRIPTION);\n    }\n    return ariaHandlesText;\n  }\n  get _ariaValueNow() {\n    return Math.abs(this.endValue - this.startValue);\n  }\n  /**\n   * Check if the previously saved state is outdated. That would mean\n   * either it is the initial rendering or that a property has been changed\n   * programmatically - because the previous state is always updated in\n   * the interaction handlers.\n   *\n   * Normalize current properties, update the previously stored state.\n   * Update the visual UI representation of the Slider.\n   *\n   */\n  onBeforeRendering() {\n    if (this.startValue > this.endValue) {\n      const affectedValue = this._valueAffected === \"startValue\" ? \"endValue\" : \"startValue\";\n      this._swapValues();\n      this._setAffectedValue(affectedValue);\n      this.update(affectedValue, this.startValue, this.endValue);\n    }\n    if (!this.isCurrentStateOutdated()) {\n      return;\n    }\n    this.notResized = true;\n    this.syncUIAndState();\n    this._updateHandlesAndRange(0);\n  }\n  syncUIAndState() {\n    // Validate step and update the stored state for the step property.\n    if (this.isPropertyUpdated(\"step\")) {\n      this._validateStep(this.step);\n      this.storePropertyState(\"step\");\n    }\n    // Recalculate the tickmarks and labels and update the stored state.\n    if (this.isPropertyUpdated(\"min\", \"max\", \"startValue\", \"endValue\")) {\n      this.storePropertyState(\"min\", \"max\");\n      // Here the value props are changed programmatically (not by user interaction)\n      // and it won't be \"stepified\" (rounded to the nearest step). 'Clip' them within\n      // min and max bounderies and update the previous state reference.\n      const normalizedStartValue = SliderBase.clipValue(this.startValue, this._effectiveMin, this._effectiveMax);\n      this.startValue = normalizedStartValue;\n      this.updateStateStorageAndFireInputEvent(\"startValue\");\n      this.storePropertyState(\"startValue\");\n      const normalizedEndValue = SliderBase.clipValue(this.endValue, this._effectiveMin, this._effectiveMax);\n      this.endValue = normalizedEndValue;\n      this.updateStateStorageAndFireInputEvent(\"endValue\");\n      this.storePropertyState(\"endValue\");\n    }\n    // Labels must be updated if any of the min/max/step/labelInterval props are changed\n    if (this.labelInterval && this.showTickmarks) {\n      this._createLabels();\n    }\n    // Update the stored state for the labelInterval, if changed\n    if (this.isPropertyUpdated(\"labelInterval\")) {\n      this.storePropertyState(\"labelInterval\");\n    }\n  }\n  _onfocusin() {\n    // If this is the initial focusin of the component save its initial\n    // value properties so they could be restored on ESC key press\n    if (!this._endValueInitial) {\n      this._startValueInitial = this.startValue;\n      this._endValueInitial = this.endValue;\n    }\n    if (this.showTooltip) {\n      this._tooltipVisibility = SliderBase.TOOLTIP_VISIBILITY.VISIBLE;\n    }\n  }\n  /**\n   * Handles focus out event of the focusable components inner elements.\n   * Prevent focusout when the focus is getting initially set within the slider before the\n   * slider customElement itself is finished focusing.\n   *\n   * Prevents the focus from leaving the Range Slider when the focus is managed between\n   * its inner elements in result of user interactions.\n   *\n   * Resets the stored Range Slider's initial values saved when it was first focused\n   * @private\n   */\n  _onfocusout() {\n    if (this._isFocusing()) {\n      this._preventFocusOut();\n      return;\n    }\n    this._setAffectedValue(undefined);\n    this._startValueInitial = undefined;\n    this._endValueInitial = undefined;\n    if (this.showTooltip) {\n      this._tooltipVisibility = SliderBase.TOOLTIP_VISIBILITY.HIDDEN;\n    }\n  }\n  /**\n  * Handles keyup logic. If one of the handles came across the other\n  * swap the start and end values. Reset the affected value by the finished\n  * user interaction.\n  * @private\n  */\n  _onkeyup() {\n    super._onkeyup();\n    this._setAffectedValue(undefined);\n    if (this.startValue !== this._startValueAtBeginningOfAction || this.endValue !== this._endValueAtBeginningOfAction) {\n      this.fireEvent(\"change\");\n    }\n    this._startValueAtBeginningOfAction = undefined;\n    this._endValueAtBeginningOfAction = undefined;\n  }\n  _handleActionKeyPress(e) {\n    this._startValueAtBeginningOfAction = this.startValue;\n    this._endValueAtBeginningOfAction = this.endValue;\n    if (isEscape(e)) {\n      this.update(undefined, this._startValueInitial, this._endValueInitial);\n      return;\n    }\n    // Set the target of the interaction based on the focused inner element\n    this._setAffectedValueByFocusedElement();\n    const min = this._effectiveMin;\n    const max = this._effectiveMax;\n    const affectedValue = this._valueAffected;\n    // If home/end key is pressed and no single handle is focused the active element\n    // is the range selection - update both start and end values. Otherwise, if 'home'\n    // is pressed the 'startValue'will be used for the start-handle offset calculation,\n    // if 'End' is pressed - the 'endValue' will be used for the end-handle update.\n    if ((isEnd(e) || isHome(e)) && !affectedValue) {\n      this._homeEndForSelectedRange(e, isHome(e) ? \"startValue\" : \"endValue\", min, max);\n      return;\n    }\n    // Calculate how much the value should be increased/decreased based on the action key\n    const newValueOffset = this._handleActionKeyPressBase(e, affectedValue);\n    if (!newValueOffset) {\n      return;\n    }\n    // Update a single value if one of the handles is focused or the range if not already at min or max\n    const ctor = this.constructor;\n    if (affectedValue && !this._isPressInCurrentRange) {\n      const propValue = this[affectedValue];\n      const newValue = ctor.clipValue(newValueOffset + propValue, min, max);\n      this.update(affectedValue, newValue, undefined);\n    } else if (newValueOffset < 0 && this.startValue > min || newValueOffset > 0 && this.endValue < max) {\n      const newStartValue = ctor.clipValue(newValueOffset + this.startValue, min, max);\n      const newEndValue = ctor.clipValue(newValueOffset + this.endValue, min, max);\n      this.update(affectedValue, newStartValue, newEndValue);\n    }\n  }\n  /**\n   * Determines affected value (start/end) depending on the currently\n   * active inner element within the Range Slider - used in the keyboard handling.\n   * @private\n   */\n  _setAffectedValueByFocusedElement() {\n    if (this.shadowRoot.activeElement === this._startHandle) {\n      this._setAffectedValue(\"startValue\");\n    }\n    if (this.shadowRoot.activeElement === this._endHandle) {\n      this._setAffectedValue(\"endValue\");\n    }\n    if (this.shadowRoot.activeElement === this._progressBar) {\n      this._setAffectedValue(undefined);\n    }\n    this._setIsPressInCurrentRange(!this._valueAffected);\n  }\n  /**\n   * Calculates the start and end values when the 'Home\" or 'End' keys\n   * are pressed on the selected range bar.\n   * @private\n   */\n  _homeEndForSelectedRange(e, affectedValue, min, max) {\n    const newValueOffset = this._handleActionKeyPressBase(e, affectedValue);\n    const ctor = this.constructor;\n    const newStartValue = ctor.clipValue(newValueOffset + this.startValue, min, max);\n    const newEndValue = ctor.clipValue(newValueOffset + this.endValue, min, max);\n    this.update(undefined, newStartValue, newEndValue);\n  }\n  /**\n   * Update values, stored inner state and the visual UI representation of the component.\n   * If no specific type of value property is passed - the range is selected - update both handles,\n   * otherwise update the handle corresponding to the affected by the user interacton value prop.\n   * @private\n   */\n  update(affectedValue, startValue, endValue) {\n    if (!affectedValue) {\n      this.startValue = startValue;\n      this.updateStateStorageAndFireInputEvent(\"startValue\");\n      this.endValue = endValue;\n      this.updateStateStorageAndFireInputEvent(\"endValue\");\n      this._updateHandlesAndRange(0);\n    } else {\n      const newValue = endValue && affectedValue === \"endValue\" ? endValue : startValue;\n      this._updateHandlesAndRange(newValue || 0);\n      if (affectedValue === \"startValue\") {\n        this.startValue = newValue;\n        this.updateStateStorageAndFireInputEvent(\"startValue\");\n      }\n      if (affectedValue === \"endValue\") {\n        this.endValue = newValue;\n        this.updateStateStorageAndFireInputEvent(\"endValue\");\n      }\n    }\n  }\n  /**\n   * Called when the user starts interacting with the slider\n   * @private\n   */\n  _onmousedown(e) {\n    // If step is 0 no interaction is available because there is no constant\n    // (equal for all user environments) quantitative representation of the value\n    if (this.disabled || this._effectiveStep === 0) {\n      return;\n    }\n    // Calculate the new value from the press position of the event\n    const newValue = this.handleDownBase(e);\n    // Determine the rest of the needed details from the start of the interaction.\n    this._saveInteractionStartData(e, newValue);\n    this.rangePressed = this._isPressInCurrentRange;\n    // Do not yet update the RangeSlider if press is in range or over a handle.\n    if (this._isPressInCurrentRange || this._handeIsPressed) {\n      this._handeIsPressed = false;\n      return;\n    }\n    // Update Slider UI and internal state\n    this.update(this._valueAffected, newValue, undefined);\n  }\n  /**\n   * Determines and saves needed values from the start of the interaction:\n   *\n   * Is the value calculated is within the currently selected range;\n   * Initial pageX position of the start handle affected by the interaction;\n   * Initial pageX value of the pressed postion;\n   * Affected value property by the action;\n   * @private\n   */\n  _saveInteractionStartData(e, newValue) {\n    const progressBarDom = this.shadowRoot.querySelector(\".ui5-slider-progress\").getBoundingClientRect();\n    // Save the state of the value properties on the start of the interaction\n    this._startValueAtBeginningOfAction = this.startValue;\n    this._endValueAtBeginningOfAction = this.endValue;\n    // Save the initial press point coordinates (position)\n    const ctor = this.constructor;\n    this._initialPageXPosition = ctor.getPageXValueFromEvent(e);\n    // Which element of the Range Slider is pressed and which value property to be modified on further interaction\n    this._pressTargetAndAffectedValue(this._initialPageXPosition, newValue);\n    // Use the progress bar to save the initial coordinates of the start-handle when the interaction begins.\n    this._initialStartHandlePageX = this.directionStart === \"left\" ? progressBarDom.left : progressBarDom.right;\n  }\n  /**\n   * Called when the user moves the slider\n   * @private\n   */\n  _handleMove(e) {\n    e.preventDefault();\n    // If 'step' is 0 no interaction is available as there is no constant quantitative representation of the value\n    if (this.disabled || this._effectiveStep === 0) {\n      return;\n    }\n    // Update UI and state when dragging a single Range Slider handle\n    if (!this._isPressInCurrentRange) {\n      this._updateValueOnHandleDrag(e);\n      return;\n    }\n    // Updates UI and state when dragging of the whole selected range\n    this._updateValueOnRangeDrag(e);\n  }\n  /**\n   * Updates UI and state when dragging a single Range Slider handle\n   * @private\n   */\n  _updateValueOnHandleDrag(event) {\n    const ctor = this.constructor;\n    const newValue = ctor.getValueFromInteraction(event, this._effectiveStep, this._effectiveMin, this._effectiveMax, this.getBoundingClientRect(), this.directionStart);\n    this.update(this._valueAffected, newValue, undefined);\n  }\n  /**\n   * Updates UI and state when dragging of the whole selected range\n   * @private\n   */\n  _updateValueOnRangeDrag(event) {\n    // Calculate the new 'start' and 'end' values from the offset between the original press point and the current position of the mouse\n    const ctor = this.constructor;\n    const currentPageXPos = ctor.getPageXValueFromEvent(event);\n    const newValues = this._calculateRangeOffset(currentPageXPos, this._initialStartHandlePageX);\n    // No matter the which value is set as the one to be modified (by prev. user action) we want to modify both of them\n    this._setAffectedValue(undefined);\n    // Update the UI and the state according to the calculated new values\n    this.update(undefined, newValues[0], newValues[1]);\n  }\n  _handleUp() {\n    this._setAffectedValueByFocusedElement();\n    this._setAffectedValue(undefined);\n    if (this.startValue !== this._startValueAtBeginningOfAction || this.endValue !== this._endValueAtBeginningOfAction) {\n      this.fireEvent(\"change\");\n    }\n    this._setIsPressInCurrentRange(false);\n    this.handleUpBase();\n    this.rangePressed = false;\n    this._startValueAtBeginningOfAction = undefined;\n    this._endValueAtBeginningOfAction = undefined;\n  }\n  /**\n   * Determines where the press occured and which values of the Range Slider\n   * handles should be updated on further interaction.\n   *\n   * If the press is not in the selected range or over one of the Range Slider handles\n   * determines which one from the value/endValue properties has to be updated\n   * after the user action (based on closest handle).\n   *\n   * Set flags if the press is over a handle or in the selected range,\n   * in such cases no values are changed on interaction start, but could be\n   * updated later when dragging.\n   * @private\n   */\n  _pressTargetAndAffectedValue(clientX, value) {\n    const startHandle = this.shadowRoot.querySelector(\".ui5-slider-handle--start\");\n    const endHandle = this.shadowRoot.querySelector(\".ui5-slider-handle--end\");\n    // Check if the press point is in the bounds of any of the Range Slider handles\n    const handleStartDomRect = startHandle.getBoundingClientRect();\n    const handleEndDomRect = endHandle.getBoundingClientRect();\n    const inHandleStartDom = clientX >= handleStartDomRect.left && clientX <= handleStartDomRect.right;\n    const inHandleEndDom = clientX >= handleEndDomRect.left && clientX <= handleEndDomRect.right;\n    // Remove the flag for value in current range if the press action is over one of the handles\n    if (inHandleEndDom || inHandleStartDom) {\n      this._handeIsPressed = true;\n    }\n    // Return that handle that is closer to the press point\n    if (inHandleEndDom || value > this.endValue) {\n      this._setAffectedValue(\"endValue\");\n    }\n    // If one of the handle is pressed return that one\n    if (inHandleStartDom || value < this.startValue) {\n      this._setAffectedValue(\"startValue\");\n    }\n    // Flag if press is in the current select range\n    const isNewValueInCurrentRange = this._startValueAtBeginningOfAction !== undefined && this._endValueAtBeginningOfAction !== undefined && value >= this._startValueAtBeginningOfAction && value <= this._endValueAtBeginningOfAction;\n    this._setIsPressInCurrentRange(!(this._valueAffected || this._handeIsPressed) ? isNewValueInCurrentRange : false);\n  }\n  /**\n   * Sets the value property (start/end) that will get updated\n   * by a user action depending on that user action's characteristics\n   * - mouse press position - cursor coordinates relative to the start/end handles\n   * - selected inner element via a keyboard navigation\n   * @param affectedValue The value that will get modified by the interaction\n   * @private\n   */\n  _setAffectedValue(affectedValue) {\n    this._valueAffected = affectedValue;\n    // If the values have been swapped reset the reversed flag\n    if (this._areValuesReversed()) {\n      this._setValuesAreReversed();\n    }\n  }\n  /**\n   * Flag if press action is made on the currently selected range of values\n   * @param isPressInCurrentRange Did the current press action occur in the current range (between the two handles)\n   * @private\n   */\n  _setIsPressInCurrentRange(isPressInCurrentRange) {\n    this._isPressInCurrentRange = isPressInCurrentRange;\n  }\n  /**\n   * Manage the focus between the focusable inner elements within the component.\n   *\n   * On initial focusin or if the whole range is affected by the user interaction\n   * set the focus on the progress selection, otherwise on one of the Range Slider\n   * handles based on the determined affected value by the user action.\n   *\n   * If one of the handles came across the other one in result of a user action\n   * switch the focus between them to keep it visually consistent.\n   *\n   * Note:\n   * In some cases this function is going to get called twice on one user action.\n   *\n   * 1. When the focus is initially set to an inner element it is done in the very beginning,\n   * of an interaction - on 'mousedown' and 'keydown' events. The focus of the host custom element\n   * is still not being received, causining an immediate focusout that we prevent by\n   * calling this function once again.\n   *\n   * 2. When the focused is manually switched from one inner element to another.\n   * The focusout handler is one and the same for all focusable parts within the\n   * Range Slider and when is called it checks if it should keep the focus within\n   * the component and which part of it should get focused if that is the case.\n   * @protected\n   */\n  focusInnerElement() {\n    const isReversed = this._areValuesReversed();\n    const affectedValue = this._valueAffected;\n    if (this._isPressInCurrentRange || !affectedValue) {\n      this._progressBar.focus();\n    }\n    if (affectedValue === \"startValue\" && !isReversed || affectedValue === \"endValue\" && isReversed) {\n      this._startHandle.focus();\n    }\n    if (affectedValue === \"endValue\" && !isReversed || affectedValue === \"startValue\" && isReversed) {\n      this._endHandle.focus();\n    }\n  }\n  /**\n   * Calculates startValue/endValue properties when the whole range is moved.\n   *\n   * Uses the change of the position of the start handle and adds the initially\n   * selected range to it, to determine the whole range offset.\n   * @param currentPageXPos The current horizontal position of the cursor/touch\n   * @param initialStartHandlePageXPos The initial horizontal position of the start handle\n   * @private\n   */\n  _calculateRangeOffset(currentPageXPos, initialStartHandlePageXPos) {\n    // Return the current values if there is no difference in the\n    // positions of the initial press and the current pointer\n    if (this._initialPageXPosition === currentPageXPos) {\n      return [this.startValue, this.endValue];\n    }\n    const min = this._effectiveMin;\n    const max = this._effectiveMax;\n    const selectedRange = this.endValue - this.startValue;\n    // Computes the new value based on the difference of the current cursor location from the start of the interaction\n    let startValue = this._calculateStartValueByOffset(currentPageXPos, initialStartHandlePageXPos);\n    // When the end handle reaches the max possible value prevent the start handle from moving\n    // And the opposite - if the start handle reaches the beginning of the slider keep the initially selected range.\n    const ctor = this.constructor;\n    startValue = ctor.clipValue(startValue, min, max - selectedRange);\n    return [startValue, startValue + selectedRange];\n  }\n  /**\n   * Computes the new value based on the difference of the current cursor location from the\n   * start of the interaction.\n   * @param currentPageXPos The current horizontal position of the cursor/touch\n   * @param initialStartHandlePageXPos The initial horizontal position of the start handle\n   * @private\n   */\n  _calculateStartValueByOffset(currentPageXPos, initialStartHandlePageXPos) {\n    const min = this._effectiveMin;\n    const max = this._effectiveMax;\n    const step = this._effectiveStep;\n    const dom = this.getBoundingClientRect();\n    let startValue;\n    let startValuePageX;\n    let positionOffset;\n    /* Depending on the dragging direction:\n    - calculate the new position of the start handle from its old pageX value combined with the movement offset;\n    - calculate the start value based on its new pageX coordinates;\n    - 'stepify' the calculated value based on the specified step property; */\n    const ctor = this.constructor;\n    if (currentPageXPos > this._initialPageXPosition) {\n      // Difference between the new position of the pointer and when the press event initial occured\n      positionOffset = currentPageXPos - this._initialPageXPosition;\n      startValuePageX = initialStartHandlePageXPos + positionOffset;\n      startValue = ctor.computedValueFromPageX(startValuePageX, min, max, dom, this.directionStart);\n      startValue = ctor.getSteppedValue(startValue, step, min);\n    } else {\n      positionOffset = this._initialPageXPosition - currentPageXPos;\n      startValuePageX = initialStartHandlePageXPos - positionOffset;\n      startValue = ctor.computedValueFromPageX(startValuePageX, min, max, dom, this.directionStart);\n      startValue = ctor.getSteppedValue(startValue, step, min);\n    }\n    return startValue;\n  }\n  /**\n   * Updates the visual representation of the component by calculating\n   * the styles of the handles and the range selection based on the new state.\n   * @private\n   */\n  _updateHandlesAndRange(newValue) {\n    const max = this._effectiveMax;\n    const min = this._effectiveMin;\n    const prevStartValue = this.getStoredPropertyState(\"startValue\") || 0;\n    const prevEndValue = this.getStoredPropertyState(\"endValue\") || 0;\n    const affectedValue = this._valueAffected;\n    // The value according to which we update the UI can be either the startValue\n    // or the endValue property. It is determined in _getClosestHandle()\n    // depending on to which handle is closer the user interaction.\n    if (affectedValue === \"startValue\") {\n      this._selectedRange = (prevEndValue - newValue) / (max - min);\n      this._firstHandlePositionFromStart = (newValue - min) / (max - min) * 100;\n    } else if (affectedValue === \"endValue\") {\n      this._selectedRange = (newValue - prevStartValue) / (max - min);\n      this._secondHandlePositionFromStart = (newValue - min) / (max - min) * 100;\n    } else {\n      // When both values are changed - UI sync or moving the whole selected range:\n      this._selectedRange = (this.endValue - this.startValue) / (max - min);\n      this._firstHandlePositionFromStart = (this.startValue - min) / (max - min) * 100;\n      this._secondHandlePositionFromStart = (this.endValue - min) / (max - min) * 100;\n    }\n  }\n  /**\n   * Swaps the start and end values of the handles if one came accros the other:\n   * - If the start value is greater than the endValue swap them and their handles\n   * - If the endValue become less than the start value swap them and their handles\n   *\n   * Switches the focus to the opposite of the currently focused handle.\n   *\n   * Note: Only the property values are reversed, the DOM elements of the handles\n   * corresponding to them are never switched.\n   * @private\n   */\n  _swapValues() {\n    const affectedValue = this._valueAffected;\n    if (!affectedValue) {\n      return;\n    }\n    if (affectedValue === \"startValue\" && this.startValue > this.endValue) {\n      const prevEndValue = this.endValue;\n      this.endValue = this.startValue;\n      this.startValue = prevEndValue;\n    }\n    if (affectedValue === \"endValue\" && this.endValue < this.startValue) {\n      const prevStartValue = this.startValue;\n      this.startValue = this.endValue;\n      this.endValue = prevStartValue;\n    }\n    this._setValuesAreReversed();\n    this._updateHandlesAndRange(this[affectedValue]);\n    this.focusInnerElement();\n    this.syncUIAndState();\n  }\n  /**\n   * Flag that we have swapped the values of the 'start' and 'end' properties,\n   * to correctly switch the focus within the component from one handle to another\n   * when the swapping is finished. As we only swap property values and not\n   * the handle elements themselves, we must also swap their focus.\n   * @private\n   */\n  _setValuesAreReversed() {\n    this._reversedValues = !this._reversedValues;\n  }\n  _areValuesReversed() {\n    return this._reversedValues;\n  }\n  get tickmarksObject() {\n    const count = this._tickmarksCount;\n    const arr = [];\n    if (this._hiddenTickmarks) {\n      return [false, false];\n    }\n    for (let i = 0; i <= count; i++) {\n      const isBiggerThanStartValue = this._effectiveMin + i * this.step >= this.startValue;\n      const isBiggerThanEndValue = this._effectiveMin + i * this.step <= this.endValue;\n      arr.push(isBiggerThanStartValue && isBiggerThanEndValue);\n    }\n    return arr;\n  }\n  get _startHandle() {\n    return this.shadowRoot.querySelector(\".ui5-slider-handle--start\");\n  }\n  get _endHandle() {\n    return this.shadowRoot.querySelector(\".ui5-slider-handle--end\");\n  }\n  get _progressBar() {\n    return this.shadowRoot.querySelector(\".ui5-slider-progress\");\n  }\n  get _ariaLabelledByStartHandleRefs() {\n    return [`${this._id}-accName`, `${this._id}-startHandleDesc`].join(\" \").trim();\n  }\n  get _ariaLabelledByEndHandleRefs() {\n    return [`${this._id}-accName`, `${this._id}-endHandleDesc`].join(\" \").trim();\n  }\n  get _ariaLabelledByProgressBarRefs() {\n    return [`${this._id}-accName`, `${this._id}-sliderDesc`].join(\" \").trim();\n  }\n  get styles() {\n    return {\n      progress: {\n        \"width\": `${this._selectedRange * 100}%`,\n        \"transform-origin\": `${this.directionStart} top`,\n        [this.directionStart]: `${this._firstHandlePositionFromStart}%`\n      },\n      startHandle: {\n        [this.directionStart]: `${this._firstHandlePositionFromStart}%`\n      },\n      endHandle: {\n        [this.directionStart]: `${this._secondHandlePositionFromStart}%`\n      },\n      label: {\n        \"width\": `${this._labelWidth}%`\n      },\n      labelContainer: {\n        \"width\": `100%`,\n        [this.directionStart]: `-${this._labelWidth / 2}%`\n      },\n      tooltip: {\n        \"visibility\": `${this._tooltipVisibility}`\n      }\n    };\n  }\n  static async onDefine() {\n    RangeSlider_1.i18nBundle = await getI18nBundle(\"@ui5/webcomponents\");\n  }\n};\n__decorate([property({\n  type: Number\n})], RangeSlider.prototype, \"startValue\", void 0);\n__decorate([property({\n  type: Number\n})], RangeSlider.prototype, \"endValue\", void 0);\n__decorate([property({\n  type: Boolean\n})], RangeSlider.prototype, \"rangePressed\", void 0);\nRangeSlider = RangeSlider_1 = __decorate([customElement({\n  tag: \"ui5-range-slider\",\n  languageAware: true,\n  formAssociated: true,\n  template: RangeSliderTemplate,\n  dependencies: [Icon],\n  styles: [SliderBase.styles, rangeSliderStyles]\n})], RangeSlider);\nRangeSlider.define();\nexport default RangeSlider;","map":{"version":3,"names":["customElement","property","getI18nBundle","isEscape","isHome","isEnd","SliderBase","Icon","RangeSliderTemplate","RANGE_SLIDER_ARIA_DESCRIPTION","RANGE_SLIDER_START_HANDLE_DESCRIPTION","RANGE_SLIDER_END_HANDLE_DESCRIPTION","rangeSliderStyles","RangeSlider","RangeSlider_1","formFormattedValue","formData","FormData","name","append","startValue","toString","endValue","constructor","rangePressed","_isPressInCurrentRange","_handeIsPressed","_reversedValues","_stateStorage","undefined","tooltipStartValue","ctor","stepPrecision","_getDecimalPrecisionOfNumber","_effectiveStep","toFixed","tooltipEndValue","_ariaDisabled","disabled","_ariaLabelledByText","i18nBundle","getText","_ariaHandlesText","isRTL","effectiveDir","isReversed","_areValuesReversed","ariaHandlesText","startHandleText","endHandleText","_ariaValueNow","Math","abs","onBeforeRendering","affectedValue","_valueAffected","_swapValues","_setAffectedValue","update","isCurrentStateOutdated","notResized","syncUIAndState","_updateHandlesAndRange","isPropertyUpdated","_validateStep","step","storePropertyState","normalizedStartValue","clipValue","_effectiveMin","_effectiveMax","updateStateStorageAndFireInputEvent","normalizedEndValue","labelInterval","showTickmarks","_createLabels","_onfocusin","_endValueInitial","_startValueInitial","showTooltip","_tooltipVisibility","TOOLTIP_VISIBILITY","VISIBLE","_onfocusout","_isFocusing","_preventFocusOut","HIDDEN","_onkeyup","_startValueAtBeginningOfAction","_endValueAtBeginningOfAction","fireEvent","_handleActionKeyPress","e","_setAffectedValueByFocusedElement","min","max","_homeEndForSelectedRange","newValueOffset","_handleActionKeyPressBase","propValue","newValue","newStartValue","newEndValue","shadowRoot","activeElement","_startHandle","_endHandle","_progressBar","_setIsPressInCurrentRange","_onmousedown","handleDownBase","_saveInteractionStartData","progressBarDom","querySelector","getBoundingClientRect","_initialPageXPosition","getPageXValueFromEvent","_pressTargetAndAffectedValue","_initialStartHandlePageX","directionStart","left","right","_handleMove","preventDefault","_updateValueOnHandleDrag","_updateValueOnRangeDrag","event","getValueFromInteraction","currentPageXPos","newValues","_calculateRangeOffset","_handleUp","handleUpBase","clientX","value","startHandle","endHandle","handleStartDomRect","handleEndDomRect","inHandleStartDom","inHandleEndDom","isNewValueInCurrentRange","_setValuesAreReversed","isPressInCurrentRange","focusInnerElement","focus","initialStartHandlePageXPos","selectedRange","_calculateStartValueByOffset","dom","startValuePageX","positionOffset","computedValueFromPageX","getSteppedValue","prevStartValue","getStoredPropertyState","prevEndValue","_selectedRange","_firstHandlePositionFromStart","_secondHandlePositionFromStart","tickmarksObject","count","_tickmarksCount","arr","_hiddenTickmarks","i","isBiggerThanStartValue","isBiggerThanEndValue","push","_ariaLabelledByStartHandleRefs","_id","join","trim","_ariaLabelledByEndHandleRefs","_ariaLabelledByProgressBarRefs","styles","progress","label","_labelWidth","labelContainer","tooltip","onDefine","__decorate","type","Number","Boolean","tag","languageAware","formAssociated","template","dependencies","define"],"sources":["/home/user/projects/reactproj/node_modules/@ui5/webcomponents/src/RangeSlider.ts"],"sourcesContent":["import customElement from \"@ui5/webcomponents-base/dist/decorators/customElement.js\";\nimport property from \"@ui5/webcomponents-base/dist/decorators/property.js\";\nimport { getI18nBundle } from \"@ui5/webcomponents-base/dist/i18nBundle.js\";\nimport type I18nBundle from \"@ui5/webcomponents-base/dist/i18nBundle.js\";\nimport type { IFormInputElement } from \"@ui5/webcomponents-base/dist/features/InputElementsFormSupport.js\";\nimport {\n\tisEscape,\n\tisHome,\n\tisEnd,\n} from \"@ui5/webcomponents-base/dist/Keys.js\";\nimport SliderBase from \"./SliderBase.js\";\nimport Icon from \"./Icon.js\";\nimport RangeSliderTemplate from \"./generated/templates/RangeSliderTemplate.lit.js\";\n\n// Texts\nimport {\n\tRANGE_SLIDER_ARIA_DESCRIPTION,\n\tRANGE_SLIDER_START_HANDLE_DESCRIPTION,\n\tRANGE_SLIDER_END_HANDLE_DESCRIPTION,\n} from \"./generated/i18n/i18n-defaults.js\";\n\n// Styles\nimport rangeSliderStyles from \"./generated/themes/RangeSlider.css.js\";\n\ntype AriaHandlesText = {\n\tstartHandleText?: string,\n\tendHandleText?: string,\n}\n\ntype AffectedValue = \"startValue\" | \"endValue\";\n\n/**\n * @class\n *\n * ### Overview\n * Represents a numerical interval and two handles (grips) to select a sub-range within it.\n * The purpose of the component to enable visual selection of sub-ranges within a given interval.\n *\n * ### Structure\n * The most important properties of the Range Slider are:\n *\n * - min - The minimum value of the slider range.\n * - max - The maximum value of the slider range.\n * - value - The current value of the slider.\n * - step - Determines the increments in which the slider will move.\n * - showTooltip - Determines if a tooltip should be displayed above the handle.\n * - showTickmarks - Displays a visual divider between the step values.\n * - labelInterval - Labels some or all of the tickmarks with their values.\n *\n * #### Notes:\n *\n * - The right and left handle can be moved individually and their positions could therefore switch.\n * - The entire range can be moved along the interval.\n *\n * ### Usage\n * The most common use case is to select and move sub-ranges on a continuous numerical scale.\n *\n * ### Responsive Behavior\n * You can move the currently selected range by clicking on it and dragging it along the interval.\n *\n * ### Keyboard Handling\n *\n * - `Left or Down Arrow` - Moves a component's handle or the entire selection one step to the left;\n * - `Right or Up Arrow` - Moves a component's handle or the entire selection one step to the right;\n * - `Left or Down Arrow + Ctrl/Cmd` - Moves a component's handle to the left or the entire range with step equal to 1/10th of the entire range;\n * - `Right or Up Arrow + Ctrl/Cmd` - Moves a component's handle to the right or the entire range with step equal to 1/10th of the entire range;\n * - `Plus` - Same as `Right or Up Arrow`;\n * - `Minus` - Same as `Left or Down Arrow`;\n * - `Home` - Moves the entire selection or the selected handle to the beginning of the component's range;\n * - `End` - Moves the entire selection or the selected handle to the end of the component's range;\n * - `Page Up` - Same as `Right or Up Arrow + Ctrl/Cmd`;\n * - `Page Down` - Same as `Left or Down Arrow + Ctrl/Cmd`;\n * - `Escape` - Resets the `startValue` and `endValue` properties to the values prior the component focusing;\n *\n * ### ES6 Module Import\n *\n * `import \"@ui5/webcomponents/dist/RangeSlider.js\";`\n * @constructor\n * @extends SliderBase\n * @since 1.0.0-rc.11\n * @public\n * @csspart progress-container - Used to style the progress container, the horizontal bar that visually represents the range between the minimum and maximum values, of the `ui5-range-slider`.\n * @csspart progress-bar - Used to style the progress bar, which shows the progress of the `ui5-range-slider`.\n * @csspart handle - Used to style the handles of the `ui5-range-slider`.\n */\n@customElement({\n\ttag: \"ui5-range-slider\",\n\tlanguageAware: true,\n\tformAssociated: true,\n\ttemplate: RangeSliderTemplate,\n\tdependencies: [Icon],\n\tstyles: [SliderBase.styles, rangeSliderStyles],\n})\nclass RangeSlider extends SliderBase implements IFormInputElement {\n\t/**\n\t * Defines start point of a selection - position of a first handle on the slider.\n\t * @default 0\n\t * @formEvents change input\n\t * @formProperty\n\t * @public\n\t */\n\t@property({ type: Number })\n\tstartValue = 0;\n\n\t/**\n\t * Defines end point of a selection - position of a second handle on the slider.\n\t * @default 100\n\t * @formEvents change input\n\t * @formProperty\n\t * @public\n\t */\n\t@property({ type: Number })\n\tendValue = 100;\n\n\t@property({ type: Boolean })\n\trangePressed = false;\n\n\t_startValueInitial?: number;\n\t_endValueInitial?: number;\n\t_valueAffected?: AffectedValue;\n\t_isPressInCurrentRange = false;\n\t_handeIsPressed = false;\n\t_initialPageXPosition?: number;\n\t_startValueAtBeginningOfAction?: number;\n\t_endValueAtBeginningOfAction?: number;\n\t_initialStartHandlePageX?: number;\n\t_firstHandlePositionFromStart?: number;\n\t_secondHandlePositionFromStart?: number;\n\t_selectedRange?: number;\n\t_reversedValues = false;\n\n\tstatic i18nBundle: I18nBundle;\n\n\tget formFormattedValue() {\n\t\tconst formData = new FormData();\n\n\t\tif (!this.name) {\n\t\t\treturn formData;\n\t\t}\n\n\t\tformData.append(this.name, this.startValue.toString());\n\t\tformData.append(this.name, this.endValue.toString());\n\n\t\treturn formData;\n\t}\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._stateStorage.startValue = undefined;\n\t\tthis._stateStorage.endValue = undefined;\n\t}\n\n\tget tooltipStartValue() {\n\t\tconst ctor = this.constructor as typeof RangeSlider;\n\t\tconst stepPrecision = ctor._getDecimalPrecisionOfNumber(this._effectiveStep);\n\t\treturn this.startValue.toFixed(stepPrecision);\n\t}\n\n\tget tooltipEndValue() {\n\t\tconst ctor = this.constructor as typeof RangeSlider;\n\t\tconst stepPrecision = ctor._getDecimalPrecisionOfNumber(this._effectiveStep);\n\t\treturn this.endValue.toFixed(stepPrecision);\n\t}\n\n\tget _ariaDisabled() {\n\t\treturn this.disabled || undefined;\n\t}\n\n\tget _ariaLabelledByText() {\n\t\treturn RangeSlider.i18nBundle.getText(RANGE_SLIDER_ARIA_DESCRIPTION);\n\t}\n\n\tget _ariaHandlesText() {\n\t\tconst isRTL = this.effectiveDir === \"rtl\";\n\t\tconst isReversed = this._areValuesReversed();\n\t\tconst ariaHandlesText: AriaHandlesText = {};\n\n\t\tif ((isRTL && !isReversed) || (!isRTL && isReversed)) {\n\t\t\tariaHandlesText.startHandleText = RangeSlider.i18nBundle.getText(RANGE_SLIDER_END_HANDLE_DESCRIPTION);\n\t\t\tariaHandlesText.endHandleText = RangeSlider.i18nBundle.getText(RANGE_SLIDER_START_HANDLE_DESCRIPTION);\n\t\t} else {\n\t\t\tariaHandlesText.startHandleText = RangeSlider.i18nBundle.getText(RANGE_SLIDER_START_HANDLE_DESCRIPTION);\n\t\t\tariaHandlesText.endHandleText = RangeSlider.i18nBundle.getText(RANGE_SLIDER_END_HANDLE_DESCRIPTION);\n\t\t}\n\n\t\treturn ariaHandlesText;\n\t}\n\n\tget _ariaValueNow() {\n\t\treturn Math.abs(this.endValue - this.startValue);\n\t}\n\n\t/**\n\t * Check if the previously saved state is outdated. That would mean\n\t * either it is the initial rendering or that a property has been changed\n\t * programmatically - because the previous state is always updated in\n\t * the interaction handlers.\n\t *\n\t * Normalize current properties, update the previously stored state.\n\t * Update the visual UI representation of the Slider.\n\t *\n\t */\n\tonBeforeRendering() {\n\t\tif (this.startValue > this.endValue) {\n\t\t\tconst affectedValue = this._valueAffected === \"startValue\" ? \"endValue\" : \"startValue\";\n\n\t\t\tthis._swapValues();\n\t\t\tthis._setAffectedValue(affectedValue);\n\t\t\tthis.update(affectedValue, this.startValue, this.endValue);\n\t\t}\n\n\t\tif (!this.isCurrentStateOutdated()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.notResized = true;\n\t\tthis.syncUIAndState();\n\t\tthis._updateHandlesAndRange(0);\n\t}\n\n\tsyncUIAndState() {\n\t\t// Validate step and update the stored state for the step property.\n\t\tif (this.isPropertyUpdated(\"step\")) {\n\t\t\tthis._validateStep(this.step);\n\t\t\tthis.storePropertyState(\"step\");\n\t\t}\n\n\t\t// Recalculate the tickmarks and labels and update the stored state.\n\t\tif (this.isPropertyUpdated(\"min\", \"max\", \"startValue\", \"endValue\")) {\n\t\t\tthis.storePropertyState(\"min\", \"max\");\n\n\t\t\t// Here the value props are changed programmatically (not by user interaction)\n\t\t\t// and it won't be \"stepified\" (rounded to the nearest step). 'Clip' them within\n\t\t\t// min and max bounderies and update the previous state reference.\n\t\t\tconst normalizedStartValue = SliderBase.clipValue(this.startValue, this._effectiveMin, this._effectiveMax);\n\t\t\tthis.startValue = normalizedStartValue;\n\t\t\tthis.updateStateStorageAndFireInputEvent(\"startValue\");\n\t\t\tthis.storePropertyState(\"startValue\");\n\n\t\t\tconst normalizedEndValue = SliderBase.clipValue(this.endValue, this._effectiveMin, this._effectiveMax);\n\t\t\tthis.endValue = normalizedEndValue;\n\t\t\tthis.updateStateStorageAndFireInputEvent(\"endValue\");\n\t\t\tthis.storePropertyState(\"endValue\");\n\t\t}\n\n\t\t// Labels must be updated if any of the min/max/step/labelInterval props are changed\n\t\tif (this.labelInterval && this.showTickmarks) {\n\t\t\tthis._createLabels();\n\t\t}\n\n\t\t// Update the stored state for the labelInterval, if changed\n\t\tif (this.isPropertyUpdated(\"labelInterval\")) {\n\t\t\tthis.storePropertyState(\"labelInterval\");\n\t\t}\n\t}\n\n\t_onfocusin() {\n\t\t// If this is the initial focusin of the component save its initial\n\t\t// value properties so they could be restored on ESC key press\n\t\tif (!this._endValueInitial) {\n\t\t\tthis._startValueInitial = this.startValue;\n\t\t\tthis._endValueInitial = this.endValue;\n\t\t}\n\n\t\tif (this.showTooltip) {\n\t\t\tthis._tooltipVisibility = SliderBase.TOOLTIP_VISIBILITY.VISIBLE;\n\t\t}\n\t}\n\n\t/**\n\t * Handles focus out event of the focusable components inner elements.\n\t * Prevent focusout when the focus is getting initially set within the slider before the\n\t * slider customElement itself is finished focusing.\n\t *\n\t * Prevents the focus from leaving the Range Slider when the focus is managed between\n\t * its inner elements in result of user interactions.\n\t *\n\t * Resets the stored Range Slider's initial values saved when it was first focused\n\t * @private\n\t */\n\t_onfocusout() {\n\t\tif (this._isFocusing()) {\n\t\t\tthis._preventFocusOut();\n\t\t\treturn;\n\t\t}\n\n\t\tthis._setAffectedValue(undefined);\n\t\tthis._startValueInitial = undefined;\n\t\tthis._endValueInitial = undefined;\n\n\t\tif (this.showTooltip) {\n\t\t\tthis._tooltipVisibility = SliderBase.TOOLTIP_VISIBILITY.HIDDEN;\n\t\t}\n\t}\n\n\t/**\n\t* Handles keyup logic. If one of the handles came across the other\n\t* swap the start and end values. Reset the affected value by the finished\n\t* user interaction.\n\t* @private\n\t*/\n\t_onkeyup() {\n\t\tsuper._onkeyup();\n\t\tthis._setAffectedValue(undefined);\n\n\t\tif (this.startValue !== this._startValueAtBeginningOfAction || this.endValue !== this._endValueAtBeginningOfAction) {\n\t\t\tthis.fireEvent(\"change\");\n\t\t}\n\n\t\tthis._startValueAtBeginningOfAction = undefined;\n\t\tthis._endValueAtBeginningOfAction = undefined;\n\t}\n\n\t_handleActionKeyPress(e: KeyboardEvent) {\n\t\tthis._startValueAtBeginningOfAction = this.startValue;\n\t\tthis._endValueAtBeginningOfAction = this.endValue;\n\n\t\tif (isEscape(e)) {\n\t\t\tthis.update(undefined, this._startValueInitial, this._endValueInitial);\n\t\t\treturn;\n\t\t}\n\n\t\t// Set the target of the interaction based on the focused inner element\n\t\tthis._setAffectedValueByFocusedElement();\n\n\t\tconst min = this._effectiveMin;\n\t\tconst max = this._effectiveMax;\n\t\tconst affectedValue = this._valueAffected!;\n\n\t\t// If home/end key is pressed and no single handle is focused the active element\n\t\t// is the range selection - update both start and end values. Otherwise, if 'home'\n\t\t// is pressed the 'startValue'will be used for the start-handle offset calculation,\n\t\t// if 'End' is pressed - the 'endValue' will be used for the end-handle update.\n\t\tif ((isEnd(e) || isHome(e)) && !affectedValue) {\n\t\t\tthis._homeEndForSelectedRange(e, isHome(e) ? \"startValue\" : \"endValue\", min, max);\n\t\t\treturn;\n\t\t}\n\n\t\t// Calculate how much the value should be increased/decreased based on the action key\n\t\tconst newValueOffset = this._handleActionKeyPressBase(e, affectedValue);\n\n\t\tif (!newValueOffset) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Update a single value if one of the handles is focused or the range if not already at min or max\n\t\tconst ctor = this.constructor as typeof RangeSlider;\n\t\tif (affectedValue && !this._isPressInCurrentRange) {\n\t\t\tconst propValue = this[affectedValue as keyof RangeSlider] as number;\n\t\t\tconst newValue = ctor.clipValue(newValueOffset + propValue, min, max);\n\t\t\tthis.update(affectedValue, newValue, undefined);\n\t\t} else if ((newValueOffset < 0 && this.startValue > min) || (newValueOffset > 0 && this.endValue < max)) {\n\t\t\tconst newStartValue = ctor.clipValue(newValueOffset + this.startValue, min, max);\n\t\t\tconst newEndValue = ctor.clipValue(newValueOffset + this.endValue, min, max);\n\t\t\tthis.update(affectedValue, newStartValue, newEndValue);\n\t\t}\n\t}\n\n\t/**\n\t * Determines affected value (start/end) depending on the currently\n\t * active inner element within the Range Slider - used in the keyboard handling.\n\t * @private\n\t */\n\t_setAffectedValueByFocusedElement() {\n\t\tif (this.shadowRoot!.activeElement === this._startHandle) {\n\t\t\tthis._setAffectedValue(\"startValue\");\n\t\t}\n\n\t\tif (this.shadowRoot!.activeElement === this._endHandle) {\n\t\t\tthis._setAffectedValue(\"endValue\");\n\t\t}\n\n\t\tif (this.shadowRoot!.activeElement === this._progressBar) {\n\t\t\tthis._setAffectedValue(undefined);\n\t\t}\n\n\t\tthis._setIsPressInCurrentRange(!this._valueAffected);\n\t}\n\n\t/**\n\t * Calculates the start and end values when the 'Home\" or 'End' keys\n\t * are pressed on the selected range bar.\n\t * @private\n\t */\n\t_homeEndForSelectedRange(e: KeyboardEvent, affectedValue: string, min: number, max: number) {\n\t\tconst newValueOffset = this._handleActionKeyPressBase(e, affectedValue);\n\t\tconst ctor = this.constructor as typeof RangeSlider;\n\t\tconst newStartValue = ctor.clipValue(newValueOffset + this.startValue, min, max);\n\t\tconst newEndValue = ctor.clipValue(newValueOffset + this.endValue, min, max);\n\n\t\tthis.update(undefined, newStartValue, newEndValue);\n\t}\n\n\t/**\n\t * Update values, stored inner state and the visual UI representation of the component.\n\t * If no specific type of value property is passed - the range is selected - update both handles,\n\t * otherwise update the handle corresponding to the affected by the user interacton value prop.\n\t * @private\n\t */\n\tupdate(affectedValue: string | undefined, startValue: number | undefined, endValue: number | undefined) {\n\t\tif (!affectedValue) {\n\t\t\tthis.startValue = startValue!;\n\t\t\tthis.updateStateStorageAndFireInputEvent(\"startValue\");\n\n\t\t\tthis.endValue = endValue!;\n\t\t\tthis.updateStateStorageAndFireInputEvent(\"endValue\");\n\t\t\tthis._updateHandlesAndRange(0);\n\t\t} else {\n\t\t\tconst newValue = endValue && affectedValue === \"endValue\" ? endValue : startValue;\n\t\t\tthis._updateHandlesAndRange(newValue || 0);\n\n\t\t\tif (affectedValue === \"startValue\") {\n\t\t\t\tthis.startValue = newValue!;\n\t\t\t\tthis.updateStateStorageAndFireInputEvent(\"startValue\");\n\t\t\t}\n\n\t\t\tif (affectedValue === \"endValue\") {\n\t\t\t\tthis.endValue = newValue!;\n\t\t\t\tthis.updateStateStorageAndFireInputEvent(\"endValue\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Called when the user starts interacting with the slider\n\t * @private\n\t */\n\t_onmousedown(e: TouchEvent | MouseEvent) {\n\t\t// If step is 0 no interaction is available because there is no constant\n\t\t// (equal for all user environments) quantitative representation of the value\n\t\tif (this.disabled || this._effectiveStep === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Calculate the new value from the press position of the event\n\t\tconst newValue = this.handleDownBase(e);\n\n\t\t// Determine the rest of the needed details from the start of the interaction.\n\t\tthis._saveInteractionStartData(e, newValue);\n\n\t\tthis.rangePressed = this._isPressInCurrentRange;\n\n\t\t// Do not yet update the RangeSlider if press is in range or over a handle.\n\t\tif (this._isPressInCurrentRange || this._handeIsPressed) {\n\t\t\tthis._handeIsPressed = false;\n\t\t\treturn;\n\t\t}\n\n\t\t// Update Slider UI and internal state\n\t\tthis.update(this._valueAffected, newValue, undefined);\n\t}\n\n\t/**\n\t * Determines and saves needed values from the start of the interaction:\n\t *\n\t * Is the value calculated is within the currently selected range;\n\t * Initial pageX position of the start handle affected by the interaction;\n\t * Initial pageX value of the pressed postion;\n\t * Affected value property by the action;\n\t * @private\n\t */\n\t_saveInteractionStartData(e: TouchEvent | MouseEvent, newValue: number) {\n\t\tconst progressBarDom = this.shadowRoot!.querySelector(\".ui5-slider-progress\")!.getBoundingClientRect();\n\n\t\t// Save the state of the value properties on the start of the interaction\n\t\tthis._startValueAtBeginningOfAction = this.startValue;\n\t\tthis._endValueAtBeginningOfAction = this.endValue;\n\n\t\t// Save the initial press point coordinates (position)\n\t\tconst ctor = this.constructor as typeof RangeSlider;\n\t\tthis._initialPageXPosition = ctor.getPageXValueFromEvent(e);\n\t\t// Which element of the Range Slider is pressed and which value property to be modified on further interaction\n\t\tthis._pressTargetAndAffectedValue(this._initialPageXPosition, newValue);\n\t\t// Use the progress bar to save the initial coordinates of the start-handle when the interaction begins.\n\t\tthis._initialStartHandlePageX = this.directionStart === \"left\" ? progressBarDom.left : progressBarDom.right;\n\t}\n\n\t/**\n\t * Called when the user moves the slider\n\t * @private\n\t */\n\t_handleMove(e: TouchEvent | MouseEvent) {\n\t\te.preventDefault();\n\n\t\t// If 'step' is 0 no interaction is available as there is no constant quantitative representation of the value\n\t\tif (this.disabled || this._effectiveStep === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Update UI and state when dragging a single Range Slider handle\n\t\tif (!this._isPressInCurrentRange) {\n\t\t\tthis._updateValueOnHandleDrag(e);\n\t\t\treturn;\n\t\t}\n\n\t\t// Updates UI and state when dragging of the whole selected range\n\t\tthis._updateValueOnRangeDrag(e);\n\t}\n\n\t/**\n\t * Updates UI and state when dragging a single Range Slider handle\n\t * @private\n\t */\n\t_updateValueOnHandleDrag(event: TouchEvent | MouseEvent) {\n\t\tconst ctor = this.constructor as typeof RangeSlider;\n\t\tconst newValue = ctor.getValueFromInteraction(event, this._effectiveStep, this._effectiveMin, this._effectiveMax, this.getBoundingClientRect(), this.directionStart);\n\t\tthis.update(this._valueAffected, newValue, undefined);\n\t}\n\n\t/**\n\t * Updates UI and state when dragging of the whole selected range\n\t * @private\n\t */\n\t_updateValueOnRangeDrag(event: TouchEvent | MouseEvent) {\n\t\t// Calculate the new 'start' and 'end' values from the offset between the original press point and the current position of the mouse\n\t\tconst ctor = this.constructor as typeof RangeSlider;\n\t\tconst currentPageXPos = ctor.getPageXValueFromEvent(event);\n\t\tconst newValues = this._calculateRangeOffset(currentPageXPos, this._initialStartHandlePageX!);\n\n\t\t// No matter the which value is set as the one to be modified (by prev. user action) we want to modify both of them\n\t\tthis._setAffectedValue(undefined);\n\n\t\t// Update the UI and the state according to the calculated new values\n\t\tthis.update(undefined, newValues[0], newValues[1]);\n\t}\n\n\t_handleUp() {\n\t\tthis._setAffectedValueByFocusedElement();\n\t\tthis._setAffectedValue(undefined);\n\n\t\tif (this.startValue !== this._startValueAtBeginningOfAction || this.endValue !== this._endValueAtBeginningOfAction) {\n\t\t\tthis.fireEvent(\"change\");\n\t\t}\n\n\t\tthis._setIsPressInCurrentRange(false);\n\t\tthis.handleUpBase();\n\n\t\tthis.rangePressed = false;\n\t\tthis._startValueAtBeginningOfAction = undefined;\n\t\tthis._endValueAtBeginningOfAction = undefined;\n\t}\n\n\t/**\n\t * Determines where the press occured and which values of the Range Slider\n\t * handles should be updated on further interaction.\n\t *\n\t * If the press is not in the selected range or over one of the Range Slider handles\n\t * determines which one from the value/endValue properties has to be updated\n\t * after the user action (based on closest handle).\n\t *\n\t * Set flags if the press is over a handle or in the selected range,\n\t * in such cases no values are changed on interaction start, but could be\n\t * updated later when dragging.\n\t * @private\n\t */\n\t_pressTargetAndAffectedValue(clientX: number, value: number) {\n\t\tconst startHandle = this.shadowRoot!.querySelector(\".ui5-slider-handle--start\")!;\n\t\tconst endHandle = this.shadowRoot!.querySelector(\".ui5-slider-handle--end\")!;\n\n\t\t// Check if the press point is in the bounds of any of the Range Slider handles\n\t\tconst handleStartDomRect = startHandle.getBoundingClientRect();\n\t\tconst handleEndDomRect = endHandle.getBoundingClientRect();\n\t\tconst inHandleStartDom = clientX >= handleStartDomRect.left && clientX <= handleStartDomRect.right;\n\t\tconst inHandleEndDom = clientX >= handleEndDomRect.left && clientX <= handleEndDomRect.right;\n\n\t\t// Remove the flag for value in current range if the press action is over one of the handles\n\t\tif (inHandleEndDom || inHandleStartDom) {\n\t\t\tthis._handeIsPressed = true;\n\t\t}\n\n\t\t// Return that handle that is closer to the press point\n\t\tif (inHandleEndDom || value > this.endValue) {\n\t\t\tthis._setAffectedValue(\"endValue\");\n\t\t}\n\n\t\t// If one of the handle is pressed return that one\n\t\tif (inHandleStartDom || value < this.startValue) {\n\t\t\tthis._setAffectedValue(\"startValue\");\n\t\t}\n\n\t\t// Flag if press is in the current select range\n\t\tconst isNewValueInCurrentRange = this._startValueAtBeginningOfAction !== undefined && this._endValueAtBeginningOfAction !== undefined && value >= this._startValueAtBeginningOfAction && value <= this._endValueAtBeginningOfAction;\n\t\tthis._setIsPressInCurrentRange(!(this._valueAffected || this._handeIsPressed) ? isNewValueInCurrentRange : false);\n\t}\n\n\t/**\n\t * Sets the value property (start/end) that will get updated\n\t * by a user action depending on that user action's characteristics\n\t * - mouse press position - cursor coordinates relative to the start/end handles\n\t * - selected inner element via a keyboard navigation\n\t * @param affectedValue The value that will get modified by the interaction\n\t * @private\n\t */\n\t_setAffectedValue(affectedValue: AffectedValue | undefined) {\n\t\tthis._valueAffected = affectedValue;\n\n\t\t// If the values have been swapped reset the reversed flag\n\t\tif (this._areValuesReversed()) {\n\t\t\tthis._setValuesAreReversed();\n\t\t}\n\t}\n\n\t/**\n\t * Flag if press action is made on the currently selected range of values\n\t * @param isPressInCurrentRange Did the current press action occur in the current range (between the two handles)\n\t * @private\n\t */\n\t_setIsPressInCurrentRange(isPressInCurrentRange: boolean) {\n\t\tthis._isPressInCurrentRange = isPressInCurrentRange;\n\t}\n\n\t/**\n\t * Manage the focus between the focusable inner elements within the component.\n\t *\n\t * On initial focusin or if the whole range is affected by the user interaction\n\t * set the focus on the progress selection, otherwise on one of the Range Slider\n\t * handles based on the determined affected value by the user action.\n\t *\n\t * If one of the handles came across the other one in result of a user action\n\t * switch the focus between them to keep it visually consistent.\n\t *\n\t * Note:\n\t * In some cases this function is going to get called twice on one user action.\n\t *\n\t * 1. When the focus is initially set to an inner element it is done in the very beginning,\n\t * of an interaction - on 'mousedown' and 'keydown' events. The focus of the host custom element\n\t * is still not being received, causining an immediate focusout that we prevent by\n\t * calling this function once again.\n\t *\n\t * 2. When the focused is manually switched from one inner element to another.\n\t * The focusout handler is one and the same for all focusable parts within the\n\t * Range Slider and when is called it checks if it should keep the focus within\n\t * the component and which part of it should get focused if that is the case.\n\t * @protected\n\t */\n\tfocusInnerElement() {\n\t\tconst isReversed = this._areValuesReversed();\n\t\tconst affectedValue = this._valueAffected;\n\n\t\tif (this._isPressInCurrentRange || !affectedValue) {\n\t\t\tthis._progressBar.focus();\n\t\t}\n\n\t\tif ((affectedValue === \"startValue\" && !isReversed) || (affectedValue === \"endValue\" && isReversed)) {\n\t\t\tthis._startHandle.focus();\n\t\t}\n\n\t\tif ((affectedValue === \"endValue\" && !isReversed) || (affectedValue === \"startValue\" && isReversed)) {\n\t\t\tthis._endHandle.focus();\n\t\t}\n\t}\n\n\t/**\n\t * Calculates startValue/endValue properties when the whole range is moved.\n\t *\n\t * Uses the change of the position of the start handle and adds the initially\n\t * selected range to it, to determine the whole range offset.\n\t * @param currentPageXPos The current horizontal position of the cursor/touch\n\t * @param initialStartHandlePageXPos The initial horizontal position of the start handle\n\t * @private\n\t */\n\t_calculateRangeOffset(currentPageXPos: number, initialStartHandlePageXPos: number) {\n\t\t// Return the current values if there is no difference in the\n\t\t// positions of the initial press and the current pointer\n\t\tif (this._initialPageXPosition === currentPageXPos) {\n\t\t\treturn [this.startValue, this.endValue];\n\t\t}\n\n\t\tconst min = this._effectiveMin;\n\t\tconst max = this._effectiveMax;\n\t\tconst selectedRange = this.endValue - this.startValue;\n\n\t\t// Computes the new value based on the difference of the current cursor location from the start of the interaction\n\t\tlet startValue = this._calculateStartValueByOffset(currentPageXPos, initialStartHandlePageXPos);\n\n\t\t// When the end handle reaches the max possible value prevent the start handle from moving\n\t\t// And the opposite - if the start handle reaches the beginning of the slider keep the initially selected range.\n\t\tconst ctor = this.constructor as typeof RangeSlider;\n\t\tstartValue = ctor.clipValue(startValue, min, max - selectedRange);\n\n\t\treturn [startValue, startValue + selectedRange];\n\t}\n\n\t/**\n\t * Computes the new value based on the difference of the current cursor location from the\n\t * start of the interaction.\n\t * @param currentPageXPos The current horizontal position of the cursor/touch\n\t * @param initialStartHandlePageXPos The initial horizontal position of the start handle\n\t * @private\n\t */\n\t_calculateStartValueByOffset(currentPageXPos: number, initialStartHandlePageXPos: number) {\n\t\tconst min = this._effectiveMin;\n\t\tconst max = this._effectiveMax;\n\t\tconst step = this._effectiveStep;\n\t\tconst dom = this.getBoundingClientRect();\n\n\t\tlet startValue;\n\t\tlet startValuePageX;\n\t\tlet positionOffset;\n\n\t\t/* Depending on the dragging direction:\n\t\t- calculate the new position of the start handle from its old pageX value combined with the movement offset;\n\t\t- calculate the start value based on its new pageX coordinates;\n\t\t- 'stepify' the calculated value based on the specified step property; */\n\t\tconst ctor = this.constructor as typeof RangeSlider;\n\t\tif (currentPageXPos > this._initialPageXPosition!) {\n\t\t\t// Difference between the new position of the pointer and when the press event initial occured\n\t\t\tpositionOffset = currentPageXPos - this._initialPageXPosition!;\n\n\t\t\tstartValuePageX = initialStartHandlePageXPos + positionOffset;\n\t\t\tstartValue = ctor.computedValueFromPageX(startValuePageX, min, max, dom, this.directionStart);\n\t\t\tstartValue = ctor.getSteppedValue(startValue, step, min);\n\t\t} else {\n\t\t\tpositionOffset = this._initialPageXPosition! - currentPageXPos;\n\t\t\tstartValuePageX = initialStartHandlePageXPos - positionOffset;\n\t\t\tstartValue = ctor.computedValueFromPageX(startValuePageX, min, max, dom, this.directionStart);\n\t\t\tstartValue = ctor.getSteppedValue(startValue, step, min);\n\t\t}\n\n\t\treturn startValue;\n\t}\n\n\t/**\n\t * Updates the visual representation of the component by calculating\n\t * the styles of the handles and the range selection based on the new state.\n\t * @private\n\t */\n\t_updateHandlesAndRange(newValue: number) {\n\t\tconst max = this._effectiveMax;\n\t\tconst min = this._effectiveMin;\n\t\tconst prevStartValue = this.getStoredPropertyState(\"startValue\") || 0;\n\t\tconst prevEndValue = this.getStoredPropertyState(\"endValue\") || 0;\n\t\tconst affectedValue = this._valueAffected;\n\n\t\t// The value according to which we update the UI can be either the startValue\n\t\t// or the endValue property. It is determined in _getClosestHandle()\n\t\t// depending on to which handle is closer the user interaction.\n\t\tif (affectedValue === \"startValue\") {\n\t\t\tthis._selectedRange = (prevEndValue - newValue) / (max - min);\n\t\t\tthis._firstHandlePositionFromStart = ((newValue - min) / (max - min)) * 100;\n\t\t} else if (affectedValue === \"endValue\") {\n\t\t\tthis._selectedRange = ((newValue - prevStartValue)) / (max - min);\n\t\t\tthis._secondHandlePositionFromStart = ((newValue - min) / (max - min)) * 100;\n\t\t} else {\n\t\t\t// When both values are changed - UI sync or moving the whole selected range:\n\t\t\tthis._selectedRange = ((this.endValue - this.startValue)) / (max - min);\n\t\t\tthis._firstHandlePositionFromStart = ((this.startValue - min) / (max - min)) * 100;\n\t\t\tthis._secondHandlePositionFromStart = ((this.endValue - min) / (max - min)) * 100;\n\t\t}\n\t}\n\n\t/**\n\t * Swaps the start and end values of the handles if one came accros the other:\n\t * - If the start value is greater than the endValue swap them and their handles\n\t * - If the endValue become less than the start value swap them and their handles\n\t *\n\t * Switches the focus to the opposite of the currently focused handle.\n\t *\n\t * Note: Only the property values are reversed, the DOM elements of the handles\n\t * corresponding to them are never switched.\n\t * @private\n\t */\n\t_swapValues() {\n\t\tconst affectedValue = this._valueAffected;\n\t\tif (!affectedValue) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (affectedValue === \"startValue\" && this.startValue > this.endValue) {\n\t\t\tconst prevEndValue = this.endValue;\n\t\t\tthis.endValue = this.startValue;\n\t\t\tthis.startValue = prevEndValue;\n\t\t}\n\n\t\tif (affectedValue === \"endValue\" && this.endValue < this.startValue) {\n\t\t\tconst prevStartValue = this.startValue;\n\t\t\tthis.startValue = this.endValue;\n\t\t\tthis.endValue = prevStartValue;\n\t\t}\n\n\t\tthis._setValuesAreReversed();\n\t\tthis._updateHandlesAndRange(this[affectedValue]);\n\t\tthis.focusInnerElement();\n\t\tthis.syncUIAndState();\n\t}\n\n\t/**\n\t * Flag that we have swapped the values of the 'start' and 'end' properties,\n\t * to correctly switch the focus within the component from one handle to another\n\t * when the swapping is finished. As we only swap property values and not\n\t * the handle elements themselves, we must also swap their focus.\n\t * @private\n\t */\n\t_setValuesAreReversed() {\n\t\tthis._reversedValues = !this._reversedValues;\n\t }\n\n\t _areValuesReversed() {\n\t\treturn this._reversedValues;\n\t}\n\n\tget tickmarksObject() {\n\t\tconst count = this._tickmarksCount;\n\t\tconst arr = [];\n\n\t\tif (this._hiddenTickmarks) {\n\t\t\treturn [false, false];\n\t\t}\n\n\t\tfor (let i = 0; i <= count; i++) {\n\t\t\tconst isBiggerThanStartValue = this._effectiveMin + (i * this.step) >= this.startValue;\n\t\t\tconst isBiggerThanEndValue = this._effectiveMin + (i * this.step) <= this.endValue;\n\n\t\t\tarr.push(isBiggerThanStartValue && isBiggerThanEndValue);\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\tget _startHandle() {\n\t\treturn this.shadowRoot!.querySelector<HTMLElement>(\".ui5-slider-handle--start\")!;\n\t}\n\n\tget _endHandle() {\n\t\treturn this.shadowRoot!.querySelector<HTMLElement>(\".ui5-slider-handle--end\")!;\n\t}\n\n\tget _progressBar() {\n\t\treturn this.shadowRoot!.querySelector<HTMLElement>(\".ui5-slider-progress\")!;\n\t}\n\n\tget _ariaLabelledByStartHandleRefs() {\n\t\treturn [`${this._id}-accName`, `${this._id}-startHandleDesc`].join(\" \").trim();\n\t}\n\n\tget _ariaLabelledByEndHandleRefs() {\n\t\treturn [`${this._id}-accName`, `${this._id}-endHandleDesc`].join(\" \").trim();\n\t}\n\n\tget _ariaLabelledByProgressBarRefs() {\n\t\treturn [`${this._id}-accName`, `${this._id}-sliderDesc`].join(\" \").trim();\n\t}\n\n\tget styles() {\n\t\treturn {\n\t\t\tprogress: {\n\t\t\t\t\"width\": `${this._selectedRange! * 100}%`,\n\t\t\t\t\"transform-origin\": `${this.directionStart} top`,\n\t\t\t\t[this.directionStart]: `${this._firstHandlePositionFromStart!}%`,\n\t\t\t},\n\t\t\tstartHandle: {\n\t\t\t\t[this.directionStart]: `${this._firstHandlePositionFromStart!}%`,\n\t\t\t},\n\t\t\tendHandle: {\n\t\t\t\t[this.directionStart]: `${this._secondHandlePositionFromStart!}%`,\n\t\t\t},\n\t\t\tlabel: {\n\t\t\t\t\"width\": `${this._labelWidth}%`,\n\t\t\t},\n\t\t\tlabelContainer: {\n\t\t\t\t\"width\": `100%`,\n\t\t\t\t[this.directionStart]: `-${this._labelWidth / 2}%`,\n\t\t\t},\n\t\t\ttooltip: {\n\t\t\t\t\"visibility\": `${this._tooltipVisibility}`,\n\t\t\t},\n\t\t};\n\t}\n\n\tstatic async onDefine() {\n\t\tRangeSlider.i18nBundle = await getI18nBundle(\"@ui5/webcomponents\");\n\t}\n}\n\nRangeSlider.define();\n\nexport default RangeSlider;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
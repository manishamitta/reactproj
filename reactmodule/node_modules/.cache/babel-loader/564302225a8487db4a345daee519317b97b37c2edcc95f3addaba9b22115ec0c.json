{"ast":null,"code":"var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar Slider_1;\nimport customElement from \"@ui5/webcomponents-base/dist/decorators/customElement.js\";\nimport property from \"@ui5/webcomponents-base/dist/decorators/property.js\";\nimport { getI18nBundle } from \"@ui5/webcomponents-base/dist/i18nBundle.js\";\nimport { isEscape } from \"@ui5/webcomponents-base/dist/Keys.js\";\nimport SliderBase from \"./SliderBase.js\";\nimport Icon from \"./Icon.js\";\n// Template\nimport SliderTemplate from \"./generated/templates/SliderTemplate.lit.js\";\n// Texts\nimport { SLIDER_ARIA_DESCRIPTION } from \"./generated/i18n/i18n-defaults.js\";\n/**\n * @class\n *\n * ### Overview\n * The Slider component represents a numerical range and a handle (grip).\n * The purpose of the component is to enable visual selection of a value in\n * a continuous numerical range by moving an adjustable handle.\n *\n * ### Structure\n * The most important properties of the Slider are:\n *\n * - min - The minimum value of the slider range.\n * - max - The maximum value of the slider range.\n * - value - The current value of the slider range.\n * - step - Determines the increments in which the slider will move.\n * - showTooltip - Determines if a tooltip should be displayed above the handle.\n * - showTickmarks - Displays a visual divider between the step values.\n * - labelInterval - Labels some or all of the tickmarks with their values.\n *\n * ### Usage\n * The most common use case is to select values on a continuous numerical scale (e.g. temperature, volume, etc. ).\n *\n * ### Responsive Behavior\n * The `ui5-slider` component adjusts to the size of its parent container by recalculating and\n * resizing the width of the control. You can move the slider handle in several different ways:\n *\n * - Drag and drop the handle to the desired value.\n * - Click/tap on the range bar to move the handle to that location.\n *\n * ### Keyboard Handling\n *\n * - `Left or Down Arrow` - Moves the handle one step to the left, effectively decreasing the component's value by `step` amount;\n * - `Right or Up Arrow` - Moves the handle one step to the right, effectively increasing the component's value by `step` amount;\n * - `Left or Down Arrow + Ctrl/Cmd` - Moves the handle to the left with step equal to 1/10th of the entire range, effectively decreasing the component's value by 1/10th of the range;\n * - `Right or Up Arrow + Ctrl/Cmd` - Moves the handle to the right with step equal to 1/10th of the entire range, effectively increasing the component's value by 1/10th of the range;\n * - `Plus` - Same as `Right or Up Arrow`;\n * - `Minus` - Same as `Left or Down Arrow`;\n * - `Home` - Moves the handle to the beginning of the range;\n * - `End` - Moves the handle to the end of the range;\n * - `Page Up` - Same as `Right or Up + Ctrl/Cmd`;\n * - `Page Down` - Same as `Left or Down + Ctrl/Cmd`;\n * - `Escape` - Resets the value property after interaction, to the position prior the component's focusing;\n *\n * ### ES6 Module Import\n *\n * `import \"@ui5/webcomponents/dist/Slider.js\";`\n * @constructor\n * @extends SliderBase\n * @since 1.0.0-rc.11\n * @public\n * @csspart progress-container - Used to style the progress container, the horizontal bar that visually represents the range between the minimum and maximum values, of the `ui5-slider`.\n * @csspart progress-bar - Used to style the progress bar, which shows the progress of the `ui5-slider`.\n * @csspart handle - Used to style the handle of the `ui5-slider`.\n */\nlet Slider = Slider_1 = class Slider extends SliderBase {\n  get formFormattedValue() {\n    return this.value.toString();\n  }\n  constructor() {\n    super();\n    /**\n     * Current value of the slider\n     * @default 0\n     * @formEvents change input\n     * @formProperty\n     * @public\n     */\n    this.value = 0;\n    this._progressPercentage = 0;\n    this._handlePositionFromStart = 0;\n    this._stateStorage.value = undefined;\n  }\n  /**\n   *\n   * Check if the previously saved state is outdated. That would mean\n   * either it is the initial rendering or that a property has been changed\n   * programmatically - because the previous state is always updated in\n   * the interaction handlers.\n   *\n   * Normalize current properties, update the previously stored state.\n   * Update the visual UI representation of the Slider.\n   *\n   */\n  onBeforeRendering() {\n    if (!this.isCurrentStateOutdated()) {\n      return;\n    }\n    this.notResized = true;\n    this.syncUIAndState();\n    this._updateHandleAndProgress(this.value);\n  }\n  syncUIAndState() {\n    // Validate step and update the stored state for the step property.\n    if (this.isPropertyUpdated(\"step\")) {\n      this._validateStep(this.step);\n      this.storePropertyState(\"step\");\n    }\n    // Recalculate the tickmarks and labels and update the stored state.\n    if (this.isPropertyUpdated(\"min\", \"max\", \"value\")) {\n      this.storePropertyState(\"min\", \"max\");\n      // Here the value props are changed programmatically (not by user interaction)\n      // and it won't be \"stepified\" (rounded to the nearest step). 'Clip' them within\n      // min and max bounderies and update the previous state reference.\n      this.value = SliderBase.clipValue(this.value, this._effectiveMin, this._effectiveMax);\n      this.updateStateStorageAndFireInputEvent(\"value\");\n      this.storePropertyState(\"value\");\n    }\n    // Labels must be updated if any of the min/max/step/labelInterval props are changed\n    if (this.labelInterval && this.showTickmarks) {\n      this._createLabels();\n    }\n    // Update the stored state for the labelInterval, if changed\n    if (this.isPropertyUpdated(\"labelInterval\")) {\n      this.storePropertyState(\"labelInterval\");\n    }\n  }\n  /**\n   * Called when the user starts interacting with the slider\n   * @private\n   */\n  _onmousedown(e) {\n    // If step is 0 no interaction is available because there is no constant\n    // (equal for all user environments) quantitative representation of the value\n    if (this.disabled || this.step === 0) {\n      return;\n    }\n    const newValue = this.handleDownBase(e);\n    this._valueOnInteractionStart = this.value;\n    // Set initial value if one is not set previously on focus in.\n    // It will be restored if ESC key is pressed.\n    if (this._valueInitial === undefined) {\n      this._valueInitial = this.value;\n    }\n    // Do not yet update the Slider if press is over a handle. It will be updated if the user drags the mouse.\n    const ctor = this.constructor;\n    if (!this._isHandlePressed(ctor.getPageXValueFromEvent(e))) {\n      this._updateHandleAndProgress(newValue);\n      this.value = newValue;\n      this.updateStateStorageAndFireInputEvent(\"value\");\n    }\n  }\n  _onfocusin() {\n    // Set initial value if one is not set previously on focus in.\n    // It will be restored if ESC key is pressed.\n    if (this._valueInitial === undefined) {\n      this._valueInitial = this.value;\n    }\n    if (this.showTooltip) {\n      this._tooltipVisibility = SliderBase.TOOLTIP_VISIBILITY.VISIBLE;\n    }\n  }\n  _onfocusout() {\n    // Prevent focusout when the focus is getting set within the slider internal\n    // element (on the handle), before the Slider' customElement itself is finished focusing\n    if (this._isFocusing()) {\n      this._preventFocusOut();\n      return;\n    }\n    // Reset focus state and the stored Slider's initial\n    // value that was saved when it was first focused in\n    this._valueInitial = undefined;\n    if (this.showTooltip) {\n      this._tooltipVisibility = SliderBase.TOOLTIP_VISIBILITY.HIDDEN;\n    }\n  }\n  /**\n   * Called when the user moves the slider\n   * @private\n   */\n  _handleMove(e) {\n    e.preventDefault();\n    // If step is 0 no interaction is available because there is no constant\n    // (equal for all user environments) quantitative representation of the value\n    if (this.disabled || this._effectiveStep === 0) {\n      return;\n    }\n    const ctor = this.constructor;\n    const newValue = ctor.getValueFromInteraction(e, this._effectiveStep, this._effectiveMin, this._effectiveMax, this.getBoundingClientRect(), this.directionStart);\n    this._updateHandleAndProgress(newValue);\n    this.value = newValue;\n    this.updateStateStorageAndFireInputEvent(\"value\");\n  }\n  /** Called when the user finish interacting with the slider\n   * @private\n   */\n  _handleUp() {\n    if (this._valueOnInteractionStart !== this.value) {\n      this.fireEvent(\"change\");\n    }\n    this.handleUpBase();\n    this._valueOnInteractionStart = undefined;\n  }\n  /** Determines if the press is over the handle\n   * @private\n   */\n  _isHandlePressed(clientX) {\n    const sliderHandleDomRect = this._sliderHandle.getBoundingClientRect();\n    return clientX >= sliderHandleDomRect.left && clientX <= sliderHandleDomRect.right;\n  }\n  /** Updates the UI representation of the progress bar and handle position\n   * @private\n   */\n  _updateHandleAndProgress(newValue) {\n    const max = this._effectiveMax;\n    const min = this._effectiveMin;\n    // The progress (completed) percentage of the slider.\n    this._progressPercentage = (newValue - min) / (max - min);\n    // How many pixels from the left end of the slider will be the placed the affected  by the user action handle\n    this._handlePositionFromStart = this._progressPercentage * 100;\n  }\n  _handleActionKeyPress(e) {\n    const min = this._effectiveMin;\n    const max = this._effectiveMax;\n    const currentValue = this.value;\n    const ctor = this.constructor;\n    const newValue = isEscape(e) ? this._valueInitial : ctor.clipValue(this._handleActionKeyPressBase(e, \"value\") + currentValue, min, max);\n    if (newValue !== currentValue) {\n      this._updateHandleAndProgress(newValue);\n      this.value = newValue;\n      this.updateStateStorageAndFireInputEvent(\"value\");\n    }\n  }\n  get styles() {\n    return {\n      progress: {\n        \"transform\": `scaleX(${this._progressPercentage})`,\n        \"transform-origin\": `${this.directionStart} top`\n      },\n      handle: {\n        [this.directionStart]: `${this._handlePositionFromStart}%`\n      },\n      label: {\n        \"width\": `${this._labelWidth}%`\n      },\n      labelContainer: {\n        \"width\": `100%`,\n        [this.directionStart]: `-${this._labelWidth / 2}%`\n      },\n      tooltip: {\n        \"visibility\": `${this._tooltipVisibility}`\n      }\n    };\n  }\n  get _sliderHandle() {\n    return this.shadowRoot.querySelector(\".ui5-slider-handle\");\n  }\n  get tooltipValue() {\n    const ctor = this.constructor;\n    const stepPrecision = ctor._getDecimalPrecisionOfNumber(this._effectiveStep);\n    return this.value.toFixed(stepPrecision);\n  }\n  get _ariaDisabled() {\n    return this.disabled || undefined;\n  }\n  get _ariaLabelledByText() {\n    return Slider_1.i18nBundle.getText(SLIDER_ARIA_DESCRIPTION);\n  }\n  static async onDefine() {\n    Slider_1.i18nBundle = await getI18nBundle(\"@ui5/webcomponents\");\n  }\n  get tickmarksObject() {\n    const count = this._tickmarksCount;\n    const arr = [];\n    if (this._hiddenTickmarks) {\n      return [true, false];\n    }\n    for (let i = 0; i <= count; i++) {\n      arr.push(this._effectiveMin + i * this.step <= this.value);\n    }\n    return arr;\n  }\n};\n__decorate([property({\n  type: Number\n})], Slider.prototype, \"value\", void 0);\nSlider = Slider_1 = __decorate([customElement({\n  tag: \"ui5-slider\",\n  languageAware: true,\n  formAssociated: true,\n  template: SliderTemplate,\n  dependencies: [Icon]\n})], Slider);\nSlider.define();\nexport default Slider;","map":{"version":3,"names":["customElement","property","getI18nBundle","isEscape","SliderBase","Icon","SliderTemplate","SLIDER_ARIA_DESCRIPTION","Slider","Slider_1","formFormattedValue","value","toString","constructor","_progressPercentage","_handlePositionFromStart","_stateStorage","undefined","onBeforeRendering","isCurrentStateOutdated","notResized","syncUIAndState","_updateHandleAndProgress","isPropertyUpdated","_validateStep","step","storePropertyState","clipValue","_effectiveMin","_effectiveMax","updateStateStorageAndFireInputEvent","labelInterval","showTickmarks","_createLabels","_onmousedown","e","disabled","newValue","handleDownBase","_valueOnInteractionStart","_valueInitial","ctor","_isHandlePressed","getPageXValueFromEvent","_onfocusin","showTooltip","_tooltipVisibility","TOOLTIP_VISIBILITY","VISIBLE","_onfocusout","_isFocusing","_preventFocusOut","HIDDEN","_handleMove","preventDefault","_effectiveStep","getValueFromInteraction","getBoundingClientRect","directionStart","_handleUp","fireEvent","handleUpBase","clientX","sliderHandleDomRect","_sliderHandle","left","right","max","min","_handleActionKeyPress","currentValue","_handleActionKeyPressBase","styles","progress","handle","label","_labelWidth","labelContainer","tooltip","shadowRoot","querySelector","tooltipValue","stepPrecision","_getDecimalPrecisionOfNumber","toFixed","_ariaDisabled","_ariaLabelledByText","i18nBundle","getText","onDefine","tickmarksObject","count","_tickmarksCount","arr","_hiddenTickmarks","i","push","__decorate","type","Number","tag","languageAware","formAssociated","template","dependencies","define"],"sources":["/home/user/projects/reactproj/node_modules/@ui5/webcomponents/src/Slider.ts"],"sourcesContent":["import customElement from \"@ui5/webcomponents-base/dist/decorators/customElement.js\";\nimport property from \"@ui5/webcomponents-base/dist/decorators/property.js\";\nimport { getI18nBundle } from \"@ui5/webcomponents-base/dist/i18nBundle.js\";\nimport type I18nBundle from \"@ui5/webcomponents-base/dist/i18nBundle.js\";\nimport { isEscape } from \"@ui5/webcomponents-base/dist/Keys.js\";\nimport type { IFormInputElement } from \"@ui5/webcomponents-base/dist/features/InputElementsFormSupport.js\";\nimport SliderBase from \"./SliderBase.js\";\nimport Icon from \"./Icon.js\";\n\n// Template\nimport SliderTemplate from \"./generated/templates/SliderTemplate.lit.js\";\n\n// Texts\nimport {\n\tSLIDER_ARIA_DESCRIPTION,\n} from \"./generated/i18n/i18n-defaults.js\";\n\n/**\n * @class\n *\n * ### Overview\n * The Slider component represents a numerical range and a handle (grip).\n * The purpose of the component is to enable visual selection of a value in\n * a continuous numerical range by moving an adjustable handle.\n *\n * ### Structure\n * The most important properties of the Slider are:\n *\n * - min - The minimum value of the slider range.\n * - max - The maximum value of the slider range.\n * - value - The current value of the slider range.\n * - step - Determines the increments in which the slider will move.\n * - showTooltip - Determines if a tooltip should be displayed above the handle.\n * - showTickmarks - Displays a visual divider between the step values.\n * - labelInterval - Labels some or all of the tickmarks with their values.\n *\n * ### Usage\n * The most common use case is to select values on a continuous numerical scale (e.g. temperature, volume, etc. ).\n *\n * ### Responsive Behavior\n * The `ui5-slider` component adjusts to the size of its parent container by recalculating and\n * resizing the width of the control. You can move the slider handle in several different ways:\n *\n * - Drag and drop the handle to the desired value.\n * - Click/tap on the range bar to move the handle to that location.\n *\n * ### Keyboard Handling\n *\n * - `Left or Down Arrow` - Moves the handle one step to the left, effectively decreasing the component's value by `step` amount;\n * - `Right or Up Arrow` - Moves the handle one step to the right, effectively increasing the component's value by `step` amount;\n * - `Left or Down Arrow + Ctrl/Cmd` - Moves the handle to the left with step equal to 1/10th of the entire range, effectively decreasing the component's value by 1/10th of the range;\n * - `Right or Up Arrow + Ctrl/Cmd` - Moves the handle to the right with step equal to 1/10th of the entire range, effectively increasing the component's value by 1/10th of the range;\n * - `Plus` - Same as `Right or Up Arrow`;\n * - `Minus` - Same as `Left or Down Arrow`;\n * - `Home` - Moves the handle to the beginning of the range;\n * - `End` - Moves the handle to the end of the range;\n * - `Page Up` - Same as `Right or Up + Ctrl/Cmd`;\n * - `Page Down` - Same as `Left or Down + Ctrl/Cmd`;\n * - `Escape` - Resets the value property after interaction, to the position prior the component's focusing;\n *\n * ### ES6 Module Import\n *\n * `import \"@ui5/webcomponents/dist/Slider.js\";`\n * @constructor\n * @extends SliderBase\n * @since 1.0.0-rc.11\n * @public\n * @csspart progress-container - Used to style the progress container, the horizontal bar that visually represents the range between the minimum and maximum values, of the `ui5-slider`.\n * @csspart progress-bar - Used to style the progress bar, which shows the progress of the `ui5-slider`.\n * @csspart handle - Used to style the handle of the `ui5-slider`.\n */\n@customElement({\n\ttag: \"ui5-slider\",\n\tlanguageAware: true,\n\tformAssociated: true,\n\ttemplate: SliderTemplate,\n\tdependencies: [Icon],\n})\nclass Slider extends SliderBase implements IFormInputElement {\n\t/**\n\t * Current value of the slider\n\t * @default 0\n\t * @formEvents change input\n\t * @formProperty\n\t * @public\n\t */\n\t@property({ type: Number })\n\tvalue = 0;\n\n\t_valueInitial?: number;\n\t_valueOnInteractionStart?: number;\n\t_progressPercentage = 0;\n\t_handlePositionFromStart = 0;\n\n\tget formFormattedValue() {\n\t\treturn this.value.toString();\n\t}\n\n\tstatic i18nBundle: I18nBundle;\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._stateStorage.value = undefined;\n\t}\n\n\t/**\n\t *\n\t * Check if the previously saved state is outdated. That would mean\n\t * either it is the initial rendering or that a property has been changed\n\t * programmatically - because the previous state is always updated in\n\t * the interaction handlers.\n\t *\n\t * Normalize current properties, update the previously stored state.\n\t * Update the visual UI representation of the Slider.\n\t *\n\t */\n\tonBeforeRendering() {\n\t\tif (!this.isCurrentStateOutdated()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.notResized = true;\n\t\tthis.syncUIAndState();\n\t\tthis._updateHandleAndProgress(this.value);\n\t}\n\n\tsyncUIAndState() {\n\t\t// Validate step and update the stored state for the step property.\n\t\tif (this.isPropertyUpdated(\"step\")) {\n\t\t\tthis._validateStep(this.step);\n\t\t\tthis.storePropertyState(\"step\");\n\t\t}\n\n\t\t// Recalculate the tickmarks and labels and update the stored state.\n\t\tif (this.isPropertyUpdated(\"min\", \"max\", \"value\")) {\n\t\t\tthis.storePropertyState(\"min\", \"max\");\n\n\t\t\t// Here the value props are changed programmatically (not by user interaction)\n\t\t\t// and it won't be \"stepified\" (rounded to the nearest step). 'Clip' them within\n\t\t\t// min and max bounderies and update the previous state reference.\n\t\t\tthis.value = SliderBase.clipValue(this.value, this._effectiveMin, this._effectiveMax);\n\t\t\tthis.updateStateStorageAndFireInputEvent(\"value\");\n\t\t\tthis.storePropertyState(\"value\");\n\t\t}\n\n\t\t// Labels must be updated if any of the min/max/step/labelInterval props are changed\n\t\tif (this.labelInterval && this.showTickmarks) {\n\t\t\tthis._createLabels();\n\t\t}\n\n\t\t// Update the stored state for the labelInterval, if changed\n\t\tif (this.isPropertyUpdated(\"labelInterval\")) {\n\t\t\tthis.storePropertyState(\"labelInterval\");\n\t\t}\n\t}\n\n\t/**\n\t * Called when the user starts interacting with the slider\n\t * @private\n\t */\n\t_onmousedown(e: TouchEvent | MouseEvent) {\n\t\t// If step is 0 no interaction is available because there is no constant\n\t\t// (equal for all user environments) quantitative representation of the value\n\t\tif (this.disabled || this.step === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst newValue = this.handleDownBase(e);\n\t\tthis._valueOnInteractionStart = this.value;\n\n\t\t// Set initial value if one is not set previously on focus in.\n\t\t// It will be restored if ESC key is pressed.\n\t\tif (this._valueInitial === undefined) {\n\t\t\tthis._valueInitial = this.value;\n\t\t}\n\n\t\t// Do not yet update the Slider if press is over a handle. It will be updated if the user drags the mouse.\n\t\tconst ctor = this.constructor as typeof Slider;\n\t\tif (!this._isHandlePressed(ctor.getPageXValueFromEvent(e))) {\n\t\t\tthis._updateHandleAndProgress(newValue);\n\t\t\tthis.value = newValue;\n\t\t\tthis.updateStateStorageAndFireInputEvent(\"value\");\n\t\t}\n\t}\n\n\t_onfocusin() {\n\t\t// Set initial value if one is not set previously on focus in.\n\t\t// It will be restored if ESC key is pressed.\n\t\tif (this._valueInitial === undefined) {\n\t\t\tthis._valueInitial = this.value;\n\t\t}\n\n\t\tif (this.showTooltip) {\n\t\t\tthis._tooltipVisibility = SliderBase.TOOLTIP_VISIBILITY.VISIBLE;\n\t\t}\n\t}\n\n\t_onfocusout() {\n\t\t// Prevent focusout when the focus is getting set within the slider internal\n\t\t// element (on the handle), before the Slider' customElement itself is finished focusing\n\t\tif (this._isFocusing()) {\n\t\t\tthis._preventFocusOut();\n\t\t\treturn;\n\t\t}\n\n\t\t// Reset focus state and the stored Slider's initial\n\t\t// value that was saved when it was first focused in\n\t\tthis._valueInitial = undefined;\n\n\t\tif (this.showTooltip) {\n\t\t\tthis._tooltipVisibility = SliderBase.TOOLTIP_VISIBILITY.HIDDEN;\n\t\t}\n\t}\n\n\t/**\n\t * Called when the user moves the slider\n\t * @private\n\t */\n\t_handleMove(e: TouchEvent | MouseEvent) {\n\t\te.preventDefault();\n\n\t\t// If step is 0 no interaction is available because there is no constant\n\t\t// (equal for all user environments) quantitative representation of the value\n\t\tif (this.disabled || this._effectiveStep === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst ctor = this.constructor as typeof Slider;\n\t\tconst newValue = ctor.getValueFromInteraction(e, this._effectiveStep, this._effectiveMin, this._effectiveMax, this.getBoundingClientRect(), this.directionStart);\n\n\t\tthis._updateHandleAndProgress(newValue);\n\t\tthis.value = newValue;\n\t\tthis.updateStateStorageAndFireInputEvent(\"value\");\n\t}\n\n\t/** Called when the user finish interacting with the slider\n\t * @private\n\t */\n\t_handleUp() {\n\t\tif (this._valueOnInteractionStart !== this.value) {\n\t\t\tthis.fireEvent(\"change\");\n\t\t}\n\n\t\tthis.handleUpBase();\n\t\tthis._valueOnInteractionStart = undefined;\n\t}\n\n\t/** Determines if the press is over the handle\n\t * @private\n\t */\n\t_isHandlePressed(clientX: number) {\n\t\tconst sliderHandleDomRect = this._sliderHandle.getBoundingClientRect();\n\t\treturn clientX >= sliderHandleDomRect.left && clientX <= sliderHandleDomRect.right;\n\t}\n\n\t/** Updates the UI representation of the progress bar and handle position\n\t * @private\n\t */\n\t_updateHandleAndProgress(newValue: number) {\n\t\tconst max = this._effectiveMax;\n\t\tconst min = this._effectiveMin;\n\n\t\t// The progress (completed) percentage of the slider.\n\t\tthis._progressPercentage = (newValue - min) / (max - min);\n\t\t// How many pixels from the left end of the slider will be the placed the affected  by the user action handle\n\t\tthis._handlePositionFromStart = this._progressPercentage * 100;\n\t}\n\n\t_handleActionKeyPress(e: KeyboardEvent) {\n\t\tconst min = this._effectiveMin;\n\t\tconst max = this._effectiveMax;\n\t\tconst currentValue = this.value;\n\t\tconst ctor = this.constructor as typeof Slider;\n\t\tconst newValue = isEscape(e) ? this._valueInitial : ctor.clipValue(this._handleActionKeyPressBase(e, \"value\") + currentValue, min, max);\n\n\t\tif (newValue !== currentValue) {\n\t\t\tthis._updateHandleAndProgress(newValue!);\n\t\t\tthis.value = newValue!;\n\t\t\tthis.updateStateStorageAndFireInputEvent(\"value\");\n\t\t}\n\t}\n\n\tget styles() {\n\t\treturn {\n\t\t\tprogress: {\n\t\t\t\t\"transform\": `scaleX(${this._progressPercentage})`,\n\t\t\t\t\"transform-origin\": `${this.directionStart} top`,\n\t\t\t},\n\t\t\thandle: {\n\t\t\t\t[this.directionStart]: `${this._handlePositionFromStart}%`,\n\t\t\t},\n\t\t\tlabel: {\n\t\t\t\t\"width\": `${this._labelWidth}%`,\n\t\t\t},\n\t\t\tlabelContainer: {\n\t\t\t\t\"width\": `100%`,\n\t\t\t\t[this.directionStart]: `-${this._labelWidth / 2}%`,\n\t\t\t},\n\t\t\ttooltip: {\n\t\t\t\t\"visibility\": `${this._tooltipVisibility}`,\n\t\t\t},\n\t\t};\n\t}\n\n\tget _sliderHandle() {\n\t\treturn this.shadowRoot!.querySelector(\".ui5-slider-handle\")!;\n\t}\n\n\tget tooltipValue() {\n\t\tconst ctor = this.constructor as typeof Slider;\n\t\tconst stepPrecision = ctor._getDecimalPrecisionOfNumber(this._effectiveStep);\n\t\treturn this.value.toFixed(stepPrecision);\n\t}\n\n\tget _ariaDisabled() {\n\t\treturn this.disabled || undefined;\n\t}\n\n\tget _ariaLabelledByText() {\n\t\treturn Slider.i18nBundle.getText(SLIDER_ARIA_DESCRIPTION);\n\t}\n\n\tstatic async onDefine() {\n\t\tSlider.i18nBundle = await getI18nBundle(\"@ui5/webcomponents\");\n\t}\n\n\tget tickmarksObject() {\n\t\tconst count = this._tickmarksCount;\n\t\tconst arr = [];\n\n\t\tif (this._hiddenTickmarks) {\n\t\t\treturn [true, false];\n\t\t}\n\n\t\tfor (let i = 0; i <= count; i++) {\n\t\t\tarr.push(this._effectiveMin + (i * this.step) <= this.value);\n\t\t}\n\n\t\treturn arr;\n\t}\n}\n\nSlider.define();\n\nexport default Slider;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
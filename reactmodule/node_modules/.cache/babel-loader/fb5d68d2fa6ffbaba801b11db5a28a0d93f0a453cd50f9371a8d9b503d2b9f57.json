{"ast":null,"code":"\"use strict\";\n\nimport \"@ui5/webcomponents-base/dist/ssr-dom.js\";\nimport U from \"./thirdparty/merge.js\";\nimport { boot as T } from \"./Boot.js\";\nimport L from \"./UI5ElementMetadata.js\";\nimport S from \"./EventProvider.js\";\nimport F from \"./updateShadowRoot.js\";\nimport { shouldIgnoreCustomElement as N } from \"./IgnoreCustomElements.js\";\nimport { renderDeferred as V, renderImmediately as k, cancelRender as j } from \"./Render.js\";\nimport { registerTag as $, isTagRegistered as x, recordTagRegistrationFailure as z } from \"./CustomElementsRegistry.js\";\nimport { observeDOMNode as H, unobserveDOMNode as q } from \"./DOMObserver.js\";\nimport { skipOriginalEvent as W } from \"./config/NoConflict.js\";\nimport K from \"./locale/getEffectiveDir.js\";\nimport { kebabToCamelCase as g, camelToKebabCase as B, kebabToPascalCase as G } from \"./util/StringHelper.js\";\nimport w from \"./util/isValidPropertyName.js\";\nimport { getSlotName as J, getSlottedNodesList as b } from \"./util/SlotsHelper.js\";\nimport Q from \"./util/arraysAreEqual.js\";\nimport { markAsRtlAware as X } from \"./locale/RTLAwareRegistry.js\";\nimport Y from \"./renderer/executeTemplate.js\";\nimport { updateFormValue as Z, setFormValue as R } from \"./features/InputElementsFormSupport.js\";\nimport { getComponentFeature as tt, subscribeForFeatureLoad as et } from \"./FeaturesRegistry.js\";\nlet nt = 0;\nconst P = new Map(),\n  M = new Map(),\n  D = {\n    fromAttribute(d, u) {\n      return u === Boolean ? d !== null : u === Number ? d === null ? void 0 : parseFloat(d) : d;\n    },\n    toAttribute(d, u) {\n      return u === Boolean ? d ? \"\" : null : u === Object || u === Array || d == null ? null : String(d);\n    }\n  };\nfunction y(d) {\n  this._suppressInvalidation || (this.onInvalidation(d), this._changedState.push(d), V(this), this._invalidationEventProvider.fireEvent(\"invalidate\", {\n    ...d,\n    target: this\n  }));\n}\nfunction st(d, u) {\n  do {\n    const t = Object.getOwnPropertyDescriptor(d, u);\n    if (t) return t;\n    d = Object.getPrototypeOf(d);\n  } while (d && d !== HTMLElement.prototype);\n}\nclass I extends HTMLElement {\n  constructor() {\n    super();\n    this._rendered = !1;\n    const t = this.constructor;\n    this._changedState = [], this._suppressInvalidation = !0, this._inDOM = !1, this._fullyConnected = !1, this._childChangeListeners = new Map(), this._slotChangeListeners = new Map(), this._invalidationEventProvider = new S(), this._componentStateFinalizedEventProvider = new S();\n    let e;\n    this._domRefReadyPromise = new Promise(n => {\n      e = n;\n    }), this._domRefReadyPromise._deferredResolve = e, this._doNotSyncAttributes = new Set(), this._slotsAssignedNodes = new WeakMap(), this._state = {\n      ...t.getMetadata().getInitialState()\n    }, this.initializedProperties = new Map(), this.constructor.getMetadata().getPropertiesList().forEach(n => {\n      if (this.hasOwnProperty(n)) {\n        const o = this[n];\n        this.initializedProperties.set(n, o);\n      }\n    }), this._internals = this.attachInternals(), this._initShadowRoot();\n  }\n  _initShadowRoot() {\n    const t = this.constructor;\n    if (t._needsShadowDOM()) {\n      const e = {\n        mode: \"open\"\n      };\n      this.attachShadow({\n        ...e,\n        ...t.getMetadata().getShadowRootOptions()\n      }), t.getMetadata().slotsAreManaged() && this.shadowRoot.addEventListener(\"slotchange\", this._onShadowRootSlotChange.bind(this));\n    }\n  }\n  _onShadowRootSlotChange(t) {\n    t.target?.getRootNode() === this.shadowRoot && this._processChildren();\n  }\n  get _id() {\n    return this.__id || (this.__id = `ui5wc_${++nt}`), this.__id;\n  }\n  render() {\n    const t = this.constructor.template;\n    return Y(t, this);\n  }\n  async connectedCallback() {\n    const t = this.constructor;\n    this.setAttribute(t.getMetadata().getPureTag(), \"\"), t.getMetadata().supportsF6FastNavigation() && this.setAttribute(\"data-sap-ui-fastnavgroup\", \"true\");\n    const e = t.getMetadata().slotsAreManaged();\n    this._inDOM = !0, e && (this._startObservingDOMChildren(), await this._processChildren()), this._inDOM && (k(this), this._domRefReadyPromise._deferredResolve(), this._fullyConnected = !0, this.onEnterDOM());\n  }\n  disconnectedCallback() {\n    const e = this.constructor.getMetadata().slotsAreManaged();\n    this._inDOM = !1, e && this._stopObservingDOMChildren(), this._fullyConnected && (this.onExitDOM(), this._fullyConnected = !1), this._domRefReadyPromise._deferredResolve(), j(this);\n  }\n  onBeforeRendering() {}\n  onAfterRendering() {}\n  onEnterDOM() {}\n  onExitDOM() {}\n  _startObservingDOMChildren() {\n    const e = this.constructor.getMetadata();\n    if (!e.hasSlots()) return;\n    const n = e.canSlotText(),\n      o = {\n        childList: !0,\n        subtree: n,\n        characterData: n\n      };\n    H(this, this._processChildren.bind(this), o);\n  }\n  _stopObservingDOMChildren() {\n    q(this);\n  }\n  async _processChildren() {\n    this.constructor.getMetadata().hasSlots() && (await this._updateSlots());\n  }\n  async _updateSlots() {\n    const t = this.constructor,\n      e = t.getMetadata().getSlots(),\n      s = t.getMetadata().canSlotText(),\n      n = Array.from(s ? this.childNodes : this.children),\n      o = new Map(),\n      a = new Map();\n    for (const [r, f] of Object.entries(e)) {\n      const c = f.propertyName || r;\n      a.set(c, r), o.set(c, [...this._state[c]]), this._clearSlot(r, f);\n    }\n    const l = new Map(),\n      i = new Map(),\n      h = n.map(async (r, f) => {\n        const c = J(r),\n          m = e[c];\n        if (m === void 0) {\n          if (c !== \"default\") {\n            const p = Object.keys(e).join(\", \");\n            console.warn(`Unknown slotName: ${c}, ignoring`, r, `Valid values are: ${p}`);\n          }\n          return;\n        }\n        if (m.individualSlots) {\n          const p = (l.get(c) || 0) + 1;\n          l.set(c, p), r._individualSlot = `${c}-${p}`;\n        }\n        if (r instanceof HTMLElement) {\n          const p = r.localName;\n          if (p.includes(\"-\") && !N(p)) {\n            if (!customElements.get(p)) {\n              const A = customElements.whenDefined(p);\n              let E = P.get(p);\n              E || (E = new Promise(O => setTimeout(O, 1e3)), P.set(p, E)), await Promise.race([A, E]);\n            }\n            customElements.upgrade(r);\n          }\n        }\n        if (r = t.getMetadata().constructor.validateSlotValue(r, m), v(r) && m.invalidateOnChildChange) {\n          const p = this._getChildChangeListener(c);\n          r.attachInvalidate.call(r, p);\n        }\n        r instanceof HTMLSlotElement && this._attachSlotChange(r, c, !!m.invalidateOnChildChange);\n        const C = m.propertyName || c;\n        i.has(C) ? i.get(C).push({\n          child: r,\n          idx: f\n        }) : i.set(C, [{\n          child: r,\n          idx: f\n        }]);\n      });\n    await Promise.all(h), i.forEach((r, f) => {\n      this._state[f] = r.sort((c, m) => c.idx - m.idx).map(c => c.child), this._state[g(f)] = this._state[f];\n    });\n    let _ = !1;\n    for (const [r, f] of Object.entries(e)) {\n      const c = f.propertyName || r;\n      Q(o.get(c), this._state[c]) || (y.call(this, {\n        type: \"slot\",\n        name: a.get(c),\n        reason: \"children\"\n      }), _ = !0, t.getMetadata().isFormAssociated() && R(this));\n    }\n    _ || y.call(this, {\n      type: \"slot\",\n      name: \"default\",\n      reason: \"textcontent\"\n    });\n  }\n  _clearSlot(t, e) {\n    const s = e.propertyName || t;\n    this._state[s].forEach(o => {\n      if (v(o)) {\n        const a = this._getChildChangeListener(t);\n        o.detachInvalidate.call(o, a);\n      }\n      o instanceof HTMLSlotElement && this._detachSlotChange(o, t);\n    }), this._state[s] = [], this._state[g(s)] = this._state[s];\n  }\n  attachInvalidate(t) {\n    this._invalidationEventProvider.attachEvent(\"invalidate\", t);\n  }\n  detachInvalidate(t) {\n    this._invalidationEventProvider.detachEvent(\"invalidate\", t);\n  }\n  _onChildChange(t, e) {\n    this.constructor.getMetadata().shouldInvalidateOnChildChange(t, e.type, e.name) && y.call(this, {\n      type: \"slot\",\n      name: t,\n      reason: \"childchange\",\n      child: e.target\n    });\n  }\n  attributeChangedCallback(t, e, s) {\n    let n;\n    if (this._doNotSyncAttributes.has(t)) return;\n    const o = this.constructor.getMetadata().getProperties(),\n      a = t.replace(/^ui5-/, \"\"),\n      l = g(a);\n    if (o.hasOwnProperty(l)) {\n      const i = o[l];\n      n = (i.converter ?? D).fromAttribute(s, i.type), this[l] = n;\n    }\n  }\n  formAssociatedCallback() {\n    this.constructor.getMetadata().isFormAssociated() && Z(this);\n  }\n  static get formAssociated() {\n    return this.getMetadata().isFormAssociated();\n  }\n  _updateAttribute(t, e) {\n    const s = this.constructor;\n    if (!s.getMetadata().hasAttribute(t)) return;\n    const o = s.getMetadata().getProperties()[t],\n      a = B(t),\n      i = (o.converter || D).toAttribute(e, o.type);\n    this._doNotSyncAttributes.add(a), i == null ? this.removeAttribute(a) : this.setAttribute(a, i), this._doNotSyncAttributes.delete(a);\n  }\n  _getChildChangeListener(t) {\n    return this._childChangeListeners.has(t) || this._childChangeListeners.set(t, this._onChildChange.bind(this, t)), this._childChangeListeners.get(t);\n  }\n  _getSlotChangeListener(t) {\n    return this._slotChangeListeners.has(t) || this._slotChangeListeners.set(t, this._onSlotChange.bind(this, t)), this._slotChangeListeners.get(t);\n  }\n  _attachSlotChange(t, e, s) {\n    const n = this._getSlotChangeListener(e);\n    t.addEventListener(\"slotchange\", o => {\n      if (n.call(t, o), s) {\n        const a = this._slotsAssignedNodes.get(t);\n        a && a.forEach(i => {\n          if (v(i)) {\n            const h = this._getChildChangeListener(e);\n            i.detachInvalidate.call(i, h);\n          }\n        });\n        const l = b([t]);\n        this._slotsAssignedNodes.set(t, l), l.forEach(i => {\n          if (v(i)) {\n            const h = this._getChildChangeListener(e);\n            i.attachInvalidate.call(i, h);\n          }\n        });\n      }\n    });\n  }\n  _detachSlotChange(t, e) {\n    t.removeEventListener(\"slotchange\", this._getSlotChangeListener(e));\n  }\n  _onSlotChange(t) {\n    y.call(this, {\n      type: \"slot\",\n      name: t,\n      reason: \"slotchange\"\n    });\n  }\n  onInvalidation(t) {}\n  updateAttributes() {\n    const e = this.constructor.getMetadata().getProperties();\n    for (const [s, n] of Object.entries(e)) this._updateAttribute(s, this[s]);\n  }\n  _render() {\n    const t = this.constructor,\n      e = t.getMetadata().hasIndividualSlots();\n    this.initializedProperties.size > 0 && (Array.from(this.initializedProperties.entries()).forEach(_ref => {\n      let [s, n] = _ref;\n      delete this[s], this[s] = n;\n    }), this.initializedProperties.clear()), this._suppressInvalidation = !0;\n    try {\n      this.onBeforeRendering(), this._rendered || this.updateAttributes(), this._componentStateFinalizedEventProvider.fireEvent(\"componentStateFinalized\");\n    } finally {\n      this._suppressInvalidation = !1;\n    }\n    this._changedState = [], t._needsShadowDOM() && F(this), this._rendered = !0, e && this._assignIndividualSlotsToChildren(), this.onAfterRendering();\n  }\n  _assignIndividualSlotsToChildren() {\n    Array.from(this.children).forEach(e => {\n      e._individualSlot && e.setAttribute(\"slot\", e._individualSlot);\n    });\n  }\n  _waitForDomRef() {\n    return this._domRefReadyPromise;\n  }\n  getDomRef() {\n    if (typeof this._getRealDomRef == \"function\") return this._getRealDomRef();\n    if (!(!this.shadowRoot || this.shadowRoot.children.length === 0)) return this.shadowRoot.children[0];\n  }\n  getFocusDomRef() {\n    const t = this.getDomRef();\n    if (t) return t.querySelector(\"[data-sap-focus-ref]\") || t;\n  }\n  async getFocusDomRefAsync() {\n    return await this._waitForDomRef(), this.getFocusDomRef();\n  }\n  async focus(t) {\n    await this._waitForDomRef();\n    const e = this.getFocusDomRef();\n    e === this ? HTMLElement.prototype.focus.call(this, t) : e && typeof e.focus == \"function\" && e.focus(t);\n  }\n  fireEvent(t, e) {\n    let s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n    let n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !0;\n    const o = this._fireEvent(t, e, s, n),\n      a = G(t);\n    return a !== t ? o && this._fireEvent(a, e, s, n) : o;\n  }\n  _fireEvent(t, e) {\n    let s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n    let n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !0;\n    const o = new CustomEvent(`ui5-${t}`, {\n        detail: e,\n        composed: !1,\n        bubbles: n,\n        cancelable: s\n      }),\n      a = this.dispatchEvent(o);\n    if (W(t)) return a;\n    const l = new CustomEvent(t, {\n      detail: e,\n      composed: !1,\n      bubbles: n,\n      cancelable: s\n    });\n    return this.dispatchEvent(l) && a;\n  }\n  getSlottedNodes(t) {\n    return b(this[t]);\n  }\n  attachComponentStateFinalized(t) {\n    this._componentStateFinalizedEventProvider.attachEvent(\"componentStateFinalized\", t);\n  }\n  detachComponentStateFinalized(t) {\n    this._componentStateFinalizedEventProvider.detachEvent(\"componentStateFinalized\", t);\n  }\n  get effectiveDir() {\n    return X(this.constructor), K(this);\n  }\n  get isUI5Element() {\n    return !0;\n  }\n  get classes() {\n    return {};\n  }\n  get accessibilityInfo() {\n    return {};\n  }\n  static get observedAttributes() {\n    return this.getMetadata().getAttributesList();\n  }\n  static _needsShadowDOM() {\n    return !!this.template || Object.prototype.hasOwnProperty.call(this.prototype, \"render\");\n  }\n  static _generateAccessors() {\n    const t = this.prototype,\n      e = this.getMetadata().slotsAreManaged(),\n      s = this.getMetadata().getProperties();\n    for (const [n, o] of Object.entries(s)) {\n      w(n) || console.warn(`\"${n}\" is not a valid property name. Use a name that does not collide with DOM APIs`);\n      const a = st(t, n);\n      let l;\n      a?.set && (l = a.set);\n      let i;\n      a?.get && (i = a.get), Object.defineProperty(t, n, {\n        get() {\n          return i ? i.call(this) : this._state[n];\n        },\n        set(h) {\n          const _ = this.constructor,\n            r = i ? i.call(this) : this._state[n];\n          r !== h && (l ? l.call(this, h) : this._state[n] = h, y.call(this, {\n            type: \"property\",\n            name: n,\n            newValue: h,\n            oldValue: r\n          }), this._rendered && this._updateAttribute(n, h), _.getMetadata().isFormAssociated() && R(this));\n        }\n      });\n    }\n    if (e) {\n      const n = this.getMetadata().getSlots();\n      for (const [o, a] of Object.entries(n)) {\n        w(o) || console.warn(`\"${o}\" is not a valid property name. Use a name that does not collide with DOM APIs`);\n        const l = a.propertyName || o,\n          i = {\n            get() {\n              return this._state[l] !== void 0 ? this._state[l] : [];\n            },\n            set() {\n              throw new Error(\"Cannot set slot content directly, use the DOM APIs (appendChild, removeChild, etc...)\");\n            }\n          };\n        Object.defineProperty(t, l, i), l !== g(l) && Object.defineProperty(t, g(l), i);\n      }\n    }\n  }\n  static #_ = (() => this.metadata = {})();\n  static #_2 = (() => this.styles = \"\")();\n  static get dependencies() {\n    return [];\n  }\n  static cacheUniqueDependencies() {\n    const t = this.dependencies.filter((e, s, n) => n.indexOf(e) === s);\n    M.set(this, t);\n  }\n  static getUniqueDependencies() {\n    return M.has(this) || this.cacheUniqueDependencies(), M.get(this) || [];\n  }\n  static whenDependenciesDefined() {\n    return Promise.all(this.getUniqueDependencies().map(t => t.define()));\n  }\n  static async onDefine() {\n    return Promise.resolve();\n  }\n  static async define() {\n    await T(), await Promise.all([this.whenDependenciesDefined(), this.onDefine()]);\n    const t = this.getMetadata().getTag();\n    this.getMetadata().getFeatures().forEach(o => {\n      tt(o) && this.cacheUniqueDependencies(), et(o, this, this.cacheUniqueDependencies.bind(this));\n    });\n    const s = x(t),\n      n = customElements.get(t);\n    return n && !s ? z(t) : n || (this._generateAccessors(), $(t), customElements.define(t, this)), this;\n  }\n  static getMetadata() {\n    if (this.hasOwnProperty(\"_metadata\")) return this._metadata;\n    const t = [this.metadata];\n    let e = this;\n    for (; e !== I;) e = Object.getPrototypeOf(e), t.unshift(e.metadata);\n    const s = U({}, ...t);\n    return this._metadata = new L(s), this._metadata;\n  }\n  get validity() {\n    return this._internals.validity;\n  }\n  get validationMessage() {\n    return this._internals.validationMessage;\n  }\n  checkValidity() {\n    return this._internals.checkValidity();\n  }\n  reportValidity() {\n    return this._internals.reportValidity();\n  }\n}\nconst v = d => \"isUI5Element\" in d;\nexport default I;\nexport { v as instanceOfUI5Element };","map":{"version":3,"names":["U","boot","T","L","S","F","shouldIgnoreCustomElement","N","renderDeferred","V","renderImmediately","k","cancelRender","j","registerTag","$","isTagRegistered","x","recordTagRegistrationFailure","z","observeDOMNode","H","unobserveDOMNode","q","skipOriginalEvent","W","K","kebabToCamelCase","g","camelToKebabCase","B","kebabToPascalCase","G","w","getSlotName","J","getSlottedNodesList","b","Q","markAsRtlAware","X","Y","updateFormValue","Z","setFormValue","R","getComponentFeature","tt","subscribeForFeatureLoad","et","nt","P","Map","M","D","fromAttribute","d","u","Boolean","Number","parseFloat","toAttribute","Object","Array","String","y","_suppressInvalidation","onInvalidation","_changedState","push","_invalidationEventProvider","fireEvent","target","st","t","getOwnPropertyDescriptor","getPrototypeOf","HTMLElement","prototype","I","constructor","_rendered","_inDOM","_fullyConnected","_childChangeListeners","_slotChangeListeners","_componentStateFinalizedEventProvider","e","_domRefReadyPromise","Promise","n","_deferredResolve","_doNotSyncAttributes","Set","_slotsAssignedNodes","WeakMap","_state","getMetadata","getInitialState","initializedProperties","getPropertiesList","forEach","hasOwnProperty","o","set","_internals","attachInternals","_initShadowRoot","_needsShadowDOM","mode","attachShadow","getShadowRootOptions","slotsAreManaged","shadowRoot","addEventListener","_onShadowRootSlotChange","bind","getRootNode","_processChildren","_id","__id","render","template","connectedCallback","setAttribute","getPureTag","supportsF6FastNavigation","_startObservingDOMChildren","onEnterDOM","disconnectedCallback","_stopObservingDOMChildren","onExitDOM","onBeforeRendering","onAfterRendering","hasSlots","canSlotText","childList","subtree","characterData","_updateSlots","getSlots","s","from","childNodes","children","a","r","f","entries","c","propertyName","_clearSlot","l","i","h","map","m","p","keys","join","console","warn","individualSlots","get","_individualSlot","localName","includes","customElements","A","whenDefined","E","O","setTimeout","race","upgrade","validateSlotValue","v","invalidateOnChildChange","_getChildChangeListener","attachInvalidate","call","HTMLSlotElement","_attachSlotChange","C","has","child","idx","all","sort","_","type","name","reason","isFormAssociated","detachInvalidate","_detachSlotChange","attachEvent","detachEvent","_onChildChange","shouldInvalidateOnChildChange","attributeChangedCallback","getProperties","replace","converter","formAssociatedCallback","formAssociated","_updateAttribute","hasAttribute","add","removeAttribute","delete","_getSlotChangeListener","_onSlotChange","removeEventListener","updateAttributes","_render","hasIndividualSlots","size","_ref","clear","_assignIndividualSlotsToChildren","_waitForDomRef","getDomRef","_getRealDomRef","length","getFocusDomRef","querySelector","getFocusDomRefAsync","focus","arguments","undefined","_fireEvent","CustomEvent","detail","composed","bubbles","cancelable","dispatchEvent","getSlottedNodes","attachComponentStateFinalized","detachComponentStateFinalized","effectiveDir","isUI5Element","classes","accessibilityInfo","observedAttributes","getAttributesList","_generateAccessors","defineProperty","newValue","oldValue","Error","metadata","_2","styles","dependencies","cacheUniqueDependencies","filter","indexOf","getUniqueDependencies","whenDependenciesDefined","define","onDefine","resolve","getTag","getFeatures","_metadata","unshift","validity","validationMessage","checkValidity","reportValidity","instanceOfUI5Element"],"sources":["/home/user/projects/reactproj/node_modules/@ui5/webcomponents-base/src/UI5Element.ts"],"sourcesContent":["// eslint-disable-next-line import/no-extraneous-dependencies\nimport \"@ui5/webcomponents-base/dist/ssr-dom.js\";\nimport merge from \"./thirdparty/merge.js\";\nimport { boot } from \"./Boot.js\";\nimport UI5ElementMetadata from \"./UI5ElementMetadata.js\";\nimport type {\n\tSlot,\n\tSlotValue,\n\tState,\n\tPropertyValue,\n\tMetadata,\n} from \"./UI5ElementMetadata.js\";\nimport EventProvider from \"./EventProvider.js\";\nimport updateShadowRoot from \"./updateShadowRoot.js\";\nimport { shouldIgnoreCustomElement } from \"./IgnoreCustomElements.js\";\nimport {\n\trenderDeferred,\n\trenderImmediately,\n\tcancelRender,\n} from \"./Render.js\";\nimport { registerTag, isTagRegistered, recordTagRegistrationFailure } from \"./CustomElementsRegistry.js\";\nimport { observeDOMNode, unobserveDOMNode } from \"./DOMObserver.js\";\nimport { skipOriginalEvent } from \"./config/NoConflict.js\";\nimport getEffectiveDir from \"./locale/getEffectiveDir.js\";\nimport { kebabToCamelCase, camelToKebabCase, kebabToPascalCase } from \"./util/StringHelper.js\";\nimport isValidPropertyName from \"./util/isValidPropertyName.js\";\nimport { getSlotName, getSlottedNodesList } from \"./util/SlotsHelper.js\";\nimport arraysAreEqual from \"./util/arraysAreEqual.js\";\nimport { markAsRtlAware } from \"./locale/RTLAwareRegistry.js\";\nimport executeTemplate, { getTagsToScope } from \"./renderer/executeTemplate.js\";\nimport type { TemplateFunction, TemplateFunctionResult } from \"./renderer/executeTemplate.js\";\nimport type {\n\tAccessibilityInfo,\n\tPromiseResolve,\n\tComponentStylesData,\n\tClassMap,\n} from \"./types.js\";\nimport { updateFormValue, setFormValue } from \"./features/InputElementsFormSupport.js\";\nimport type { IFormInputElement } from \"./features/InputElementsFormSupport.js\";\nimport { getComponentFeature, subscribeForFeatureLoad } from \"./FeaturesRegistry.js\";\n\n;\nlet autoId = 0;\n\nconst elementTimeouts = new Map<string, Promise<void>>();\nconst uniqueDependenciesCache = new Map<typeof UI5Element, Array<typeof UI5Element>>();\n\ntype Renderer = (templateResult: TemplateFunctionResult, container: HTMLElement | DocumentFragment, options: RendererOptions) => void;\n\ntype RendererOptions = {\n\t/**\n\t * An object to use as the `this` value for event listeners. It's often\n\t * useful to set this to the host component rendering a template.\n\t */\n\thost?: object,\n}\n\ntype ChangeInfo = {\n\ttype: \"property\" | \"slot\",\n\tname: string,\n\treason?: string,\n\tchild?: SlotValue,\n\ttarget?: UI5Element,\n\tnewValue?: PropertyValue,\n\toldValue?: PropertyValue,\n}\n\ntype InvalidationInfo = ChangeInfo & { target: UI5Element };\n\ntype ChildChangeListener = (param: InvalidationInfo) => void;\n\ntype SlotChangeListener = (this: HTMLSlotElement, ev: Event) => void;\n\nconst defaultConverter = {\n\tfromAttribute(value: string | null, type: unknown) {\n\t\tif (type === Boolean) {\n\t\t\treturn value !== null;\n\t\t}\n\t\tif (type === Number) {\n\t\t\treturn value === null ? undefined : parseFloat(value);\n\t\t}\n\t\treturn value;\n\t},\n\ttoAttribute(value: unknown, type: unknown) {\n\t\tif (type === Boolean) {\n\t\t\treturn value as boolean ? \"\" : null;\n\t\t}\n\n\t\t// don't set attributes for arrays and objects\n\t\tif (type === Object || type === Array) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// object, array, other\n\t\tif (value === null || value === undefined) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn String(value);\n\t},\n};\n\n/**\n * Triggers re-rendering of a UI5Element instance due to state change.\n * @param {ChangeInfo} changeInfo An object with information about the change that caused invalidation.\n * @private\n */\nfunction _invalidate(this: UI5Element, changeInfo: ChangeInfo) {\n\t// Invalidation should be suppressed: 1) before the component is rendered for the first time 2) and during the execution of onBeforeRendering\n\t// This is necessary not only as an optimization, but also to avoid infinite loops on invalidation between children and parents (when invalidateOnChildChange is used)\n\tif (this._suppressInvalidation) {\n\t\treturn;\n\t}\n\n\t// Call the onInvalidation hook\n\tthis.onInvalidation(changeInfo);\n\n\tthis._changedState.push(changeInfo);\n\trenderDeferred(this);\n\tthis._invalidationEventProvider.fireEvent(\"invalidate\", { ...changeInfo, target: this });\n}\n\n/**\n * looks up a property descsriptor including in the prototype chain\n * @param proto the starting prototype\n * @param name the property to look for\n * @returns the property descriptor if found directly or in the prototype chaing, undefined if not found\n */\nfunction getPropertyDescriptor(proto: any, name: PropertyKey): PropertyDescriptor | undefined {\n\tdo {\n\t\tconst descriptor = Object.getOwnPropertyDescriptor(proto, name);\n\t\tif (descriptor) {\n\t\t\treturn descriptor;\n\t\t}\n\t\t// go up the prototype chain\n\t\tproto = Object.getPrototypeOf(proto);\n\t} while (proto && proto !== HTMLElement.prototype);\n}\n\n/**\n * @class\n * Base class for all UI5 Web Components\n *\n * @extends HTMLElement\n * @public\n */\nabstract class UI5Element extends HTMLElement {\n\t__id?: string;\n\t_suppressInvalidation: boolean;\n\t_changedState: Array<ChangeInfo>;\n\t_invalidationEventProvider: EventProvider<InvalidationInfo, void>;\n\t_componentStateFinalizedEventProvider: EventProvider<void, void>;\n\t_inDOM: boolean;\n\t_fullyConnected: boolean;\n\t_childChangeListeners: Map<string, ChildChangeListener>;\n\t_slotsAssignedNodes: WeakMap<HTMLSlotElement, Array<SlotValue>>;\n\t_slotChangeListeners: Map<string, SlotChangeListener>;\n\t_domRefReadyPromise: Promise<void> & { _deferredResolve?: PromiseResolve };\n\t_doNotSyncAttributes: Set<string>;\n\t_state: State;\n\t_internals: ElementInternals;\n\t_getRealDomRef?: () => HTMLElement;\n\n\tstatic template?: TemplateFunction;\n\tstatic _metadata: UI5ElementMetadata;\n\n\tstatic renderer: Renderer;\n\tinitializedProperties: Map<string, unknown>;\n\n\t// used to differentiate whether a setter is called from the constructor (from an initializer) or later\n\t// setters from the constructor should not set attributes, this is delegated after the first rendering but is async\n\t// setters after the constructor can set attributes synchronously for more convinient development\n\t_rendered = false;\n\n\tconstructor() {\n\t\tsuper();\n\n\t\tconst ctor = this.constructor as typeof UI5Element;\n\t\tthis._changedState = []; // Filled on each invalidation, cleared on re-render (used for debugging)\n\t\tthis._suppressInvalidation = true; // A flag telling whether all invalidations should be ignored. Initialized with \"true\" because a UI5Element can not be invalidated until it is rendered for the first time\n\t\tthis._inDOM = false; // A flag telling whether the UI5Element is currently in the DOM tree of the document or not\n\t\tthis._fullyConnected = false; // A flag telling whether the UI5Element's onEnterDOM hook was called (since it's possible to have the element removed from DOM before that)\n\t\tthis._childChangeListeners = new Map(); // used to store lazy listeners per slot for the child change event of every child inside that slot\n\t\tthis._slotChangeListeners = new Map(); // used to store lazy listeners per slot for the slotchange event of all slot children inside that slot\n\t\tthis._invalidationEventProvider = new EventProvider(); // used by parent components for listening to changes to child components\n\t\tthis._componentStateFinalizedEventProvider = new EventProvider(); // used by friend classes for synchronization\n\t\tlet deferredResolve;\n\t\tthis._domRefReadyPromise = new Promise(resolve => {\n\t\t\tdeferredResolve = resolve;\n\t\t});\n\t\tthis._domRefReadyPromise._deferredResolve = deferredResolve;\n\t\tthis._doNotSyncAttributes = new Set(); // attributes that are excluded from attributeChangedCallback synchronization\n\t\tthis._slotsAssignedNodes = new WeakMap(); // map of all nodes, slotted (directly or transitively) per component slot\n\n\t\tthis._state = { ...ctor.getMetadata().getInitialState() };\n\n\t\t// save properties set before element is upgraded, as they will be overriden by the field initializers in the constructor\n\t\tthis.initializedProperties = new Map();\n\t\tconst allProps = (this.constructor as typeof UI5Element).getMetadata().getPropertiesList();\n\t\tallProps.forEach(propertyName => {\n\t\t\tif (this.hasOwnProperty(propertyName)) { // eslint-disable-line\n\t\t\t\tconst value = (this as Record<string, unknown>)[propertyName];\n\t\t\t\tthis.initializedProperties.set(propertyName, value);\n\t\t\t}\n\t\t});\n\t\tthis._internals = this.attachInternals();\n\n\t\tthis._initShadowRoot();\n\t}\n\n\t_initShadowRoot() {\n\t\tconst ctor = this.constructor as typeof UI5Element;\n\t\tif (ctor._needsShadowDOM()) {\n\t\t\tconst defaultOptions = { mode: \"open\" } as ShadowRootInit;\n\t\t\tthis.attachShadow({ ...defaultOptions, ...ctor.getMetadata().getShadowRootOptions() });\n\n\t\t\tconst slotsAreManaged = ctor.getMetadata().slotsAreManaged();\n\t\t\tif (slotsAreManaged) {\n\t\t\t\tthis.shadowRoot!.addEventListener(\"slotchange\", this._onShadowRootSlotChange.bind(this));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Note: this \"slotchange\" listener is for slots, rendered in the component's shadow root\n\t */\n\t_onShadowRootSlotChange(e: Event) {\n\t\tconst targetShadowRoot = (e.target as Node)?.getRootNode(); // the \"slotchange\" event target is always a slot element\n\t\tif (targetShadowRoot === this.shadowRoot) { // only for slotchange events that originate from slots, belonging to the component's shadow root\n\t\t\tthis._processChildren();\n\t\t}\n\t}\n\n\t/**\n\t * Returns a unique ID for this UI5 Element\n\t *\n\t * @deprecated - This property is not guaranteed in future releases\n\t * @protected\n\t */\n\tget _id() {\n\t\tif (!this.__id) {\n\t\t\tthis.__id = `ui5wc_${++autoId}`;\n\t\t}\n\n\t\treturn this.__id;\n\t}\n\n\trender() {\n\t\tconst template = (this.constructor as typeof UI5Element).template;\n\t\treturn executeTemplate(template!, this);\n\t}\n\n\t/**\n\t * Do not call this method from derivatives of UI5Element, use \"onEnterDOM\" only\n\t * @private\n\t */\n\tasync connectedCallback() {\n\t\tif (false) {\n\t\t\tconst rootNode = this.getRootNode();\n\t\t\t// when an element is connected, check if it exists in the `dependencies` of the parent\n\t\t\tif (rootNode instanceof ShadowRoot && instanceOfUI5Element(rootNode.host)) {\n\t\t\t\tconst klass = rootNode.host.constructor as typeof UI5Element;\n\t\t\t\tconst hasDependency = getTagsToScope(rootNode.host).includes((this.constructor as typeof UI5Element).getMetadata().getPureTag());\n\t\t\t\tif (!hasDependency) {\n\t\t\t\t\t// eslint-disable-next-line no-console\n\t\t\t\t\tconsole.error(`[UI5-FWK] ${(this.constructor as typeof UI5Element).getMetadata().getTag()} not found in dependencies of ${klass.getMetadata().getTag()}`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (false) {\n\t\t\tconst props = (this.constructor as typeof UI5Element).getMetadata().getProperties();\n\t\t\tfor (const [prop, propData] of Object.entries(props)) { // eslint-disable-line\n\t\t\t\tif (Object.hasOwn(this, prop) && !this.initializedProperties.has(prop)) {\n\t\t\t\t\t// initialized properties should not trigger this error as they will be reassigned, only property initializers will trigger this in case unsupported TS mode\n\t\t\t\t\t// eslint-disable-next-line no-console\n\t\t\t\t\tconsole.error(`[UI5-FWK] ${(this.constructor as typeof UI5Element).getMetadata().getTag()} has a property [${prop}] that is shadowed by the instance. Updates to this property will not invalidate the component. Possible reason is TS target ES2022 or TS useDefineForClassFields`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst ctor = this.constructor as typeof UI5Element;\n\n\t\tthis.setAttribute(ctor.getMetadata().getPureTag(), \"\");\n\t\tif (ctor.getMetadata().supportsF6FastNavigation()) {\n\t\t\tthis.setAttribute(\"data-sap-ui-fastnavgroup\", \"true\");\n\t\t}\n\n\t\tconst slotsAreManaged = ctor.getMetadata().slotsAreManaged();\n\n\t\tthis._inDOM = true;\n\n\t\tif (slotsAreManaged) {\n\t\t\t// always register the observer before yielding control to the main thread (await)\n\t\t\tthis._startObservingDOMChildren();\n\t\t\tawait this._processChildren();\n\t\t}\n\n\t\tif (!this._inDOM) { // Component removed from DOM while _processChildren was running\n\t\t\treturn;\n\t\t}\n\n\t\trenderImmediately(this);\n\t\tthis._domRefReadyPromise._deferredResolve!();\n\t\tthis._fullyConnected = true;\n\t\tthis.onEnterDOM();\n\t}\n\n\t/**\n\t * Do not call this method from derivatives of UI5Element, use \"onExitDOM\" only\n\t * @private\n\t */\n\tdisconnectedCallback() {\n\t\tconst ctor = this.constructor as typeof UI5Element;\n\t\tconst slotsAreManaged = ctor.getMetadata().slotsAreManaged();\n\n\t\tthis._inDOM = false;\n\n\t\tif (slotsAreManaged) {\n\t\t\tthis._stopObservingDOMChildren();\n\t\t}\n\n\t\tif (this._fullyConnected) {\n\t\t\tthis.onExitDOM();\n\t\t\tthis._fullyConnected = false;\n\t\t}\n\n\t\tthis._domRefReadyPromise._deferredResolve!();\n\n\t\tcancelRender(this);\n\t}\n\n\t/**\n\t * Called every time before the component renders.\n\t * @public\n\t */\n\tonBeforeRendering(): void {}\n\n\t/**\n\t * Called every time after the component renders.\n\t * @public\n\t */\n\tonAfterRendering(): void {}\n\n\t/**\n\t * Called on connectedCallback - added to the DOM.\n\t * @public\n\t */\n\tonEnterDOM(): void {}\n\n\t/**\n\t * Called on disconnectedCallback - removed from the DOM.\n\t * @public\n\t */\n\tonExitDOM(): void {}\n\n\t/**\n\t * @private\n\t */\n\t_startObservingDOMChildren() {\n\t\tconst ctor = this.constructor as typeof UI5Element;\n\t\tconst metadata = ctor.getMetadata();\n\t\tconst shouldObserveChildren = metadata.hasSlots();\n\n\t\tif (!shouldObserveChildren) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst canSlotText = metadata.canSlotText();\n\t\tconst mutationObserverOptions = {\n\t\t\tchildList: true,\n\t\t\tsubtree: canSlotText,\n\t\t\tcharacterData: canSlotText,\n\t\t};\n\t\tobserveDOMNode(this, this._processChildren.bind(this) as MutationCallback, mutationObserverOptions);\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_stopObservingDOMChildren() {\n\t\tunobserveDOMNode(this);\n\t}\n\n\t/**\n\t * Note: this method is also manually called by \"compatibility/patchNodeValue.js\"\n\t * @private\n\t */\n\tasync _processChildren() {\n\t\tconst hasSlots = (this.constructor as typeof UI5Element).getMetadata().hasSlots();\n\t\tif (hasSlots) {\n\t\t\tawait this._updateSlots();\n\t\t}\n\t}\n\n\t/**\n\t * @private\n\t */\n\tasync _updateSlots() {\n\t\tconst ctor = this.constructor as typeof UI5Element;\n\t\tconst slotsMap = ctor.getMetadata().getSlots();\n\t\tconst canSlotText = ctor.getMetadata().canSlotText();\n\t\tconst domChildren = Array.from(canSlotText ? this.childNodes : this.children) as Array<Node>;\n\n\t\tconst slotsCachedContentMap = new Map<string, Array<SlotValue>>(); // Store here the content of each slot before the mutation occurred\n\t\tconst propertyNameToSlotMap = new Map<string, string>(); // Used for reverse lookup to determine to which slot the property name corresponds\n\n\t\t// Init the _state object based on the supported slots and store the previous values\n\t\tfor (const [slotName, slotData] of Object.entries(slotsMap)) { // eslint-disable-line\n\t\t\tconst propertyName = slotData.propertyName || slotName;\n\t\t\tpropertyNameToSlotMap.set(propertyName, slotName);\n\t\t\tslotsCachedContentMap.set(propertyName, [...(this._state[propertyName] as Array<SlotValue>)]);\n\t\t\tthis._clearSlot(slotName, slotData);\n\t\t}\n\n\t\tconst autoIncrementMap = new Map<string, number>();\n\t\tconst slottedChildrenMap = new Map<string, Array<{child: Node, idx: number }>>();\n\n\t\tconst allChildrenUpgraded = domChildren.map(async (child, idx) => {\n\t\t\t// Determine the type of the child (mainly by the slot attribute)\n\t\t\tconst slotName = getSlotName(child);\n\t\t\tconst slotData = slotsMap[slotName];\n\n\t\t\t// Check if the slotName is supported\n\t\t\tif (slotData === undefined) {\n\t\t\t\tif (slotName !== \"default\") {\n\t\t\t\t\tconst validValues = Object.keys(slotsMap).join(\", \");\n\t\t\t\t\tconsole.warn(`Unknown slotName: ${slotName}, ignoring`, child, `Valid values are: ${validValues}`); // eslint-disable-line\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// For children that need individual slots, calculate them\n\t\t\tif (slotData.individualSlots) {\n\t\t\t\tconst nextIndex = (autoIncrementMap.get(slotName) || 0) + 1;\n\t\t\t\tautoIncrementMap.set(slotName, nextIndex);\n\t\t\t\t(child as Record<string, any>)._individualSlot = `${slotName}-${nextIndex}`;\n\t\t\t}\n\n\t\t\t// Await for not-yet-defined custom elements\n\t\t\tif (child instanceof HTMLElement) {\n\t\t\t\tconst localName = child.localName;\n\t\t\t\tconst shouldWaitForCustomElement = localName.includes(\"-\") && !shouldIgnoreCustomElement(localName);\n\n\t\t\t\tif (shouldWaitForCustomElement) {\n\t\t\t\t\tconst isDefined = customElements.get(localName);\n\t\t\t\t\tif (!isDefined) {\n\t\t\t\t\t\tconst whenDefinedPromise = customElements.whenDefined(localName); // Class registered, but instances not upgraded yet\n\t\t\t\t\t\tlet timeoutPromise = elementTimeouts.get(localName);\n\t\t\t\t\t\tif (!timeoutPromise) {\n\t\t\t\t\t\t\ttimeoutPromise = new Promise(resolve => setTimeout(resolve, 1000));\n\t\t\t\t\t\t\telementTimeouts.set(localName, timeoutPromise);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tawait Promise.race([whenDefinedPromise, timeoutPromise]);\n\t\t\t\t\t}\n\t\t\t\t\tcustomElements.upgrade(child);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchild = (ctor.getMetadata().constructor as typeof UI5ElementMetadata).validateSlotValue(child, slotData);\n\n\t\t\t// Listen for any invalidation on the child if invalidateOnChildChange is true or an object (ignore when false or not set)\n\t\t\tif (instanceOfUI5Element(child) && slotData.invalidateOnChildChange) {\n\t\t\t\tconst childChangeListener = this._getChildChangeListener(slotName);\n\t\t\t\tchild.attachInvalidate.call(child, childChangeListener);\n\t\t\t}\n\n\t\t\t// Listen for the slotchange event if the child is a slot itself\n\t\t\tif (child instanceof HTMLSlotElement) {\n\t\t\t\tthis._attachSlotChange(child, slotName, !!slotData.invalidateOnChildChange);\n\t\t\t}\n\n\t\t\tconst propertyName = slotData.propertyName || slotName;\n\n\t\t\tif (slottedChildrenMap.has(propertyName)) {\n\t\t\t\tslottedChildrenMap.get(propertyName)!.push({ child, idx });\n\t\t\t} else {\n\t\t\t\tslottedChildrenMap.set(propertyName, [{ child, idx }]);\n\t\t\t}\n\t\t});\n\n\t\tawait Promise.all(allChildrenUpgraded);\n\n\t\t// Distribute the child in the _state object, keeping the Light DOM order,\n\t\t// not the order elements are defined.\n\t\tslottedChildrenMap.forEach((children, propertyName) => {\n\t\t\tthis._state[propertyName] = children.sort((a, b) => a.idx - b.idx).map(_ => _.child);\n\t\t\tthis._state[kebabToCamelCase(propertyName)] = this._state[propertyName];\n\t\t});\n\n\t\t// Compare the content of each slot with the cached values and invalidate for the ones that changed\n\t\tlet invalidated = false;\n\t\tfor (const [slotName, slotData] of Object.entries(slotsMap)) { // eslint-disable-line\n\t\t\tconst propertyName = slotData.propertyName || slotName;\n\t\t\tif (!arraysAreEqual(slotsCachedContentMap.get(propertyName)!, this._state[propertyName] as Array<SlotValue>)) {\n\t\t\t\t_invalidate.call(this, {\n\t\t\t\t\ttype: \"slot\",\n\t\t\t\t\tname: propertyNameToSlotMap.get(propertyName)!,\n\t\t\t\t\treason: \"children\",\n\t\t\t\t});\n\n\t\t\t\tinvalidated = true;\n\n\t\t\t\tif (ctor.getMetadata().isFormAssociated()) {\n\t\t\t\t\tsetFormValue(this as unknown as IFormInputElement);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If none of the slots had an invalidation due to changes to immediate children,\n\t\t// the change is considered to be text content of the default slot\n\t\tif (!invalidated) {\n\t\t\t_invalidate.call(this, {\n\t\t\t\ttype: \"slot\",\n\t\t\t\tname: \"default\",\n\t\t\t\treason: \"textcontent\",\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Removes all children from the slot and detaches listeners, if any\n\t * @private\n\t */\n\t_clearSlot(slotName: string, slotData: Slot) {\n\t\tconst propertyName = slotData.propertyName || slotName;\n\t\tconst children = this._state[propertyName] as Array<SlotValue>;\n\n\t\tchildren.forEach(child => {\n\t\t\tif (instanceOfUI5Element(child)) {\n\t\t\t\tconst childChangeListener = this._getChildChangeListener(slotName);\n\t\t\t\tchild.detachInvalidate.call(child, childChangeListener);\n\t\t\t}\n\n\t\t\tif (child instanceof HTMLSlotElement) {\n\t\t\t\tthis._detachSlotChange(child, slotName);\n\t\t\t}\n\t\t});\n\n\t\tthis._state[propertyName] = [];\n\t\tthis._state[kebabToCamelCase(propertyName)] = this._state[propertyName];\n\t}\n\n\t/**\n\t * Attach a callback that will be executed whenever the component is invalidated\n\t *\n\t * @param callback\n\t * @public\n\t */\n\tattachInvalidate(callback: (param: InvalidationInfo) => void): void {\n\t\tthis._invalidationEventProvider.attachEvent(\"invalidate\", callback);\n\t}\n\n\t/**\n\t * Detach the callback that is executed whenever the component is invalidated\n\t *\n\t * @param callback\n\t * @public\n\t */\n\tdetachInvalidate(callback: (param: InvalidationInfo) => void): void {\n\t\tthis._invalidationEventProvider.detachEvent(\"invalidate\", callback);\n\t}\n\n\t/**\n\t * Callback that is executed whenever a monitored child changes its state\n\t *\n\t * @param slotName the slot in which a child was invalidated\n\t * @param childChangeInfo the changeInfo object for the child in the given slot\n\t * @private\n\t */\n\t_onChildChange(slotName: string, childChangeInfo: ChangeInfo) {\n\t\tif (!(this.constructor as typeof UI5Element).getMetadata().shouldInvalidateOnChildChange(slotName, childChangeInfo.type, childChangeInfo.name)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// The component should be invalidated as this type of change on the child is listened for\n\t\t// However, no matter what changed on the child (property/slot), the invalidation is registered as \"type=slot\" for the component itself\n\t\t_invalidate.call(this, {\n\t\t\ttype: \"slot\",\n\t\t\tname: slotName,\n\t\t\treason: \"childchange\",\n\t\t\tchild: childChangeInfo.target,\n\t\t});\n\t}\n\n\t/**\n\t * Do not override this method in derivatives of UI5Element\n\t * @private\n\t */\n\tattributeChangedCallback(name: string, oldValue: string | null, newValue: string | null) {\n\t\tlet newPropertyValue: PropertyValue;\n\t\tif (this._doNotSyncAttributes.has(name)) { // This attribute is mutated internally, not by the user\n\t\t\treturn;\n\t\t}\n\n\t\tconst properties = (this.constructor as typeof UI5Element).getMetadata().getProperties();\n\t\tconst realName = name.replace(/^ui5-/, \"\");\n\t\tconst nameInCamelCase = kebabToCamelCase(realName);\n\t\tif (properties.hasOwnProperty(nameInCamelCase)) { // eslint-disable-line\n\t\t\tconst propData = properties[nameInCamelCase];\n\n\t\t\tconst converter = propData.converter ?? defaultConverter;\n\t\t\tnewPropertyValue = converter.fromAttribute(newValue, propData.type);\n\n\t\t\t(this as Record<string, any>)[nameInCamelCase] = newPropertyValue;\n\t\t}\n\t}\n\n\tformAssociatedCallback() {\n\t\tconst ctor = this.constructor as typeof UI5Element;\n\n\t\tif (!ctor.getMetadata().isFormAssociated()) {\n\t\t\treturn;\n\t\t}\n\n\t\tupdateFormValue(this);\n\t}\n\n\tstatic get formAssociated() {\n\t\treturn this.getMetadata().isFormAssociated();\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_updateAttribute(name: string, newValue: PropertyValue) {\n\t\tconst ctor = this.constructor as typeof UI5Element;\n\n\t\tif (!ctor.getMetadata().hasAttribute(name)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst properties = ctor.getMetadata().getProperties();\n\t\tconst propData = properties[name];\n\t\tconst attrName = camelToKebabCase(name);\n\t\tconst converter = propData.converter || defaultConverter;\n\n\t\tif (false) {\n\t\t\tconst tag = (this.constructor as typeof UI5Element).getMetadata().getTag();\n\t\t\tif (typeof newValue === \"boolean\" && propData.type !== Boolean) {\n\t\t\t\t// eslint-disable-next-line\n\t\t\t\tconsole.error(`[UI5-FWK] boolean value for property [${name}] of component [${tag}] is missing \"{ type: Boolean }\" in its property decorator. Attribute conversion will treat it as a string. If this is intended, pass the value converted to string, otherwise add the type to the property decorator`);\n\t\t\t}\n\t\t\tif (typeof newValue === \"number\" && propData.type !== Number) {\n\t\t\t\t// eslint-disable-next-line\n\t\t\t\tconsole.error(`[UI5-FWK] numeric value for property [${name}] of component [${tag}] is missing \"{ type: Number }\" in its property decorator. Attribute conversion will treat it as a string. If this is intended, pass the value converted to string, otherwise add the type to the property decorator`);\n\t\t\t}\n\t\t\tif (typeof newValue === \"string\" && propData.type && propData.type !== String) {\n\t\t\t\t// eslint-disable-next-line\n\t\t\t\tconsole.error(`[UI5-FWK] string value for property [${name}] of component [${tag}] which has a non-string type [${propData.type}] in its property decorator. Attribute conversion will stop and keep the string value in the property.`);\n\t\t\t}\n\t\t}\n\n\t\tconst newAttrValue = converter.toAttribute(newValue, propData.type);\n\t\tthis._doNotSyncAttributes.add(attrName); // skip the attributeChangedCallback call for this attribute\n\t\tif (newAttrValue === null || newAttrValue === undefined) { // null means there must be no attribute for the current value of the property\n\t\t\tthis.removeAttribute(attrName); // remove the attribute safely (will not trigger synchronization to the property value due to the above line)\n\t\t} else {\n\t\t\tthis.setAttribute(attrName, newAttrValue); // setting attributes from properties should not trigger the property setter again\n\t\t}\n\t\tthis._doNotSyncAttributes.delete(attrName); // enable synchronization again for this attribute\n\t}\n\n\t/**\n\t * Returns a singleton event listener for the \"change\" event of a child in a given slot\n\t *\n\t * @param slotName the name of the slot, where the child is\n\t * @private\n\t */\n\t_getChildChangeListener(slotName: string): ChildChangeListener {\n\t\tif (!this._childChangeListeners.has(slotName)) {\n\t\t\tthis._childChangeListeners.set(slotName, this._onChildChange.bind(this, slotName));\n\t\t}\n\t\treturn this._childChangeListeners.get(slotName)!;\n\t}\n\n\t/**\n\t * Returns a singleton slotchange event listener that invalidates the component due to changes in the given slot\n\t *\n\t * @param slotName the name of the slot, where the slot element (whose slotchange event we're listening to) is\n\t * @private\n\t */\n\t_getSlotChangeListener(slotName: string): SlotChangeListener {\n\t\tif (!this._slotChangeListeners.has(slotName)) {\n\t\t\tthis._slotChangeListeners.set(slotName, this._onSlotChange.bind(this, slotName));\n\t\t}\n\t\treturn this._slotChangeListeners.get(slotName)!;\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_attachSlotChange(slot: HTMLSlotElement, slotName: string, invalidateOnChildChange: boolean) {\n\t\tconst slotChangeListener = this._getSlotChangeListener(slotName);\n\t\tslot.addEventListener(\"slotchange\", (e: Event) => {\n\t\t\tslotChangeListener.call(slot, e);\n\n\t\t\tif (invalidateOnChildChange) {\n\t\t\t\t// Detach listeners for UI5 Elements that used to be in this slot\n\t\t\t\tconst previousChildren = this._slotsAssignedNodes.get(slot);\n\t\t\t\tif (previousChildren) {\n\t\t\t\t\tpreviousChildren.forEach(child => {\n\t\t\t\t\t\tif (instanceOfUI5Element(child)) {\n\t\t\t\t\t\t\tconst childChangeListener = this._getChildChangeListener(slotName);\n\t\t\t\t\t\t\tchild.detachInvalidate.call(child, childChangeListener);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Attach listeners for UI5 Elements that are now in this slot\n\t\t\t\tconst newChildren = getSlottedNodesList([slot]);\n\t\t\t\tthis._slotsAssignedNodes.set(slot, newChildren);\n\t\t\t\tnewChildren.forEach(child => {\n\t\t\t\t\tif (instanceOfUI5Element(child)) {\n\t\t\t\t\t\tconst childChangeListener = this._getChildChangeListener(slotName);\n\t\t\t\t\t\tchild.attachInvalidate.call(child, childChangeListener);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_detachSlotChange(child: HTMLSlotElement, slotName: string) {\n\t\tchild.removeEventListener(\"slotchange\", this._getSlotChangeListener(slotName));\n\t}\n\n\t/**\n\t * Whenever a slot element is slotted inside a UI5 Web Component, its slotchange event invalidates the component\n\t * Note: this \"slotchange\" listener is for slots that are children of the component (in the light dom, as opposed to slots rendered by the component in the shadow root)\n\t *\n\t * @param slotName the name of the slot, where the slot element (whose slotchange event we're listening to) is\n\t * @private\n\t */\n\t_onSlotChange(slotName: string) {\n\t\t_invalidate.call(this, {\n\t\t\ttype: \"slot\",\n\t\t\tname: slotName,\n\t\t\treason: \"slotchange\",\n\t\t});\n\t}\n\n\t/**\n\t * A callback that is executed each time an already rendered component is invalidated (scheduled for re-rendering)\n\t *\n\t * @param  changeInfo An object with information about the change that caused invalidation.\n\t * The object can have the following properties:\n\t *  - type: (property|slot) tells what caused the invalidation\n\t *   1) property: a property value was changed either directly or as a result of changing the corresponding attribute\n\t *   2) slot: a slotted node(nodes) changed in one of several ways (see \"reason\")\n\t *\n\t *  - name: the name of the property or slot that caused the invalidation\n\t *\n\t *  - reason: (children|textcontent|childchange|slotchange) relevant only for type=\"slot\" only and tells exactly what changed in the slot\n\t *   1) children: immediate children (HTML elements or text nodes) were added, removed or reordered in the slot\n\t *   2) textcontent: text nodes in the slot changed value (or nested text nodes were added or changed value). Can only trigger for slots of \"type: Node\"\n\t *   3) slotchange: a slot element, slotted inside that slot had its \"slotchange\" event listener called. This practically means that transitively slotted children changed.\n\t *\t  Can only trigger if the child of a slot is a slot element itself.\n\t *   4) childchange: indicates that a UI5Element child in that slot was invalidated and in turn invalidated the component.\n\t *\t  Can only trigger for slots with \"invalidateOnChildChange\" metadata descriptor\n\t *\n\t *  - newValue: the new value of the property (for type=\"property\" only)\n\t *\n\t *  - oldValue: the old value of the property (for type=\"property\" only)\n\t *\n\t *  - child the child that was changed (for type=\"slot\" and reason=\"childchange\" only)\n\t *\n\t * @public\n\t */\n\tonInvalidation(changeInfo: ChangeInfo): void {} // eslint-disable-line\n\n\tupdateAttributes() {\n\t\tconst ctor = this.constructor as typeof UI5Element;\n\t\tconst props = ctor.getMetadata().getProperties();\n\t\tfor (const [prop, propData] of Object.entries(props)) { // eslint-disable-line\n\t\t\tthis._updateAttribute(prop, (this as unknown as Record<string, PropertyValue>)[prop]);\n\t\t}\n\t}\n\n\t/**\n\t * Do not call this method directly, only intended to be called by js\n\t * @protected\n\t */\n\t_render() {\n\t\tconst ctor = this.constructor as typeof UI5Element;\n\t\tconst hasIndividualSlots = ctor.getMetadata().hasIndividualSlots();\n\n\t\t// restore properties that were initialized before `define` by calling the setter\n\t\tif (this.initializedProperties.size > 0) {\n\t\t\tArray.from(this.initializedProperties.entries()).forEach(([prop, value]) => {\n\t\t\t\tdelete (this as Record<string, unknown>)[prop];\n\t\t\t\t(this as Record<string, unknown>)[prop] = value;\n\t\t\t});\n\t\t\tthis.initializedProperties.clear();\n\t\t}\n\t\t// suppress invalidation to prevent state changes scheduling another rendering\n\t\tthis._suppressInvalidation = true;\n\n\t\ttry\t{\n\t\t\tthis.onBeforeRendering();\n\n\t\t\tif (!this._rendered) {\n\t\t\t\t// first time rendering, previous setters might have been initializers from the constructor - update attributes here\n\t\t\t\tthis.updateAttributes();\n\t\t\t}\n\n\t\t\t// Intended for framework usage only. Currently ItemNavigation updates tab indexes after the component has updated its state but before the template is rendered\n\t\t\tthis._componentStateFinalizedEventProvider.fireEvent(\"componentStateFinalized\");\n\t\t} finally {\n\t\t\t// always resume normal invalidation handling\n\t\t\tthis._suppressInvalidation = false;\n\t\t}\n\n\t\t// Update the shadow root with the render result\n\t\t/*\n\t\tif (this._changedState.length) {\n\t\t\tlet element = this.localName;\n\t\t\tif (this.id) {\n\t\t\t\telement = `${element}#${this.id}`;\n\t\t\t}\n\t\t\tconsole.log(\"Re-rendering:\", element, this._changedState.map(x => { // eslint-disable-line\n\t\t\t\tlet res = `${x.type}`;\n\t\t\t\tif (x.reason) {\n\t\t\t\t\tres = `${res}(${x.reason})`;\n\t\t\t\t}\n\t\t\t\tres = `${res}: ${x.name}`;\n\t\t\t\tif (x.type === \"property\") {\n\t\t\t\t\tres = `${res} ${JSON.stringify(x.oldValue)} => ${JSON.stringify(x.newValue)}`;\n\t\t\t\t}\n\n\t\t\t\treturn res;\n\t\t\t}));\n\t\t}\n\t\t*/\n\t\tthis._changedState = [];\n\n\t\t// Update shadow root and static area item\n\t\tif (ctor._needsShadowDOM()) {\n\t\t\tupdateShadowRoot(this);\n\t\t}\n\t\tthis._rendered = true;\n\n\t\t// Safari requires that children get the slot attribute only after the slot tags have been rendered in the shadow DOM\n\t\tif (hasIndividualSlots) {\n\t\t\tthis._assignIndividualSlotsToChildren();\n\t\t}\n\n\t\t// Call the onAfterRendering hook\n\t\tthis.onAfterRendering();\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_assignIndividualSlotsToChildren() {\n\t\tconst domChildren = Array.from(this.children);\n\n\t\tdomChildren.forEach((child: Record<string, any>) => {\n\t\t\tif (child._individualSlot) {\n\t\t\t\tchild.setAttribute(\"slot\", child._individualSlot);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_waitForDomRef() {\n\t\treturn this._domRefReadyPromise;\n\t}\n\n\t/**\n\t * Returns the DOM Element inside the Shadow Root that corresponds to the opening tag in the UI5 Web Component's template\n\t * *Note:* For logical (abstract) elements (items, options, etc...), returns the part of the parent's DOM that represents this option\n\t * Use this method instead of \"this.shadowRoot\" to read the Shadow DOM, if ever necessary\n\t *\n\t * @public\n\t */\n\tgetDomRef(): HTMLElement | undefined {\n\t\t// If a component set _getRealDomRef to its children, use the return value of this function\n\t\tif (typeof this._getRealDomRef === \"function\") {\n\t\t\treturn this._getRealDomRef();\n\t\t}\n\n\t\tif (!this.shadowRoot || this.shadowRoot.children.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn this.shadowRoot.children[0] as HTMLElement;\n\t}\n\n\t/**\n\t * Returns the DOM Element marked with \"data-sap-focus-ref\" inside the template.\n\t * This is the element that will receive the focus by default.\n\t * @public\n\t */\n\tgetFocusDomRef(): HTMLElement | undefined {\n\t\tconst domRef = this.getDomRef();\n\t\tif (domRef) {\n\t\t\tconst focusRef = domRef.querySelector(\"[data-sap-focus-ref]\") as HTMLElement;\n\t\t\treturn focusRef || domRef;\n\t\t}\n\t}\n\n\t/**\n\t * Waits for dom ref and then returns the DOM Element marked with \"data-sap-focus-ref\" inside the template.\n\t * This is the element that will receive the focus by default.\n\t * @public\n\t */\n\tasync getFocusDomRefAsync(): Promise<HTMLElement | undefined> {\n\t\tawait this._waitForDomRef();\n\t\treturn this.getFocusDomRef();\n\t}\n\n\t/**\n\t * Set the focus to the element, returned by \"getFocusDomRef()\" (marked by \"data-sap-focus-ref\")\n\t * @param focusOptions additional options for the focus\n\t * @public\n\t */\n\tasync focus(focusOptions?: FocusOptions): Promise<void> {\n\t\tawait this._waitForDomRef();\n\n\t\tconst focusDomRef = this.getFocusDomRef();\n\t\tif (focusDomRef === this) {\n\t\t\tHTMLElement.prototype.focus.call(this, focusOptions);\n\t\t} else if (focusDomRef && typeof focusDomRef.focus === \"function\") {\n\t\t\tfocusDomRef.focus(focusOptions);\n\t\t}\n\t}\n\n\t/**\n\t *\n\t * @public\n\t * @param name - name of the event\n\t * @param data - additional data for the event\n\t * @param cancelable - true, if the user can call preventDefault on the event object\n\t * @param bubbles - true, if the event bubbles\n\t * @returns false, if the event was cancelled (preventDefault called), true otherwise\n\t */\n\tfireEvent<T>(name: string, data?: T, cancelable = false, bubbles = true): boolean {\n\t\tconst eventResult = this._fireEvent(name, data, cancelable, bubbles);\n\t\tconst pascalCaseEventName = kebabToPascalCase(name);\n\n\t\t// pascal events are more convinient for native react usage\n\t\t// live-change:\n\t\t//\t Before: onlive-change\n\t\t//\t After: onLiveChange\n\t\tif (pascalCaseEventName !== name) {\n\t\t\treturn eventResult && this._fireEvent(pascalCaseEventName, data, cancelable, bubbles);\n\t\t}\n\n\t\treturn eventResult;\n\t}\n\n\t_fireEvent<T>(name: string, data?: T, cancelable = false, bubbles = true) {\n\t\tconst noConflictEvent = new CustomEvent<T>(`ui5-${name}`, {\n\t\t\tdetail: data,\n\t\t\tcomposed: false,\n\t\t\tbubbles,\n\t\t\tcancelable,\n\t\t});\n\n\t\t// This will be false if the no-conflict event is prevented\n\t\tconst noConflictEventResult = this.dispatchEvent(noConflictEvent);\n\n\t\tif (skipOriginalEvent(name)) {\n\t\t\treturn noConflictEventResult;\n\t\t}\n\n\t\tconst normalEvent = new CustomEvent<T>(name, {\n\t\t\tdetail: data,\n\t\t\tcomposed: false,\n\t\t\tbubbles,\n\t\t\tcancelable,\n\t\t});\n\n\t\t// This will be false if the normal event is prevented\n\t\tconst normalEventResult = this.dispatchEvent(normalEvent);\n\n\t\t// Return false if any of the two events was prevented (its result was false).\n\t\treturn normalEventResult && noConflictEventResult;\n\t}\n\n\t/**\n\t * Returns the actual children, associated with a slot.\n\t * Useful when there are transitive slots in nested component scenarios and you don't want to get a list of the slots, but rather of their content.\n\t * @public\n\t */\n\tgetSlottedNodes<T = Node>(slotName: string): Array<T> {\n\t\treturn getSlottedNodesList((this as unknown as Record<string, Array<SlotValue>>)[slotName]) as Array<T>;\n\t}\n\n\t/**\n\t * Attach a callback that will be executed whenever the component's state is finalized\n\t *\n\t * @param callback\n\t * @public\n\t */\n\tattachComponentStateFinalized(callback: () => void): void {\n\t\tthis._componentStateFinalizedEventProvider.attachEvent(\"componentStateFinalized\", callback);\n\t}\n\n\t/**\n\t * Detach the callback that is executed whenever the component's state is finalized\n\t *\n\t * @param callback\n\t * @public\n\t */\n\tdetachComponentStateFinalized(callback: () => void): void {\n\t\tthis._componentStateFinalizedEventProvider.detachEvent(\"componentStateFinalized\", callback);\n\t}\n\n\t/**\n\t * Determines whether the component should be rendered in RTL mode or not.\n\t * Returns: \"rtl\", \"ltr\" or undefined\n\t *\n\t * @public\n\t * @default undefined\n\t */\n\tget effectiveDir(): string | undefined {\n\t\tmarkAsRtlAware(this.constructor as typeof UI5Element); // if a UI5 Element calls this method, it's considered to be rtl-aware\n\t\treturn getEffectiveDir(this);\n\t}\n\n\t/**\n\t * Used to duck-type UI5 elements without using instanceof\n\t * @public\n\t * @default true\n\t */\n\tget isUI5Element(): boolean {\n\t\treturn true;\n\t}\n\n\tget classes(): ClassMap {\n\t\treturn {};\n\t}\n\n\t/**\n\t * Returns the component accessibility info.\n\t * @private\n\t */\n\tget accessibilityInfo(): AccessibilityInfo {\n\t\treturn {};\n\t}\n\n\t/**\n\t * Do not override this method in derivatives of UI5Element, use metadata properties instead\n\t * @private\n\t */\n\tstatic get observedAttributes() {\n\t\treturn this.getMetadata().getAttributesList();\n\t}\n\n\t/**\n\t * @private\n\t */\n\tstatic _needsShadowDOM() {\n\t\treturn !!this.template || Object.prototype.hasOwnProperty.call(this.prototype, \"render\");\n\t}\n\n\t/**\n\t * @private\n\t */\n\tstatic _generateAccessors() {\n\t\tconst proto = this.prototype;\n\t\tconst slotsAreManaged = this.getMetadata().slotsAreManaged();\n\n\t\t// Properties\n\t\tconst properties = this.getMetadata().getProperties();\n\t\tfor (const [prop, propData] of Object.entries(properties)) { // eslint-disable-line\n\t\t\tif (!isValidPropertyName(prop)) {\n\t\t\t\tconsole.warn(`\"${prop}\" is not a valid property name. Use a name that does not collide with DOM APIs`); /* eslint-disable-line */\n\t\t\t}\n\n\t\t\tconst descriptor = getPropertyDescriptor(proto, prop);\n\t\t\t// if the decorator is on a setter, proxy the new setter to it\n\t\t\tlet origSet: (v: any) => void;\n\t\t\tif (descriptor?.set) {\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/unbound-method\n\t\t\t\torigSet = descriptor.set;\n\t\t\t}\n\t\t\t// if the decorator is on a setter, there will be a corresponding getter - proxy the new getter to it\n\t\t\tlet origGet: () => PropertyValue;\n\t\t\tif (descriptor?.get) {\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/unbound-method\n\t\t\t\torigGet = descriptor.get;\n\t\t\t}\n\n\t\t\tObject.defineProperty(proto, prop, {\n\t\t\t\tget(this: UI5Element) {\n\t\t\t\t\t// proxy the getter to the original accessor if there was one\n\t\t\t\t\tif (origGet) {\n\t\t\t\t\t\treturn origGet.call(this);\n\t\t\t\t\t}\n\t\t\t\t\treturn this._state[prop];\n\t\t\t\t},\n\n\t\t\t\tset(this: UI5Element, value: PropertyValue) {\n\t\t\t\t\tconst ctor = this.constructor as typeof UI5Element;\n\t\t\t\t\tconst oldState = origGet ? origGet.call(this) : this._state[prop];\n\n\t\t\t\t\tconst isDifferent = oldState !== value;\n\t\t\t\t\tif (isDifferent) {\n\t\t\t\t\t\t// if the decorator is on a setter, use it for storage\n\t\t\t\t\t\tif (origSet) {\n\t\t\t\t\t\t\torigSet.call(this, value);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis._state[prop] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_invalidate.call(this, {\n\t\t\t\t\t\t\ttype: \"property\",\n\t\t\t\t\t\t\tname: prop,\n\t\t\t\t\t\t\tnewValue: value,\n\t\t\t\t\t\t\toldValue: oldState,\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tif (this._rendered) {\n\t\t\t\t\t\t\t// is already rendered so it is not the constructor - can set the attribute synchronously\n\t\t\t\t\t\t\tthis._updateAttribute(prop, value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (ctor.getMetadata().isFormAssociated()) {\n\t\t\t\t\t\t\tsetFormValue(this as unknown as IFormInputElement);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\n\t\t// Slots\n\t\tif (slotsAreManaged) {\n\t\t\tconst slots = this.getMetadata().getSlots();\n\t\t\tfor (const [slotName, slotData] of Object.entries(slots)) { // eslint-disable-line\n\t\t\t\tif (!isValidPropertyName(slotName)) {\n\t\t\t\t\tconsole.warn(`\"${slotName}\" is not a valid property name. Use a name that does not collide with DOM APIs`); /* eslint-disable-line */\n\t\t\t\t}\n\n\t\t\t\tconst propertyName = slotData.propertyName || slotName;\n\t\t\t\tconst propertyDescriptor: PropertyDescriptor = {\n\t\t\t\t\tget(this: UI5Element) {\n\t\t\t\t\t\tif (this._state[propertyName] !== undefined) {\n\t\t\t\t\t\t\treturn this._state[propertyName];\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn [];\n\t\t\t\t\t},\n\t\t\t\t\tset() {\n\t\t\t\t\t\tthrow new Error(\"Cannot set slot content directly, use the DOM APIs (appendChild, removeChild, etc...)\");\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t\tObject.defineProperty(proto, propertyName, propertyDescriptor);\n\t\t\t\tif (propertyName !== kebabToCamelCase(propertyName)) {\n\t\t\t\t\tObject.defineProperty(proto, kebabToCamelCase(propertyName), propertyDescriptor);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns the metadata object for this UI5 Web Component Class\n\t * @protected\n\t */\n\tstatic metadata: Metadata = {};\n\n\t/**\n\t * Returns the CSS for this UI5 Web Component Class\n\t * @protected\n\t */\n\tstatic styles: ComponentStylesData = \"\";\n\n\t/**\n\t * Returns an array with the dependencies for this UI5 Web Component, which could be:\n\t *  - composed components (used in its shadow root or static area item)\n\t *  - slotted components that the component may need to communicate with\n\t *\n\t * @protected\n\t */\n\tstatic get dependencies(): Array<typeof UI5Element> {\n\t\treturn [];\n\t}\n\n\tstatic cacheUniqueDependencies(this: typeof UI5Element): void {\n\t\tconst filtered = this.dependencies.filter((dep, index, deps) => deps.indexOf(dep) === index);\n\t\tuniqueDependenciesCache.set(this, filtered);\n\t}\n\n\t/**\n\t * Returns a list of the unique dependencies for this UI5 Web Component\n\t *\n\t * @public\n\t */\n\tstatic getUniqueDependencies(this: typeof UI5Element): Array<typeof UI5Element> {\n\t\tif (!uniqueDependenciesCache.has(this)) {\n\t\t\tthis.cacheUniqueDependencies();\n\t\t}\n\n\t\treturn uniqueDependenciesCache.get(this) || [];\n\t}\n\n\t/**\n\t * Returns a promise that resolves whenever all dependencies for this UI5 Web Component have resolved\n\t */\n\tstatic whenDependenciesDefined(): Promise<Array<typeof UI5Element>> {\n\t\treturn Promise.all(this.getUniqueDependencies().map(dep => dep.define()));\n\t}\n\n\t/**\n\t * Hook that will be called upon custom element definition\n\t *\n\t * @protected\n\t */\n\tstatic async onDefine(): Promise<void> {\n\t\treturn Promise.resolve();\n\t}\n\n\t/**\n\t * Registers a UI5 Web Component in the browser window object\n\t * @public\n\t */\n\tstatic async define(): Promise<typeof UI5Element> {\n\t\tawait boot();\n\n\t\tawait Promise.all([\n\t\t\tthis.whenDependenciesDefined(),\n\t\t\tthis.onDefine(),\n\t\t]);\n\n\t\tconst tag = this.getMetadata().getTag();\n\n\t\tconst features = this.getMetadata().getFeatures();\n\n\t\tfeatures.forEach(feature => {\n\t\t\tif (getComponentFeature(feature)) {\n\t\t\t\tthis.cacheUniqueDependencies();\n\t\t\t}\n\n\t\t\tsubscribeForFeatureLoad(feature, this, this.cacheUniqueDependencies.bind(this));\n\t\t});\n\n\t\tconst definedLocally = isTagRegistered(tag);\n\t\tconst definedGlobally = customElements.get(tag);\n\n\t\tif (definedGlobally && !definedLocally) {\n\t\t\trecordTagRegistrationFailure(tag);\n\t\t} else if (!definedGlobally) {\n\t\t\tthis._generateAccessors();\n\t\t\tregisterTag(tag);\n\t\t\tcustomElements.define(tag, this as unknown as CustomElementConstructor);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns an instance of UI5ElementMetadata.js representing this UI5 Web Component's full metadata (its and its parents')\n\t * Note: not to be confused with the \"get metadata()\" method, which returns an object for this class's metadata only\n\t * @public\n\t */\n\tstatic getMetadata(): UI5ElementMetadata {\n\t\tif (this.hasOwnProperty(\"_metadata\")) { // eslint-disable-line\n\t\t\treturn this._metadata;\n\t\t}\n\n\t\tconst metadataObjects = [this.metadata];\n\t\tlet klass = this; // eslint-disable-line\n\t\twhile (klass !== UI5Element) {\n\t\t\tklass = Object.getPrototypeOf(klass);\n\t\t\tmetadataObjects.unshift(klass.metadata);\n\t\t}\n\t\tconst mergedMetadata = merge({}, ...metadataObjects) as Metadata;\n\n\t\tthis._metadata = new UI5ElementMetadata(mergedMetadata);\n\t\treturn this._metadata;\n\t}\n\n\tget validity() { return this._internals.validity; }\n\tget validationMessage() { return this._internals.validationMessage; }\n\tcheckValidity() { return this._internals.checkValidity(); }\n\treportValidity() { return this._internals.reportValidity(); }\n}\n\n/**\n * Always use duck-typing to cover all runtimes on the page.\n */\nconst instanceOfUI5Element = (object: any): object is UI5Element => {\n\treturn \"isUI5Element\" in object;\n};\n\nexport default UI5Element;\nexport {\n\tinstanceOfUI5Element,\n};\nexport type {\n\tChangeInfo,\n\tRenderer,\n\tRendererOptions,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
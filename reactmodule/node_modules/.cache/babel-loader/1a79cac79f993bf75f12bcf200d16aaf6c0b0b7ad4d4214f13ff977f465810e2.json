{"ast":null,"code":"/*!\n * OpenUI5\n * (c) Copyright 2009-2024 SAP SE or an SAP affiliate company.\n * Licensed under the Apache License, Version 2.0 - see LICENSE.txt.\n */\nimport assert from \"../assert.js\";\n/**\n * Pattern to analyze MessageFormat strings.\n *\n * Group 1: captures doubled single quotes within the string\n * Group 2: captures quoted fragments within the string.\n *            Note that java.util.MessageFormat silently forgives a missing single quote at\n *            the end of a pattern. This special case is handled by the RegEx as well.\n * Group 3: captures placeholders\n *            Checks only for numerical argument index, any remainder is ignored up to the next\n *            closing curly brace. Nested placeholders are not accepted!\n * Group 4: captures any remaining curly braces and indicates syntax errors\n *\n *                    [-1] [----- quoted string -----] [------ placeholder ------] [--]\n * @private\n */\nvar rMessageFormat = /('')|'([^']+(?:''[^']*)*)(?:'|$)|\\{([0-9]+(?:\\s*,[^{}]*)?)\\}|[{}]/g;\n\n/**\n * Creates a string from a pattern by replacing placeholders with concrete values.\n *\n * The syntax of the pattern is inspired by (but not fully equivalent to) the\n * java.util.MessageFormat.\n *\n * Placeholders have the form <code>{ integer }</code>, where any occurrence of\n * <code>{0}</code> is replaced by the value with index 0 in <code>aValues</code>,\n * <code>{1}</code> by the value with index 1 in <code>aValues</code> etc.\n *\n * To avoid interpretation of curly braces as placeholders, any non-placeholder fragment\n * of the pattern can be enclosed in single quotes. The surrounding single quotes will be\n * omitted from the result. Single quotes that are not meant to escape a fragment and\n * that should appear in the result, need to be doubled. In the result, only a single\n * single quote will occur.\n *\n * Example: Pattern Strings\n * <pre>\n *  formatMessage(\"Say {0}\",     [\"Hello\"]) -> \"Say Hello\"    // normal use case\n *  formatMessage(\"Say '{0}'\",   [\"Hello\"]) -> \"Say {0}\"      // escaped placeholder\n *  formatMessage(\"Say ''{0}''\", [\"Hello\"]) -> \"Say 'Hello'\"  // doubled single quote\n *  formatMessage(\"Say '{0}'''\", [\"Hello\"]) -> \"Say {0}'\"     // doubled single quote in quoted fragment\n * </pre>\n * In contrast to java.util.MessageFormat, format types or format styles are not supported.\n * Everything after the argument index and up to the first closing curly brace is ignored.\n * Nested placeholders (as supported by java.lang.MessageFormat for the format type choice)\n * are not ignored but reported as a parse error.\n *\n * This method throws an Error when the pattern syntax is not fulfilled (e.g. unbalanced curly\n * braces, nested placeholders or a non-numerical argument index).\n *\n * This method can also be used as a formatter within a binding. The first part of a composite binding\n * will be used as pattern, the following parts as aValues. If there is only one value and this\n * value is an array it will be handled like the default described above.\n *\n * @function\n * @since 1.58\n * @alias module:sap/base/strings/formatMessage\n * @param {string} sPattern A pattern string in the described syntax\n * @param {any[]} [aValues=[]] The values to be used instead of the placeholders.\n * @returns {string} The formatted result string\n * @SecPassthrough {*|return}\n * @public\n */\nvar fnFormatMessage = function (sPattern, aValues) {\n  assert(typeof sPattern === \"string\" || sPattern instanceof String, \"pattern must be string\");\n  if (arguments.length > 2 || aValues != null && !Array.isArray(aValues)) {\n    aValues = Array.prototype.slice.call(arguments, 1);\n  }\n  aValues = aValues || [];\n  return sPattern.replace(rMessageFormat, function ($0, $1, $2, $3, offset) {\n    if ($1) {\n      // a doubled single quote in a normal string fragment\n      //   --> emit a single quote\n      return \"'\";\n    } else if ($2) {\n      // a quoted sequence of chars, potentially containing doubled single quotes again\n      //   --> emit with doubled single quotes replaced by a single quote\n      return $2.replace(/''/g, \"'\");\n    } else if ($3) {\n      // a welformed curly brace\n      //   --> emit the argument but ignore other parameters\n      return String(aValues[parseInt($3)]);\n    }\n    // e.g. malformed curly braces\n    //   --> throw Error\n    throw new Error(\"formatMessage: pattern syntax error at pos. \" + offset);\n  });\n};\nexport default fnFormatMessage;","map":{"version":3,"names":["assert","rMessageFormat","fnFormatMessage","sPattern","aValues","String","arguments","length","Array","isArray","prototype","slice","call","replace","$0","$1","$2","$3","offset","parseInt","Error"],"sources":["/home/user/projects/reactproj/node_modules/@ui5/webcomponents-localization/dist/sap/base/strings/formatMessage.js"],"sourcesContent":["/*!\n * OpenUI5\n * (c) Copyright 2009-2024 SAP SE or an SAP affiliate company.\n * Licensed under the Apache License, Version 2.0 - see LICENSE.txt.\n */\nimport assert from \"../assert.js\";\n/**\n * Pattern to analyze MessageFormat strings.\n *\n * Group 1: captures doubled single quotes within the string\n * Group 2: captures quoted fragments within the string.\n *            Note that java.util.MessageFormat silently forgives a missing single quote at\n *            the end of a pattern. This special case is handled by the RegEx as well.\n * Group 3: captures placeholders\n *            Checks only for numerical argument index, any remainder is ignored up to the next\n *            closing curly brace. Nested placeholders are not accepted!\n * Group 4: captures any remaining curly braces and indicates syntax errors\n *\n *                    [-1] [----- quoted string -----] [------ placeholder ------] [--]\n * @private\n */\nvar rMessageFormat = /('')|'([^']+(?:''[^']*)*)(?:'|$)|\\{([0-9]+(?:\\s*,[^{}]*)?)\\}|[{}]/g;\n\n/**\n * Creates a string from a pattern by replacing placeholders with concrete values.\n *\n * The syntax of the pattern is inspired by (but not fully equivalent to) the\n * java.util.MessageFormat.\n *\n * Placeholders have the form <code>{ integer }</code>, where any occurrence of\n * <code>{0}</code> is replaced by the value with index 0 in <code>aValues</code>,\n * <code>{1}</code> by the value with index 1 in <code>aValues</code> etc.\n *\n * To avoid interpretation of curly braces as placeholders, any non-placeholder fragment\n * of the pattern can be enclosed in single quotes. The surrounding single quotes will be\n * omitted from the result. Single quotes that are not meant to escape a fragment and\n * that should appear in the result, need to be doubled. In the result, only a single\n * single quote will occur.\n *\n * Example: Pattern Strings\n * <pre>\n *  formatMessage(\"Say {0}\",     [\"Hello\"]) -> \"Say Hello\"    // normal use case\n *  formatMessage(\"Say '{0}'\",   [\"Hello\"]) -> \"Say {0}\"      // escaped placeholder\n *  formatMessage(\"Say ''{0}''\", [\"Hello\"]) -> \"Say 'Hello'\"  // doubled single quote\n *  formatMessage(\"Say '{0}'''\", [\"Hello\"]) -> \"Say {0}'\"     // doubled single quote in quoted fragment\n * </pre>\n * In contrast to java.util.MessageFormat, format types or format styles are not supported.\n * Everything after the argument index and up to the first closing curly brace is ignored.\n * Nested placeholders (as supported by java.lang.MessageFormat for the format type choice)\n * are not ignored but reported as a parse error.\n *\n * This method throws an Error when the pattern syntax is not fulfilled (e.g. unbalanced curly\n * braces, nested placeholders or a non-numerical argument index).\n *\n * This method can also be used as a formatter within a binding. The first part of a composite binding\n * will be used as pattern, the following parts as aValues. If there is only one value and this\n * value is an array it will be handled like the default described above.\n *\n * @function\n * @since 1.58\n * @alias module:sap/base/strings/formatMessage\n * @param {string} sPattern A pattern string in the described syntax\n * @param {any[]} [aValues=[]] The values to be used instead of the placeholders.\n * @returns {string} The formatted result string\n * @SecPassthrough {*|return}\n * @public\n */\nvar fnFormatMessage = function (sPattern, aValues) {\n  assert(typeof sPattern === \"string\" || sPattern instanceof String, \"pattern must be string\");\n  if (arguments.length > 2 || aValues != null && !Array.isArray(aValues)) {\n    aValues = Array.prototype.slice.call(arguments, 1);\n  }\n  aValues = aValues || [];\n  return sPattern.replace(rMessageFormat, function ($0, $1, $2, $3, offset) {\n    if ($1) {\n      // a doubled single quote in a normal string fragment\n      //   --> emit a single quote\n      return \"'\";\n    } else if ($2) {\n      // a quoted sequence of chars, potentially containing doubled single quotes again\n      //   --> emit with doubled single quotes replaced by a single quote\n      return $2.replace(/''/g, \"'\");\n    } else if ($3) {\n      // a welformed curly brace\n      //   --> emit the argument but ignore other parameters\n      return String(aValues[parseInt($3)]);\n    }\n    // e.g. malformed curly braces\n    //   --> throw Error\n    throw new Error(\"formatMessage: pattern syntax error at pos. \" + offset);\n  });\n};\nexport default fnFormatMessage;"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,OAAOA,MAAM,MAAM,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,cAAc,GAAG,oEAAoE;;AAEzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,eAAe,GAAG,SAAAA,CAAUC,QAAQ,EAAEC,OAAO,EAAE;EACjDJ,MAAM,CAAC,OAAOG,QAAQ,KAAK,QAAQ,IAAIA,QAAQ,YAAYE,MAAM,EAAE,wBAAwB,CAAC;EAC5F,IAAIC,SAAS,CAACC,MAAM,GAAG,CAAC,IAAIH,OAAO,IAAI,IAAI,IAAI,CAACI,KAAK,CAACC,OAAO,CAACL,OAAO,CAAC,EAAE;IACtEA,OAAO,GAAGI,KAAK,CAACE,SAAS,CAACC,KAAK,CAACC,IAAI,CAACN,SAAS,EAAE,CAAC,CAAC;EACpD;EACAF,OAAO,GAAGA,OAAO,IAAI,EAAE;EACvB,OAAOD,QAAQ,CAACU,OAAO,CAACZ,cAAc,EAAE,UAAUa,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,MAAM,EAAE;IACxE,IAAIH,EAAE,EAAE;MACN;MACA;MACA,OAAO,GAAG;IACZ,CAAC,MAAM,IAAIC,EAAE,EAAE;MACb;MACA;MACA,OAAOA,EAAE,CAACH,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC;IAC/B,CAAC,MAAM,IAAII,EAAE,EAAE;MACb;MACA;MACA,OAAOZ,MAAM,CAACD,OAAO,CAACe,QAAQ,CAACF,EAAE,CAAC,CAAC,CAAC;IACtC;IACA;IACA;IACA,MAAM,IAAIG,KAAK,CAAC,8CAA8C,GAAGF,MAAM,CAAC;EAC1E,CAAC,CAAC;AACJ,CAAC;AACD,eAAehB,eAAe","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
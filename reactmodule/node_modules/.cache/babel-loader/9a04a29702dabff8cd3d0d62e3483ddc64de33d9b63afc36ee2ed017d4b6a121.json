{"ast":null,"code":"/*!\n * OpenUI5\n * (c) Copyright 2009-2024 SAP SE or an SAP affiliate company.\n * Licensed under the Apache License, Version 2.0 - see LICENSE.txt.\n */\n/* global Set */\n// Provides class sap.ui.base.DataType\nimport ObjectPath from \"../../base/util/ObjectPath.js\";\nimport assert from \"../../base/assert.js\";\nimport Log from \"../../base/Log.js\";\nimport isPlainObject from \"../../base/util/isPlainObject.js\";\nimport resolveReference from \"../../base/util/resolveReference.js\";\n/**\n * Pseudo-Constructor for class <code>DataType</code>, never to be used.\n *\n * @class Represents the type of properties in a <code>ManagedObject</code> class.\n *\n * Each type provides some metadata like its {@link #getName qualified name} or its\n * {@link #getBaseType base type} in case of a derived type. Array types provide information\n * about the allowed {@link #getComponentType type of components} in an array, enumeration types\n * inform about the set of their allowed {@link #getEnumValues keys and values}.\n *\n * Each type has a method to {@link #isValid check whether a value is valid} for a property\n * of that type.\n *\n * Already defined types can be looked up by calling {@link #.getType DataType.getType}, new\n * types can only be created by calling the factory method {@link #.createType DataType.createType},\n * calling the constructor will throw an error.\n *\n * @author SAP SE\n * @since 0.9.0\n * @alias sap.ui.base.DataType\n * @public\n * @hideconstructor\n * @throws {Error} Constructor must not be called, use {@link #.createType DataType.createType} instead\n */\nvar DataType = function () {\n  // Avoid construction of a DataType.\n  // DataType is only a function to support the \"instanceof\" operator.\n  throw new Error();\n};\n\n/**\n * The qualified name of the data type.\n *\n * @returns {string} Name of the data type\n * @public\n */\nDataType.prototype.getName = function () {\n  return undefined;\n};\n\n/**\n * The base type of this type or undefined if this is a primitive type.\n * @returns {sap.ui.base.DataType|undefined} Base type or <code>undefined</code>\n * @public\n */\nDataType.prototype.getBaseType = function () {\n  return undefined;\n};\n\n/**\n * Returns the most basic (primitive) type that this type has been derived from.\n *\n * If the type is a primitive type by itself, <code>this</code> is returned.\n *\n * @returns {sap.ui.base.DataType} Primitive type of this type\n * @public\n */\nDataType.prototype.getPrimitiveType = function () {\n  /*eslint-disable consistent-this*/\n  var oType = this;\n  /*eslint-enable consistent-this*/\n  while (oType.getBaseType()) {\n    oType = oType.getBaseType();\n  }\n  return oType;\n};\n\n/**\n * Returns the component type of this type or <code>undefined</code> if this is not an array type.\n *\n * @returns {sap.ui.base.DataType|undefined} Component type or <code>undefined</code>\n * @public\n */\nDataType.prototype.getComponentType = function () {\n  return undefined;\n};\n\n/**\n * The default value for this type. Each type must define a default value.\n * @returns {any} Default value of the data type. The type of the returned value\n *    must match the JavaScript type of the data type (a string for string types etc.)\n * @public\n */\nDataType.prototype.getDefaultValue = function () {\n  return undefined;\n};\n\n/**\n * Whether this type is an array type.\n * @returns {boolean} Whether this type is an array type\n * @public\n */\nDataType.prototype.isArrayType = function () {\n  return false;\n};\n\n/**\n * Whether this type is an enumeration type.\n * @returns {boolean} Whether this type is an enum type\n * @public\n */\nDataType.prototype.isEnumType = function () {\n  return false;\n};\n\n/**\n * Returns the object with keys and values from which this enum type was created\n * or <code>undefined</code> if this is not an enum type.\n *\n * @returns {Object<string,string>|undefined} Object with enum keys and values or <code>undefined</code>\n * @public\n */\nDataType.prototype.getEnumValues = function () {\n  return undefined;\n};\n\n/**\n * Parses the given string value and converts it into the specific data type.\n * @param {string} sValue String representation for a value of this type\n * @returns {any} Value in the correct internal format\n * @public\n */\nDataType.prototype.parseValue = function (sValue) {\n  return sValue;\n};\n\n/**\n * Checks whether the given value is valid for this type.\n *\n * To be implemented by concrete types.\n * @param {any} vValue Value to be checked\n * @returns {boolean} Whether the given value is valid for this data type (without conversion)\n * @public\n * @function\n */\nDataType.prototype.isValid = undefined;\n// Note that <code>isValid</code> must be assigned a falsy value here as it otherwise\n// would be called in addition to any <code>isValid</code> implementation in subtypes.\n// See <code>createType</code> for details.\n\n/**\n * Set or unset a normalizer function to be used for values of this data type.\n *\n * When a normalizer function has been set, it will be applied to values of this type\n * whenever {@link #normalize} is called. <code>ManagedObject.prototype.setProperty</code>\n * calls the <code>normalize</code> method before setting a new value to a property\n * (normalization is applied on-write, not on-read).\n *\n * The <code>fnNormalize</code> function has the signature\n * <pre>\n *   fnNormalize(value:any) : any\n * </pre>\n * It will be called with a value for this type and should return a normalized\n * value (which also must be valid for the this type). There's no mean to reject a value.\n * The <code>this</code> context of the function will be this type.\n *\n * This method allows applications or application frameworks to plug-in a generic value\n * normalization for a type, e.g. to convert all URLs in some app-specific way before\n * they are applied to controls. It is not intended to break-out of the value range\n * defined by a type.\n *\n * @param {function(any):any} fnNormalizer Function to apply for normalizing\n * @public\n */\nDataType.prototype.setNormalizer = function (fnNormalizer) {\n  assert(typeof fnNormalizer === \"function\", \"DataType.setNormalizer: fnNormalizer must be a function\");\n  this._fnNormalizer = typeof fnNormalizer === \"function\" ? fnNormalizer : undefined;\n};\n\n/**\n * Normalizes the given value using the specified normalizer for this data type.\n *\n * If no normalizer has been set, the original value is returned.\n *\n * @param {any} oValue Value to be normalized\n * @returns {any} Normalized value\n * @public\n */\nDataType.prototype.normalize = function (oValue) {\n  return this._fnNormalizer ? this._fnNormalizer(oValue) : oValue;\n};\nfunction createType(sName, mSettings, oBase) {\n  mSettings = mSettings || {};\n\n  // create a new type object with the base type as prototype\n  var oBaseObject = oBase || DataType.prototype;\n  var oType = Object.create(oBaseObject);\n\n  // getter for the name\n  oType.getName = function () {\n    return sName;\n  };\n\n  // if a default value is specified, create a getter for it\n  if (mSettings.hasOwnProperty(\"defaultValue\")) {\n    var vDefault = mSettings.defaultValue;\n    oType.getDefaultValue = function () {\n      return vDefault;\n    };\n  }\n\n  // if a validator is specified either chain it with the base type validator\n  // or set it if no base validator exists\n  if (mSettings.isValid) {\n    var fnIsValid = mSettings.isValid;\n    oType.isValid = oBaseObject.isValid ? function (vValue) {\n      if (!oBaseObject.isValid(vValue)) {\n        return false;\n      }\n      return fnIsValid(vValue);\n    } : fnIsValid;\n  }\n  if (mSettings.parseValue) {\n    oType.parseValue = mSettings.parseValue;\n  }\n\n  // return the base type\n  oType.getBaseType = function () {\n    return oBase;\n  };\n  return oType;\n}\nvar mTypes = {\n  \"any\": createType(\"any\", {\n    defaultValue: null,\n    isValid: function (vValue) {\n      return true;\n    }\n  }),\n  \"boolean\": createType(\"boolean\", {\n    defaultValue: false,\n    isValid: function (vValue) {\n      return typeof vValue === \"boolean\";\n    },\n    parseValue: function (sValue) {\n      return sValue == \"true\";\n    }\n  }),\n  \"int\": createType(\"int\", {\n    defaultValue: 0,\n    isValid: function (vValue) {\n      return typeof vValue === \"number\" && (isNaN(vValue) || Math.floor(vValue) == vValue);\n    },\n    parseValue: function (sValue) {\n      return parseInt(sValue);\n    }\n  }),\n  \"float\": createType(\"float\", {\n    defaultValue: 0.0,\n    isValid: function (vValue) {\n      return typeof vValue === \"number\";\n    },\n    parseValue: function (sValue) {\n      return parseFloat(sValue);\n    }\n  }),\n  \"string\": createType(\"string\", {\n    defaultValue: \"\",\n    isValid: function (vValue) {\n      return typeof vValue === \"string\" || vValue instanceof String;\n    },\n    parseValue: function (sValue) {\n      return sValue;\n    }\n  }),\n  \"object\": createType(\"object\", {\n    defaultValue: null,\n    isValid: function (vValue) {\n      return typeof vValue === \"object\" || typeof vValue === \"function\";\n    },\n    parseValue: function (sValue) {\n      return sValue ? JSON.parse(sValue) : null;\n    }\n  }),\n  \"function\": createType(\"function\", {\n    defaultValue: null,\n    isValid: function (vValue) {\n      return vValue == null || typeof vValue === 'function';\n    },\n    /*\n     * Note: the second parameter <code>_oOptions</code> is a hidden feature for internal use only.\n     * Its structure is subject to change. No code other than the XMLTemplateProcessor must use it.\n     */\n    parseValue: function (sValue, _oOptions) {\n      if (sValue === \"\") {\n        return undefined;\n      }\n      if (!/^\\.?[A-Z_\\$][A-Z0-9_\\$]*(\\.[A-Z_\\$][A-Z0-9_\\$]*)*$/i.test(sValue)) {\n        throw new Error(\"Function references must consist of dot separated \" + \"simple identifiers (A-Z, 0-9, _ or $) only, but was '\" + sValue + \"'\");\n      }\n      var fnResult,\n        oContext = _oOptions && _oOptions.context,\n        oLocals = _oOptions && _oOptions.locals;\n      fnResult = resolveReference(sValue, Object.assign({\n        \".\": oContext\n      }, oLocals));\n      if (fnResult && this.isValid(fnResult)) {\n        return fnResult;\n      }\n      throw new TypeError(\"The string '\" + sValue + \"' couldn't be resolved to a function\");\n    }\n  })\n};\n\n// The generic \"array\" type must not be exposed by DataType.getType to avoid direct usage\n// as type of a managed property. It is therefore not stored in the mTypes map\nvar arrayType = createType(\"array\", {\n  defaultValue: []\n});\nfunction createArrayType(componentType) {\n  assert(componentType instanceof DataType, \"DataType.<createArrayType>: componentType must be a DataType\");\n\n  // create a new type object with the base type as prototype\n  var oType = Object.create(DataType.prototype);\n\n  // getter for the name\n  oType.getName = function () {\n    return componentType.getName() + \"[]\";\n  };\n\n  // getter for component type\n  oType.getComponentType = function () {\n    return componentType;\n  };\n\n  // array validator\n  oType.isValid = function (aValues) {\n    if (aValues === null) {\n      return true;\n    }\n    if (Array.isArray(aValues)) {\n      for (var i = 0; i < aValues.length; i++) {\n        if (!componentType.isValid(aValues[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  };\n\n  // array parser\n  oType.parseValue = function (sValue) {\n    var aValues = sValue.split(\",\");\n    for (var i = 0; i < aValues.length; i++) {\n      aValues[i] = componentType.parseValue(aValues[i]);\n    }\n    return aValues;\n  };\n\n  // is an array type\n  oType.isArrayType = function () {\n    return true;\n  };\n\n  // return the base type\n  oType.getBaseType = function () {\n    return arrayType;\n  };\n  return oType;\n}\nconst mEnumRegistry = Object.create(null);\nfunction createEnumType(sTypeName, oEnum) {\n  var mValues = {},\n    sDefaultValue;\n  for (var sName in oEnum) {\n    var sValue = oEnum[sName];\n    // the first entry will become the default value\n    if (!sDefaultValue) {\n      sDefaultValue = sValue;\n    }\n    if (typeof sValue !== \"string\") {\n      throw new Error(\"Value \" + sValue + \" for enum type \" + sTypeName + \" is not a string\");\n    }\n    // if there are multiple entries with the same value, the one where name\n    // and value are matching is taken\n    if (!mValues.hasOwnProperty(sValue) || sName == sValue) {\n      mValues[sValue] = sName;\n    }\n  }\n  var oType = Object.create(DataType.prototype);\n\n  // getter for the name\n  oType.getName = function () {\n    return sTypeName;\n  };\n\n  // enum validator\n  oType.isValid = function (v) {\n    return typeof v === \"string\" && mValues.hasOwnProperty(v);\n  };\n\n  // enum parser\n  oType.parseValue = function (sValue) {\n    return oEnum[sValue];\n  };\n\n  // default value\n  oType.getDefaultValue = function () {\n    return sDefaultValue;\n  };\n\n  // return the base type\n  oType.getBaseType = function () {\n    return mTypes.string;\n  };\n\n  // is an enum type\n  oType.isEnumType = function () {\n    return true;\n  };\n\n  // enum values are best represented by the existing global object\n  oType.getEnumValues = function () {\n    return oEnum;\n  };\n  return oType;\n}\n\n/**\n * Looks up the type with the given name and returns it.\n *\n * See {@link topic:ac56d92162ed47ff858fdf1ce26c18c4 Defining Control Properties} for\n * a list of the built-in primitive types and their semantics.\n *\n * The lookup consists of the following steps:\n * <ul>\n * <li>When a type with the given name is already known, it will be returned</li>\n * <li>When the name ends with a pair of brackets (<code>[]</code>), a type with the name\n *     in front of the brackets (<code>name.slice(0,-2)</code>) will be looked up and an\n *     array type will be created with the looked-up type as its component type. If the\n *     component type is <code>undefined</code>, <code>undefined</code> will be returned</li>\n * <li>When a global property exists with the same name as the type and when the value of that\n *     property is an instance of <code>DataType</code>, that instance will be returned</li>\n * <li>When a global property exists with the same name as the type and when the value of that\n *     property is a plain object (its prototype is <code>Object</code>), then an enum type will\n *     be created, based on the keys and values in that object. The <code>parseValue</code> method\n *     of the type will accept any of the keys in the plain object and convert them to the\n *     corresponding value; <code>isValid</code> will accept any of the values from the plain\n *     object's keys. The <code>defaultValue</code> will be the value of the first key found in\n *     the plain object</li>\n * <li>When a global property exist with any other, non-falsy value, a warning is logged and the\n *     primitive type 'any' is returned</li>\n * <li>If no such global property exist, an error is logged and <code>undefined</code>\n *     is returned</li>\n * </ul>\n *\n * <b<Note:</b> UI Libraries and even components can introduce additional types. This method\n * only checks for types that either have been defined already, or that describe arrays of\n * values of an already defined type or types whose name matches the global name of a plain\n * object (containing enum keys and values). This method doesn't try to load modules that\n * might contain type definitions. So before being able to lookup and use a specific type,\n * the module containing its definition has to be loaded. For that reason it is suggested that\n * controls (or <code>ManagedObject</code> classes in general) declare a dependency to all\n * modules (typically <code>some/lib/library.js</code> modules) that contain the type definitions\n * needed by the specific control or class definition.\n *\n * @param {string} sTypeName Qualified name of the type to retrieve\n * @returns {sap.ui.base.DataType|undefined} Type object or <code>undefined</code> when\n *     no such type has been defined yet\n * @public\n */\nDataType.getType = function (sTypeName) {\n  assert(sTypeName && typeof sTypeName === 'string', \"sTypeName must be a non-empty string\");\n  var oType = mTypes[sTypeName];\n  if (!(oType instanceof DataType)) {\n    // check for array types\n    if (sTypeName.indexOf(\"[]\", sTypeName.length - 2) > 0) {\n      var sComponentTypeName = sTypeName.slice(0, -2),\n        oComponentType = this.getType(sComponentTypeName);\n      oType = oComponentType && createArrayType(oComponentType);\n      if (oType) {\n        mTypes[sTypeName] = oType;\n      }\n    } else if (sTypeName !== 'array') {\n      // check if we have a valid pre-registered enum\n      oType = mEnumRegistry[sTypeName];\n\n      /**\n       * If an enum was not registered beforehand (either explicitly via registerEnum or\n       * via a Proxy in the library namespace), we have to look it up in the global object.\n       * @deprecated since 1.120\n       */\n      if (oType == null) {\n        oType = ObjectPath.get(sTypeName);\n        if (oType != null) {\n          Log.error(`The type '${sTypeName}' was accessed via globals. Defining enums via globals is deprecated. Please require the module 'sap/ui/base/DataType' and call the static 'DataType.registerEnum' API.`);\n        }\n      }\n      if (oType instanceof DataType) {\n        mTypes[sTypeName] = oType;\n      } else if (isPlainObject(oType)) {\n        oType = mTypes[sTypeName] = createEnumType(sTypeName, oType);\n        delete mEnumRegistry[sTypeName];\n      } else if (oType) {\n        Log.warning(\"[FUTURE FATAL] '\" + sTypeName + \"' is not a valid data type. Falling back to type 'any'.\");\n        oType = mTypes.any;\n      } else {\n        Log.error(\"[FUTURE FATAL] data type '\" + sTypeName + \"' could not be found.\");\n        oType = undefined;\n      }\n    }\n  }\n  return oType;\n};\n\n/**\n * Derives a new type from a given base type.\n *\n * Example:<br>\n * <pre>\n *\n *   var fooType = DataType.createType('foo', {\n *       isValid : function(vValue) {\n *           return /^(foo(bar)?)$/.test(vValue);\n *       }\n *   }, DataType.getType('string'));\n *\n *   fooType.isValid('foo'); // true\n *   fooType.isValid('foobar'); // true\n *   fooType.isValid('==foobar=='); // false\n *\n * </pre>\n *\n * If <code>mSettings</code> contains an implementation for <code>isValid</code>,\n * then the validity check of the newly created type will first execute the check of the\n * base type and then call the given <code>isValid</code> function.\n *\n * Array types and enumeration types cannot be created with this method. They're created\n * on-the-fly by {@link #.getType DataType.getType} when such a type is looked up.\n *\n * <b>Note:</b> The creation of new primitive types is not supported. When a type is created\n * without a base type, it is automatically derived from the primitive type <code>any</code>.\n *\n * <b>Note:</b> If a type has to be used in classes, then the implementation of\n * <code>isValid</code> must exactly have the structure shown in the example above (single\n * return statement, regular expression literal of the form <code>/^(...)$/</code>, calling\n * <code>/regex/.test()</code> on the given value).\n * Only the inner part of the regular expression literal can be different.\n *\n * @param {string} sName Unique qualified name of the new type\n * @param {object} [mSettings] Settings for the new type\n * @param {any} [mSettings.defaultValue] Default value for the type (inherited if not given)\n * @param {function} [mSettings.isValid] Additional validity check function for values of the\n *                       type (inherited if not given)\n * @param {function} [mSettings.parseValue] Parse function that converts a locale independent\n *                       string into a value of the type (inherited if not given)\n * @param {sap.ui.base.DataType|string} [vBase='any'] Base type for the new type\n * @returns {sap.ui.base.DataType} The newly created type object\n * @public\n */\nDataType.createType = function (sName, mSettings, vBase) {\n  assert(typeof sName === \"string\" && sName, \"DataType.createType: type name must be a non-empty string\");\n  assert(vBase == null || vBase instanceof DataType || typeof vBase === \"string\" && vBase, \"DataType.createType: base type must be empty or a DataType or a non-empty string\");\n  if (/[\\[\\]]/.test(sName)) {\n    Log.error(\"[FUTURE FATAL] DataType.createType: array types ('something[]') must not be created with createType, \" + \"they're created on-the-fly by DataType.getType\");\n  }\n  if (typeof vBase === \"string\") {\n    vBase = DataType.getType(vBase);\n  }\n  vBase = vBase || mTypes.any;\n  if (vBase.isArrayType() || vBase.isEnumType()) {\n    Log.error(\"[FUTURE FATAL] DataType.createType: base type must not be an array- or enum-type\");\n  }\n  if (sName === 'array' || mTypes[sName] instanceof DataType) {\n    if (sName === 'array' || mTypes[sName].getBaseType() == null) {\n      throw new Error(\"DataType.createType: primitive or hidden type \" + sName + \" can't be re-defined\");\n    }\n    Log.warning(\"[FUTURE FATAL] DataTypes.createType: type \" + sName + \" is redefined. \" + \"This is an unsupported usage of DataType and might cause issues.\");\n  }\n  var oType = mTypes[sName] = createType(sName, mSettings, vBase);\n  return oType;\n};\n\n// ---- minimal support for interface types -------------------------------------------------------------------\n\nvar oInterfaces = new Set();\n\n/**\n * Registers the given array of type names as known interface types.\n * Only purpose is to enable the {@link #isInterfaceType} check.\n * @param {string[]} aTypes interface types to be registered\n * @private\n * @ui5-restricted sap.ui.core.Core\n */\nDataType.registerInterfaceTypes = function (aTypes) {\n  aTypes.forEach(function (sType) {\n    oInterfaces.add(sType);\n\n    // Defining the interface on global namespace for compatibility reasons.\n    // This has never been a public feature and it is strongly discouraged it be relied upon.\n    // An interface must always be referenced by a string literal, not via the global namespace.\n    ObjectPath.set(sType, sType);\n  });\n};\n\n/**\n * Registers an enum under the given name.\n * With version 2.0, registering an enum becomes mandatory when said enum is to be used in\n * properties of a {@link sap.ui.base.ManagedObject ManagedObject} subclass.\n *\n * Example:<br>\n * <pre>\n *    DataType.registerEnum(\"my.enums.Sample\", {\n *       \"A\": \"A\",\n *       \"B\": \"B\",\n *       ...\n *    });\n * </pre>\n *\n * @param {string} sTypeName the type name in dot syntax, e.g. sap.ui.my.EnumType\n * @param {object} mContent the enum content\n * @public\n * @since 1.120.0\n */\nDataType.registerEnum = function (sTypeName, mContent) {\n  mEnumRegistry[sTypeName] = mContent;\n};\n\n/**\n * Checks if the given object contains only static content\n * and can be regarded as an enum candidate.\n *\n * @param {object} oObject the enum candidate\n * @returns {boolean} whether the given object can be regarded as an enum candidate\n * @private\n * @ui5-restricted sap.ui.core.Lib\n */\nDataType._isEnumCandidate = function (oObject) {\n  return !Object.keys(oObject).some(key => {\n    const propertyType = typeof oObject[key];\n    return propertyType === \"object\" || propertyType === \"function\";\n  });\n};\n\n/**\n * @param {string} sType name of type to check\n * @returns {boolean} whether the given type is known to be an interface type\n * @private\n * @ui5-restricted sap.ui.base.ManagedObject\n */\nDataType.isInterfaceType = function (sType) {\n  return oInterfaces.has(sType);\n};\nexport default DataType;","map":{"version":3,"names":["ObjectPath","assert","Log","isPlainObject","resolveReference","DataType","Error","prototype","getName","undefined","getBaseType","getPrimitiveType","oType","getComponentType","getDefaultValue","isArrayType","isEnumType","getEnumValues","parseValue","sValue","isValid","setNormalizer","fnNormalizer","_fnNormalizer","normalize","oValue","createType","sName","mSettings","oBase","oBaseObject","Object","create","hasOwnProperty","vDefault","defaultValue","fnIsValid","vValue","mTypes","isNaN","Math","floor","parseInt","parseFloat","String","JSON","parse","_oOptions","test","fnResult","oContext","context","oLocals","locals","assign","TypeError","arrayType","createArrayType","componentType","aValues","Array","isArray","i","length","split","mEnumRegistry","createEnumType","sTypeName","oEnum","mValues","sDefaultValue","v","string","getType","indexOf","sComponentTypeName","slice","oComponentType","get","error","warning","any","vBase","oInterfaces","Set","registerInterfaceTypes","aTypes","forEach","sType","add","set","registerEnum","mContent","_isEnumCandidate","oObject","keys","some","key","propertyType","isInterfaceType","has"],"sources":["/home/user/projects/reactproj/node_modules/@ui5/webcomponents-localization/dist/sap/ui/base/DataType.js"],"sourcesContent":["/*!\n * OpenUI5\n * (c) Copyright 2009-2024 SAP SE or an SAP affiliate company.\n * Licensed under the Apache License, Version 2.0 - see LICENSE.txt.\n */\n/* global Set */\n// Provides class sap.ui.base.DataType\nimport ObjectPath from \"../../base/util/ObjectPath.js\";\nimport assert from \"../../base/assert.js\";\nimport Log from \"../../base/Log.js\";\nimport isPlainObject from \"../../base/util/isPlainObject.js\";\nimport resolveReference from \"../../base/util/resolveReference.js\";\n/**\n * Pseudo-Constructor for class <code>DataType</code>, never to be used.\n *\n * @class Represents the type of properties in a <code>ManagedObject</code> class.\n *\n * Each type provides some metadata like its {@link #getName qualified name} or its\n * {@link #getBaseType base type} in case of a derived type. Array types provide information\n * about the allowed {@link #getComponentType type of components} in an array, enumeration types\n * inform about the set of their allowed {@link #getEnumValues keys and values}.\n *\n * Each type has a method to {@link #isValid check whether a value is valid} for a property\n * of that type.\n *\n * Already defined types can be looked up by calling {@link #.getType DataType.getType}, new\n * types can only be created by calling the factory method {@link #.createType DataType.createType},\n * calling the constructor will throw an error.\n *\n * @author SAP SE\n * @since 0.9.0\n * @alias sap.ui.base.DataType\n * @public\n * @hideconstructor\n * @throws {Error} Constructor must not be called, use {@link #.createType DataType.createType} instead\n */\nvar DataType = function () {\n  // Avoid construction of a DataType.\n  // DataType is only a function to support the \"instanceof\" operator.\n  throw new Error();\n};\n\n/**\n * The qualified name of the data type.\n *\n * @returns {string} Name of the data type\n * @public\n */\nDataType.prototype.getName = function () {\n  return undefined;\n};\n\n/**\n * The base type of this type or undefined if this is a primitive type.\n * @returns {sap.ui.base.DataType|undefined} Base type or <code>undefined</code>\n * @public\n */\nDataType.prototype.getBaseType = function () {\n  return undefined;\n};\n\n/**\n * Returns the most basic (primitive) type that this type has been derived from.\n *\n * If the type is a primitive type by itself, <code>this</code> is returned.\n *\n * @returns {sap.ui.base.DataType} Primitive type of this type\n * @public\n */\nDataType.prototype.getPrimitiveType = function () {\n  /*eslint-disable consistent-this*/\n  var oType = this;\n  /*eslint-enable consistent-this*/\n  while (oType.getBaseType()) {\n    oType = oType.getBaseType();\n  }\n  return oType;\n};\n\n/**\n * Returns the component type of this type or <code>undefined</code> if this is not an array type.\n *\n * @returns {sap.ui.base.DataType|undefined} Component type or <code>undefined</code>\n * @public\n */\nDataType.prototype.getComponentType = function () {\n  return undefined;\n};\n\n/**\n * The default value for this type. Each type must define a default value.\n * @returns {any} Default value of the data type. The type of the returned value\n *    must match the JavaScript type of the data type (a string for string types etc.)\n * @public\n */\nDataType.prototype.getDefaultValue = function () {\n  return undefined;\n};\n\n/**\n * Whether this type is an array type.\n * @returns {boolean} Whether this type is an array type\n * @public\n */\nDataType.prototype.isArrayType = function () {\n  return false;\n};\n\n/**\n * Whether this type is an enumeration type.\n * @returns {boolean} Whether this type is an enum type\n * @public\n */\nDataType.prototype.isEnumType = function () {\n  return false;\n};\n\n/**\n * Returns the object with keys and values from which this enum type was created\n * or <code>undefined</code> if this is not an enum type.\n *\n * @returns {Object<string,string>|undefined} Object with enum keys and values or <code>undefined</code>\n * @public\n */\nDataType.prototype.getEnumValues = function () {\n  return undefined;\n};\n\n/**\n * Parses the given string value and converts it into the specific data type.\n * @param {string} sValue String representation for a value of this type\n * @returns {any} Value in the correct internal format\n * @public\n */\nDataType.prototype.parseValue = function (sValue) {\n  return sValue;\n};\n\n/**\n * Checks whether the given value is valid for this type.\n *\n * To be implemented by concrete types.\n * @param {any} vValue Value to be checked\n * @returns {boolean} Whether the given value is valid for this data type (without conversion)\n * @public\n * @function\n */\nDataType.prototype.isValid = undefined;\n// Note that <code>isValid</code> must be assigned a falsy value here as it otherwise\n// would be called in addition to any <code>isValid</code> implementation in subtypes.\n// See <code>createType</code> for details.\n\n/**\n * Set or unset a normalizer function to be used for values of this data type.\n *\n * When a normalizer function has been set, it will be applied to values of this type\n * whenever {@link #normalize} is called. <code>ManagedObject.prototype.setProperty</code>\n * calls the <code>normalize</code> method before setting a new value to a property\n * (normalization is applied on-write, not on-read).\n *\n * The <code>fnNormalize</code> function has the signature\n * <pre>\n *   fnNormalize(value:any) : any\n * </pre>\n * It will be called with a value for this type and should return a normalized\n * value (which also must be valid for the this type). There's no mean to reject a value.\n * The <code>this</code> context of the function will be this type.\n *\n * This method allows applications or application frameworks to plug-in a generic value\n * normalization for a type, e.g. to convert all URLs in some app-specific way before\n * they are applied to controls. It is not intended to break-out of the value range\n * defined by a type.\n *\n * @param {function(any):any} fnNormalizer Function to apply for normalizing\n * @public\n */\nDataType.prototype.setNormalizer = function (fnNormalizer) {\n  assert(typeof fnNormalizer === \"function\", \"DataType.setNormalizer: fnNormalizer must be a function\");\n  this._fnNormalizer = typeof fnNormalizer === \"function\" ? fnNormalizer : undefined;\n};\n\n/**\n * Normalizes the given value using the specified normalizer for this data type.\n *\n * If no normalizer has been set, the original value is returned.\n *\n * @param {any} oValue Value to be normalized\n * @returns {any} Normalized value\n * @public\n */\nDataType.prototype.normalize = function (oValue) {\n  return this._fnNormalizer ? this._fnNormalizer(oValue) : oValue;\n};\nfunction createType(sName, mSettings, oBase) {\n  mSettings = mSettings || {};\n\n  // create a new type object with the base type as prototype\n  var oBaseObject = oBase || DataType.prototype;\n  var oType = Object.create(oBaseObject);\n\n  // getter for the name\n  oType.getName = function () {\n    return sName;\n  };\n\n  // if a default value is specified, create a getter for it\n  if (mSettings.hasOwnProperty(\"defaultValue\")) {\n    var vDefault = mSettings.defaultValue;\n    oType.getDefaultValue = function () {\n      return vDefault;\n    };\n  }\n\n  // if a validator is specified either chain it with the base type validator\n  // or set it if no base validator exists\n  if (mSettings.isValid) {\n    var fnIsValid = mSettings.isValid;\n    oType.isValid = oBaseObject.isValid ? function (vValue) {\n      if (!oBaseObject.isValid(vValue)) {\n        return false;\n      }\n      return fnIsValid(vValue);\n    } : fnIsValid;\n  }\n  if (mSettings.parseValue) {\n    oType.parseValue = mSettings.parseValue;\n  }\n\n  // return the base type\n  oType.getBaseType = function () {\n    return oBase;\n  };\n  return oType;\n}\nvar mTypes = {\n  \"any\": createType(\"any\", {\n    defaultValue: null,\n    isValid: function (vValue) {\n      return true;\n    }\n  }),\n  \"boolean\": createType(\"boolean\", {\n    defaultValue: false,\n    isValid: function (vValue) {\n      return typeof vValue === \"boolean\";\n    },\n    parseValue: function (sValue) {\n      return sValue == \"true\";\n    }\n  }),\n  \"int\": createType(\"int\", {\n    defaultValue: 0,\n    isValid: function (vValue) {\n      return typeof vValue === \"number\" && (isNaN(vValue) || Math.floor(vValue) == vValue);\n    },\n    parseValue: function (sValue) {\n      return parseInt(sValue);\n    }\n  }),\n  \"float\": createType(\"float\", {\n    defaultValue: 0.0,\n    isValid: function (vValue) {\n      return typeof vValue === \"number\";\n    },\n    parseValue: function (sValue) {\n      return parseFloat(sValue);\n    }\n  }),\n  \"string\": createType(\"string\", {\n    defaultValue: \"\",\n    isValid: function (vValue) {\n      return typeof vValue === \"string\" || vValue instanceof String;\n    },\n    parseValue: function (sValue) {\n      return sValue;\n    }\n  }),\n  \"object\": createType(\"object\", {\n    defaultValue: null,\n    isValid: function (vValue) {\n      return typeof vValue === \"object\" || typeof vValue === \"function\";\n    },\n    parseValue: function (sValue) {\n      return sValue ? JSON.parse(sValue) : null;\n    }\n  }),\n  \"function\": createType(\"function\", {\n    defaultValue: null,\n    isValid: function (vValue) {\n      return vValue == null || typeof vValue === 'function';\n    },\n    /*\n     * Note: the second parameter <code>_oOptions</code> is a hidden feature for internal use only.\n     * Its structure is subject to change. No code other than the XMLTemplateProcessor must use it.\n     */\n    parseValue: function (sValue, _oOptions) {\n      if (sValue === \"\") {\n        return undefined;\n      }\n      if (!/^\\.?[A-Z_\\$][A-Z0-9_\\$]*(\\.[A-Z_\\$][A-Z0-9_\\$]*)*$/i.test(sValue)) {\n        throw new Error(\"Function references must consist of dot separated \" + \"simple identifiers (A-Z, 0-9, _ or $) only, but was '\" + sValue + \"'\");\n      }\n      var fnResult,\n        oContext = _oOptions && _oOptions.context,\n        oLocals = _oOptions && _oOptions.locals;\n      fnResult = resolveReference(sValue, Object.assign({\n        \".\": oContext\n      }, oLocals));\n      if (fnResult && this.isValid(fnResult)) {\n        return fnResult;\n      }\n      throw new TypeError(\"The string '\" + sValue + \"' couldn't be resolved to a function\");\n    }\n  })\n};\n\n// The generic \"array\" type must not be exposed by DataType.getType to avoid direct usage\n// as type of a managed property. It is therefore not stored in the mTypes map\nvar arrayType = createType(\"array\", {\n  defaultValue: []\n});\nfunction createArrayType(componentType) {\n  assert(componentType instanceof DataType, \"DataType.<createArrayType>: componentType must be a DataType\");\n\n  // create a new type object with the base type as prototype\n  var oType = Object.create(DataType.prototype);\n\n  // getter for the name\n  oType.getName = function () {\n    return componentType.getName() + \"[]\";\n  };\n\n  // getter for component type\n  oType.getComponentType = function () {\n    return componentType;\n  };\n\n  // array validator\n  oType.isValid = function (aValues) {\n    if (aValues === null) {\n      return true;\n    }\n    if (Array.isArray(aValues)) {\n      for (var i = 0; i < aValues.length; i++) {\n        if (!componentType.isValid(aValues[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  };\n\n  // array parser\n  oType.parseValue = function (sValue) {\n    var aValues = sValue.split(\",\");\n    for (var i = 0; i < aValues.length; i++) {\n      aValues[i] = componentType.parseValue(aValues[i]);\n    }\n    return aValues;\n  };\n\n  // is an array type\n  oType.isArrayType = function () {\n    return true;\n  };\n\n  // return the base type\n  oType.getBaseType = function () {\n    return arrayType;\n  };\n  return oType;\n}\nconst mEnumRegistry = Object.create(null);\nfunction createEnumType(sTypeName, oEnum) {\n  var mValues = {},\n    sDefaultValue;\n  for (var sName in oEnum) {\n    var sValue = oEnum[sName];\n    // the first entry will become the default value\n    if (!sDefaultValue) {\n      sDefaultValue = sValue;\n    }\n    if (typeof sValue !== \"string\") {\n      throw new Error(\"Value \" + sValue + \" for enum type \" + sTypeName + \" is not a string\");\n    }\n    // if there are multiple entries with the same value, the one where name\n    // and value are matching is taken\n    if (!mValues.hasOwnProperty(sValue) || sName == sValue) {\n      mValues[sValue] = sName;\n    }\n  }\n  var oType = Object.create(DataType.prototype);\n\n  // getter for the name\n  oType.getName = function () {\n    return sTypeName;\n  };\n\n  // enum validator\n  oType.isValid = function (v) {\n    return typeof v === \"string\" && mValues.hasOwnProperty(v);\n  };\n\n  // enum parser\n  oType.parseValue = function (sValue) {\n    return oEnum[sValue];\n  };\n\n  // default value\n  oType.getDefaultValue = function () {\n    return sDefaultValue;\n  };\n\n  // return the base type\n  oType.getBaseType = function () {\n    return mTypes.string;\n  };\n\n  // is an enum type\n  oType.isEnumType = function () {\n    return true;\n  };\n\n  // enum values are best represented by the existing global object\n  oType.getEnumValues = function () {\n    return oEnum;\n  };\n  return oType;\n}\n\n/**\n * Looks up the type with the given name and returns it.\n *\n * See {@link topic:ac56d92162ed47ff858fdf1ce26c18c4 Defining Control Properties} for\n * a list of the built-in primitive types and their semantics.\n *\n * The lookup consists of the following steps:\n * <ul>\n * <li>When a type with the given name is already known, it will be returned</li>\n * <li>When the name ends with a pair of brackets (<code>[]</code>), a type with the name\n *     in front of the brackets (<code>name.slice(0,-2)</code>) will be looked up and an\n *     array type will be created with the looked-up type as its component type. If the\n *     component type is <code>undefined</code>, <code>undefined</code> will be returned</li>\n * <li>When a global property exists with the same name as the type and when the value of that\n *     property is an instance of <code>DataType</code>, that instance will be returned</li>\n * <li>When a global property exists with the same name as the type and when the value of that\n *     property is a plain object (its prototype is <code>Object</code>), then an enum type will\n *     be created, based on the keys and values in that object. The <code>parseValue</code> method\n *     of the type will accept any of the keys in the plain object and convert them to the\n *     corresponding value; <code>isValid</code> will accept any of the values from the plain\n *     object's keys. The <code>defaultValue</code> will be the value of the first key found in\n *     the plain object</li>\n * <li>When a global property exist with any other, non-falsy value, a warning is logged and the\n *     primitive type 'any' is returned</li>\n * <li>If no such global property exist, an error is logged and <code>undefined</code>\n *     is returned</li>\n * </ul>\n *\n * <b<Note:</b> UI Libraries and even components can introduce additional types. This method\n * only checks for types that either have been defined already, or that describe arrays of\n * values of an already defined type or types whose name matches the global name of a plain\n * object (containing enum keys and values). This method doesn't try to load modules that\n * might contain type definitions. So before being able to lookup and use a specific type,\n * the module containing its definition has to be loaded. For that reason it is suggested that\n * controls (or <code>ManagedObject</code> classes in general) declare a dependency to all\n * modules (typically <code>some/lib/library.js</code> modules) that contain the type definitions\n * needed by the specific control or class definition.\n *\n * @param {string} sTypeName Qualified name of the type to retrieve\n * @returns {sap.ui.base.DataType|undefined} Type object or <code>undefined</code> when\n *     no such type has been defined yet\n * @public\n */\nDataType.getType = function (sTypeName) {\n  assert(sTypeName && typeof sTypeName === 'string', \"sTypeName must be a non-empty string\");\n  var oType = mTypes[sTypeName];\n  if (!(oType instanceof DataType)) {\n    // check for array types\n    if (sTypeName.indexOf(\"[]\", sTypeName.length - 2) > 0) {\n      var sComponentTypeName = sTypeName.slice(0, -2),\n        oComponentType = this.getType(sComponentTypeName);\n      oType = oComponentType && createArrayType(oComponentType);\n      if (oType) {\n        mTypes[sTypeName] = oType;\n      }\n    } else if (sTypeName !== 'array') {\n      // check if we have a valid pre-registered enum\n      oType = mEnumRegistry[sTypeName];\n\n      /**\n       * If an enum was not registered beforehand (either explicitly via registerEnum or\n       * via a Proxy in the library namespace), we have to look it up in the global object.\n       * @deprecated since 1.120\n       */\n      if (oType == null) {\n        oType = ObjectPath.get(sTypeName);\n        if (oType != null) {\n          Log.error(`The type '${sTypeName}' was accessed via globals. Defining enums via globals is deprecated. Please require the module 'sap/ui/base/DataType' and call the static 'DataType.registerEnum' API.`);\n        }\n      }\n      if (oType instanceof DataType) {\n        mTypes[sTypeName] = oType;\n      } else if (isPlainObject(oType)) {\n        oType = mTypes[sTypeName] = createEnumType(sTypeName, oType);\n        delete mEnumRegistry[sTypeName];\n      } else if (oType) {\n        Log.warning(\"[FUTURE FATAL] '\" + sTypeName + \"' is not a valid data type. Falling back to type 'any'.\");\n        oType = mTypes.any;\n      } else {\n        Log.error(\"[FUTURE FATAL] data type '\" + sTypeName + \"' could not be found.\");\n        oType = undefined;\n      }\n    }\n  }\n  return oType;\n};\n\n/**\n * Derives a new type from a given base type.\n *\n * Example:<br>\n * <pre>\n *\n *   var fooType = DataType.createType('foo', {\n *       isValid : function(vValue) {\n *           return /^(foo(bar)?)$/.test(vValue);\n *       }\n *   }, DataType.getType('string'));\n *\n *   fooType.isValid('foo'); // true\n *   fooType.isValid('foobar'); // true\n *   fooType.isValid('==foobar=='); // false\n *\n * </pre>\n *\n * If <code>mSettings</code> contains an implementation for <code>isValid</code>,\n * then the validity check of the newly created type will first execute the check of the\n * base type and then call the given <code>isValid</code> function.\n *\n * Array types and enumeration types cannot be created with this method. They're created\n * on-the-fly by {@link #.getType DataType.getType} when such a type is looked up.\n *\n * <b>Note:</b> The creation of new primitive types is not supported. When a type is created\n * without a base type, it is automatically derived from the primitive type <code>any</code>.\n *\n * <b>Note:</b> If a type has to be used in classes, then the implementation of\n * <code>isValid</code> must exactly have the structure shown in the example above (single\n * return statement, regular expression literal of the form <code>/^(...)$/</code>, calling\n * <code>/regex/.test()</code> on the given value).\n * Only the inner part of the regular expression literal can be different.\n *\n * @param {string} sName Unique qualified name of the new type\n * @param {object} [mSettings] Settings for the new type\n * @param {any} [mSettings.defaultValue] Default value for the type (inherited if not given)\n * @param {function} [mSettings.isValid] Additional validity check function for values of the\n *                       type (inherited if not given)\n * @param {function} [mSettings.parseValue] Parse function that converts a locale independent\n *                       string into a value of the type (inherited if not given)\n * @param {sap.ui.base.DataType|string} [vBase='any'] Base type for the new type\n * @returns {sap.ui.base.DataType} The newly created type object\n * @public\n */\nDataType.createType = function (sName, mSettings, vBase) {\n  assert(typeof sName === \"string\" && sName, \"DataType.createType: type name must be a non-empty string\");\n  assert(vBase == null || vBase instanceof DataType || typeof vBase === \"string\" && vBase, \"DataType.createType: base type must be empty or a DataType or a non-empty string\");\n  if (/[\\[\\]]/.test(sName)) {\n    Log.error(\"[FUTURE FATAL] DataType.createType: array types ('something[]') must not be created with createType, \" + \"they're created on-the-fly by DataType.getType\");\n  }\n  if (typeof vBase === \"string\") {\n    vBase = DataType.getType(vBase);\n  }\n  vBase = vBase || mTypes.any;\n  if (vBase.isArrayType() || vBase.isEnumType()) {\n    Log.error(\"[FUTURE FATAL] DataType.createType: base type must not be an array- or enum-type\");\n  }\n  if (sName === 'array' || mTypes[sName] instanceof DataType) {\n    if (sName === 'array' || mTypes[sName].getBaseType() == null) {\n      throw new Error(\"DataType.createType: primitive or hidden type \" + sName + \" can't be re-defined\");\n    }\n    Log.warning(\"[FUTURE FATAL] DataTypes.createType: type \" + sName + \" is redefined. \" + \"This is an unsupported usage of DataType and might cause issues.\");\n  }\n  var oType = mTypes[sName] = createType(sName, mSettings, vBase);\n  return oType;\n};\n\n// ---- minimal support for interface types -------------------------------------------------------------------\n\nvar oInterfaces = new Set();\n\n/**\n * Registers the given array of type names as known interface types.\n * Only purpose is to enable the {@link #isInterfaceType} check.\n * @param {string[]} aTypes interface types to be registered\n * @private\n * @ui5-restricted sap.ui.core.Core\n */\nDataType.registerInterfaceTypes = function (aTypes) {\n  aTypes.forEach(function (sType) {\n    oInterfaces.add(sType);\n\n    // Defining the interface on global namespace for compatibility reasons.\n    // This has never been a public feature and it is strongly discouraged it be relied upon.\n    // An interface must always be referenced by a string literal, not via the global namespace.\n    ObjectPath.set(sType, sType);\n  });\n};\n\n/**\n * Registers an enum under the given name.\n * With version 2.0, registering an enum becomes mandatory when said enum is to be used in\n * properties of a {@link sap.ui.base.ManagedObject ManagedObject} subclass.\n *\n * Example:<br>\n * <pre>\n *    DataType.registerEnum(\"my.enums.Sample\", {\n *       \"A\": \"A\",\n *       \"B\": \"B\",\n *       ...\n *    });\n * </pre>\n *\n * @param {string} sTypeName the type name in dot syntax, e.g. sap.ui.my.EnumType\n * @param {object} mContent the enum content\n * @public\n * @since 1.120.0\n */\nDataType.registerEnum = function (sTypeName, mContent) {\n  mEnumRegistry[sTypeName] = mContent;\n};\n\n/**\n * Checks if the given object contains only static content\n * and can be regarded as an enum candidate.\n *\n * @param {object} oObject the enum candidate\n * @returns {boolean} whether the given object can be regarded as an enum candidate\n * @private\n * @ui5-restricted sap.ui.core.Lib\n */\nDataType._isEnumCandidate = function (oObject) {\n  return !Object.keys(oObject).some(key => {\n    const propertyType = typeof oObject[key];\n    return propertyType === \"object\" || propertyType === \"function\";\n  });\n};\n\n/**\n * @param {string} sType name of type to check\n * @returns {boolean} whether the given type is known to be an interface type\n * @private\n * @ui5-restricted sap.ui.base.ManagedObject\n */\nDataType.isInterfaceType = function (sType) {\n  return oInterfaces.has(sType);\n};\nexport default DataType;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar SliderBase_1;\nimport UI5Element from \"@ui5/webcomponents-base/dist/UI5Element.js\";\nimport property from \"@ui5/webcomponents-base/dist/decorators/property.js\";\nimport event from \"@ui5/webcomponents-base/dist/decorators/event.js\";\nimport litRender from \"@ui5/webcomponents-base/dist/renderer/LitRenderer.js\";\nimport ResizeHandler from \"@ui5/webcomponents-base/dist/delegate/ResizeHandler.js\";\nimport { isPhone, supportsTouch } from \"@ui5/webcomponents-base/dist/Device.js\";\nimport \"@ui5/webcomponents-icons/dist/direction-arrows.js\";\nimport { isEscape, isHome, isEnd, isUp, isDown, isRight, isLeft, isUpCtrl, isDownCtrl, isRightCtrl, isLeftCtrl, isPlus, isMinus, isPageUp, isPageDown } from \"@ui5/webcomponents-base/dist/Keys.js\";\n// Styles\nimport sliderBaseStyles from \"./generated/themes/SliderBase.css.js\";\n/**\n * Fired when the value changes and the user has finished interacting with the slider.\n * @public\n */\nlet SliderBase = SliderBase_1 =\n/**\n * @class\n *\n * ### Overview\n * @constructor\n * @extends UI5Element\n * @public\n */\nclass SliderBase extends UI5Element {\n  async formElementAnchor() {\n    return this.getFocusDomRefAsync();\n  }\n  constructor() {\n    super();\n    /**\n     * Defines the minimum value of the slider.\n     * @default 0\n     * @public\n     */\n    this.min = 0;\n    /**\n     * Defines the maximum value of the slider.\n     * @default 100\n     * @public\n     */\n    this.max = 100;\n    /**\n     * Defines the size of the slider's selection intervals (e.g. min = 0, max = 10, step = 5 would result in possible selection of the values 0, 5, 10).\n     *\n     * **Note:** If set to 0 the slider handle movement is disabled. When negative number or value other than a number, the component fallbacks to its default value.\n     * @default 1\n     * @public\n     */\n    this.step = 1;\n    /**\n     * Displays a label with a value on every N-th step.\n     *\n     * **Note:** The step and tickmarks properties must be enabled.\n     * Example - if the step value is set to 2 and the label interval is also specified to 2 - then every second\n     * tickmark will be labelled, which means every 4th value number.\n     * @default 0\n     * @public\n     */\n    this.labelInterval = 0;\n    /**\n     * Enables tickmarks visualization for each step.\n     *\n     * **Note:** The step must be a positive number.\n     * @default false\n     * @public\n     */\n    this.showTickmarks = false;\n    /**\n     * Enables handle tooltip displaying the current value.\n     * @default false\n     * @public\n     */\n    this.showTooltip = false;\n    /**\n     * Defines whether the slider is in disabled state.\n     * @default false\n     * @public\n     */\n    this.disabled = false;\n    /**\n     * @private\n     */\n    this._tooltipVisibility = \"hidden\";\n    this._labelsOverlapping = false;\n    this._hiddenTickmarks = false;\n    this.notResized = false;\n    this._isUserInteraction = false;\n    this._isInnerElementFocusing = false;\n    this._labelWidth = 0;\n    this._resizeHandler = this._handleResize.bind(this);\n    this._moveHandler = this._handleMove.bind(this);\n    this._upHandler = this._handleUp.bind(this);\n    this._stateStorage = {\n      step: undefined,\n      min: undefined,\n      max: undefined,\n      labelInterval: undefined\n    };\n    const handleTouchStartEvent = e => {\n      this._onmousedown(e);\n    };\n    this._ontouchstart = {\n      handleEvent: handleTouchStartEvent,\n      passive: true\n    };\n  }\n  _handleMove(e) {} // eslint-disable-line\n  _handleUp() {}\n  _onmousedown(e) {} // eslint-disable-line\n  _handleActionKeyPress(e) {} // eslint-disable-line\n  static get ACTION_KEYS() {\n    return [isLeft, isRight, isUp, isDown, isLeftCtrl, isRightCtrl, isUpCtrl, isDownCtrl, isPlus, isMinus, isHome, isEnd, isPageUp, isPageDown, isEscape];\n  }\n  static get MIN_SPACE_BETWEEN_TICKMARKS() {\n    return 8;\n  }\n  static get TOOLTIP_VISIBILITY() {\n    return {\n      VISIBLE: \"visible\",\n      HIDDEN: \"hidden\"\n    };\n  }\n  static get renderer() {\n    return litRender;\n  }\n  static get styles() {\n    return sliderBaseStyles;\n  }\n  get classes() {\n    return {\n      root: {\n        \"ui5-slider-root-phone\": isPhone()\n      },\n      labelContainer: {\n        \"ui5-slider-hidden-labels\": this._labelsOverlapping\n      }\n    };\n  }\n  onEnterDOM() {\n    ResizeHandler.register(this, this._resizeHandler);\n  }\n  onExitDOM() {\n    ResizeHandler.deregister(this, this._resizeHandler);\n  }\n  onAfterRendering() {\n    // Only call if the resize is triggered by a state changes other than\n    // the ones that occured on the previous resize and those caused by user interaction.\n    if (this.notResized) {\n      this._resizeHandler();\n    }\n  }\n  /** Shows the tooltip(s) if the `showTooltip` property is set to true\n   * @private\n   */\n  _onmouseover() {\n    if (this.showTooltip) {\n      this._tooltipVisibility = SliderBase_1.TOOLTIP_VISIBILITY.VISIBLE;\n    }\n  }\n  /**\n   * Hides the tooltip(s) if the `showTooltip` property is set to true\n   * @private\n   */\n  _onmouseout() {\n    if (this.showTooltip && !this.shadowRoot.activeElement) {\n      this._tooltipVisibility = SliderBase_1.TOOLTIP_VISIBILITY.HIDDEN;\n    }\n  }\n  _onkeydown(e) {\n    if (this.disabled || this._effectiveStep === 0) {\n      return;\n    }\n    if (SliderBase_1._isActionKey(e)) {\n      e.preventDefault();\n      this._isUserInteraction = true;\n      this._handleActionKeyPress(e);\n    }\n  }\n  _onkeyup() {\n    if (this.disabled) {\n      return;\n    }\n    this._isUserInteraction = false;\n  }\n  /**\n   * Flags if an inner element is currently being focused\n   * @private\n   */\n  _preserveFocus(isFocusing) {\n    this._isInnerElementFocusing = isFocusing;\n  }\n  /**\n   * Return if an inside element within the component is currently being focused\n   * @private\n   */\n  _isFocusing() {\n    return this._isInnerElementFocusing;\n  }\n  /**\n   * Prevent focus out when inner element within the component is currently being in process of focusing in.\n   * @private\n   */\n  _preventFocusOut() {\n    this.focusInnerElement();\n  }\n  /**\n   * Manages the focus between the component's inner elements\n   * @protected\n   */\n  focusInnerElement() {\n    this.focus();\n  }\n  /**\n   * Handle the responsiveness of the Slider's UI elements when resizing\n   * @private\n   */\n  _handleResize() {\n    if (!this.showTickmarks) {\n      return;\n    }\n    // Mark resizing to avoid unneccessary calls to that function after rendering\n    this.notResized = false;\n    // Convert the string represented calculation expression to a normal one\n    // Check the distance  in pixels exist between every tickmark\n    const spaceBetweenTickmarks = this._spaceBetweenTickmarks();\n    // If the pixels between the tickmarks are less than 8 only the first and the last one should be visible\n    // In such case the labels must correspond to the tickmarks, only the first and the last one should exist.\n    if (spaceBetweenTickmarks < SliderBase_1.MIN_SPACE_BETWEEN_TICKMARKS) {\n      this._hiddenTickmarks = true;\n      this._labelsOverlapping = true;\n    } else {\n      this._hiddenTickmarks = false;\n    }\n    if (this.labelInterval <= 0 || this._hiddenTickmarks) {\n      return;\n    }\n    // Check if there are any overlapping labels.\n    // If so - only the first and the last one should be visible\n    const labelItems = this.shadowRoot.querySelectorAll(\".ui5-slider-labels li\");\n    this._labelsOverlapping = [...labelItems].some(label => label.scrollWidth > label.clientWidth);\n  }\n  /**\n   * Called when the user starts interacting with the slider.\n   * After a down event on the slider root, listen for move events on window, so the slider value\n   * is updated even if the user drags the pointer outside the slider root.\n   * @protected\n   */\n  handleDownBase(e) {\n    const min = this._effectiveMin;\n    const max = this._effectiveMax;\n    const domRect = this.getBoundingClientRect();\n    const directionStart = this.directionStart;\n    const step = this._effectiveStep;\n    const newValue = SliderBase_1.getValueFromInteraction(e, step, min, max, domRect, directionStart);\n    // Mark start of a user interaction\n    this._isUserInteraction = true;\n    window.addEventListener(\"mouseup\", this._upHandler);\n    window.addEventListener(\"touchend\", this._upHandler);\n    // Only allow one type of move event to be listened to (the first one registered after the down event)\n    if (supportsTouch() && e instanceof TouchEvent) {\n      window.addEventListener(\"touchmove\", this._moveHandler);\n    } else {\n      window.addEventListener(\"mousemove\", this._moveHandler);\n    }\n    this._handleFocusOnMouseDown(e);\n    return newValue;\n  }\n  /**\n   * Forward the focus to an inner inner part within the component on press\n   * @private\n   */\n  _handleFocusOnMouseDown(e) {\n    const focusedElement = this.shadowRoot.activeElement;\n    if (!focusedElement || focusedElement !== e.target) {\n      this._preserveFocus(true);\n      this.focusInnerElement();\n    }\n  }\n  /**\n   * Called when the user finish interacting with the slider\n   * Fires an `change` event indicating a final value change, after user interaction is finished.\n   * @protected\n   */\n  handleUpBase() {\n    window.removeEventListener(\"mouseup\", this._upHandler);\n    window.removeEventListener(\"touchend\", this._upHandler);\n    // Only one of the following was attached, but it's ok to remove both as there is no error\n    window.removeEventListener(\"mousemove\", this._moveHandler);\n    window.removeEventListener(\"touchmove\", this._moveHandler);\n    this._isUserInteraction = false;\n    this._preserveFocus(false);\n  }\n  /**\n   * Updates state storage for the value-related property\n   * Fires an `input` event indicating a value change via interaction that is not yet finished.\n   * @protected\n   */\n  updateStateStorageAndFireInputEvent(valueType) {\n    this.storePropertyState(valueType);\n    if (this._isUserInteraction) {\n      this.fireEvent(\"input\");\n    }\n  }\n  /**\n   * Goes through the key shortcuts available for the component and returns 'true' if the event is triggered by one.\n   * @private\n   */\n  static _isActionKey(e) {\n    return this.ACTION_KEYS.some(actionKey => actionKey(e));\n  }\n  /**\n   * Locks the given value between min and max boundaries based on slider properties\n   * @protected\n   */\n  static clipValue(value, min, max) {\n    value = Math.min(Math.max(value, min), max);\n    return value;\n  }\n  /**\n   * Sets the slider value from an event\n   * @protected\n   */\n  static getValueFromInteraction(e, stepSize, min, max, boundingClientRect, directionStart) {\n    const pageX = this.getPageXValueFromEvent(e);\n    const value = this.computedValueFromPageX(pageX, min, max, boundingClientRect, directionStart);\n    const steppedValue = this.getSteppedValue(value, stepSize, min);\n    return this.clipValue(steppedValue, min, max);\n  }\n  /**\n   * \"Stepify\" the raw value - calculate the new value depending on the specified step property\n   * @protected\n   */\n  static getSteppedValue(value, stepSize, min) {\n    const stepModuloValue = Math.abs((value - min) % stepSize);\n    if (stepSize === 0 || stepModuloValue === 0) {\n      return value;\n    }\n    // Clip (snap) the new value to the nearest step\n    value = stepModuloValue * 2 >= stepSize ? value + stepSize - stepModuloValue : value - stepModuloValue;\n    // If the step value is not a round number get its precision\n    const stepPrecision = SliderBase_1._getDecimalPrecisionOfNumber(stepSize);\n    return Number(value.toFixed(stepPrecision));\n  }\n  /**\n   * Gets pageX value from event on user interaction with the Slider\n   * @protected\n   */\n  static getPageXValueFromEvent(e) {\n    if (supportsTouch() && e instanceof TouchEvent) {\n      if (e.targetTouches && e.targetTouches.length > 0) {\n        return e.targetTouches[0].pageX;\n      }\n      return 0;\n    }\n    return e.pageX; // MouseEvent\n  }\n  /**\n   * Computes the new value (in %) from the pageX position of the cursor.\n   * Returns the value rounded to a precision of at most 2 digits after decimal point.\n   * @protected\n   */\n  static computedValueFromPageX(pageX, min, max, boundingClientRect, directionStart) {\n    // Determine pageX position relative to the Slider DOM\n    const xRelativePosition = directionStart === \"left\" ? pageX - boundingClientRect[directionStart] : boundingClientRect[directionStart] - pageX;\n    // Calculate the percentage complete (the \"progress\")\n    const percentageComplete = xRelativePosition / boundingClientRect.width;\n    // Fit (map) the complete percentage between the min/max value range\n    return min + percentageComplete * (max - min);\n  }\n  /**\n   * Calculates the precision (decimal places) of a number, returns 0 if integer\n   * Handles scientific notation cases.\n   * @private\n   */\n  static _getDecimalPrecisionOfNumber(value) {\n    if (Number.isInteger(value)) {\n      return 0;\n    }\n    const match = String(value).match(/(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/);\n    if (!match || match.length < 2) {\n      return 0;\n    }\n    return Math.max(0, (match[1] ? match[1].length : 0) - (match[2] ? Number(match[2]) : 0));\n  }\n  /**\n   * In order to always keep the visual UI representation and the internal\n   * state in sync, the component has a 'state storage' that is updated when the\n   * current state is changed due to a user action.\n   *\n   * Check if the previously saved state is outdated. That would mean\n   * a property has been changed programmatically because the previous state\n   * is always updated in the interaction handlers.\n   *\n   * Will return true if any of the properties is not equal to its previously\n   * stored value.\n   * @protected\n   */\n  isCurrentStateOutdated() {\n    return Object.entries(this._stateStorage).some(_ref => {\n      let [propName, propValue] = _ref;\n      return this[propName] !== propValue;\n    });\n  }\n  /**\n   * Returns the last stored value of a property\n   * @protected\n   */\n  getStoredPropertyState(prop) {\n    return this._stateStorage[prop];\n  }\n  /**\n   * Check if one or more properties have been updated compared to their last\n   * saved values in the state storage.\n   * @protected\n   */\n  isPropertyUpdated() {\n    for (var _len = arguments.length, props = new Array(_len), _key = 0; _key < _len; _key++) {\n      props[_key] = arguments[_key];\n    }\n    return props.some(prop => this.getStoredPropertyState(prop) !== this[prop]);\n  }\n  /**\n   * Updates the previously saved in the _stateStorage values of one or more properties.\n   * @protected\n   */\n  storePropertyState() {\n    for (var _len2 = arguments.length, props = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      props[_key2] = arguments[_key2];\n    }\n    props.forEach(prop => {\n      this._stateStorage[prop] = this[prop];\n    });\n  }\n  /**\n   * Returns the start side of a direction - left for LTR, right for RTL\n   */\n  get directionStart() {\n    return this.effectiveDir === \"rtl\" ? \"right\" : \"left\";\n  }\n  /**\n   * Calculates the labels amount, width and text and creates them\n   * @private\n   */\n  _createLabels() {\n    if (!this.labelInterval || !this.showTickmarks) {\n      return;\n    }\n    const labelInterval = this.labelInterval;\n    const step = this._effectiveStep;\n    const newNumberOfLabels = (this._effectiveMax - this._effectiveMin) / (step * labelInterval);\n    // If the required labels are already rendered\n    if (newNumberOfLabels === this._oldNumberOfLabels && this._oldMin === this._effectiveMin && this._oldMax === this._effectiveMax) {\n      return;\n    }\n    this._oldMin = this._effectiveMin;\n    this._oldMax = this._effectiveMax;\n    this._oldNumberOfLabels = newNumberOfLabels;\n    this._labelWidth = 100 / newNumberOfLabels;\n    this._labelValues = [];\n    // If the step value is not a round number get its precision\n    const stepPrecision = SliderBase_1._getDecimalPrecisionOfNumber(step);\n    // numberOfLabels below can be float so that the \"distance betweenlabels labels\"\n    // calculation to be precize (exactly the same as the distance between the tickmarks).\n    // That's ok as the loop stop condition is set to an integer, so it will practically\n    // \"floor\" the number of labels anyway.\n    for (let i = 0; i <= newNumberOfLabels; i++) {\n      // Format the label numbers with the same decimal precision as the value of the step property\n      const labelItemNumber = (i * step * labelInterval + this._effectiveMin).toFixed(stepPrecision);\n      this._labelValues.push(labelItemNumber);\n    }\n  }\n  _handleActionKeyPressBase(e, affectedPropName) {\n    const isUpAction = SliderBase_1._isIncreaseValueAction(e);\n    const isBigStep = SliderBase_1._isBigStepAction(e);\n    const currentValue = this[affectedPropName];\n    const min = this._effectiveMin;\n    const max = this._effectiveMax;\n    // We need to take into consideration the effective direction of the slider - rtl or ltr.\n    // While in ltr, the left arrow key decreases the value, in rtl it should actually increase it.\n    let step = this.effectiveDir === \"rtl\" ? -this._effectiveStep : this._effectiveStep;\n    // If the action key corresponds to a long step and the slider has more than 10 normal steps,\n    // make a jump of 1/10th of the Slider's length, otherwise just use the normal step property.\n    step = isBigStep && (max - min) / step > 10 ? (max - min) / 10 : step;\n    if (isEnd(e)) {\n      return max - currentValue;\n    }\n    if (isHome(e)) {\n      return (currentValue - min) * -1;\n    }\n    return isUpAction ? step : step * -1;\n  }\n  static _isDecreaseValueAction(e) {\n    return isDown(e) || isDownCtrl(e) || isLeft(e) || isLeftCtrl(e) || isMinus(e) || isPageDown(e);\n  }\n  static _isIncreaseValueAction(e) {\n    return isUp(e) || isUpCtrl(e) || isRight(e) || isRightCtrl(e) || isPlus(e) || isPageUp(e);\n  }\n  static _isBigStepAction(e) {\n    return isDownCtrl(e) || isUpCtrl(e) || isLeftCtrl(e) || isRightCtrl(e) || isPageUp(e) || isPageDown(e);\n  }\n  get _tickmarksCount() {\n    return (this._effectiveMax - this._effectiveMin) / this._effectiveStep;\n  }\n  /**\n   * Calculates space between tickmarks\n   * @private\n   */\n  _spaceBetweenTickmarks() {\n    return this.getBoundingClientRect().width / this._tickmarksCount;\n  }\n  /**\n   * Notify in case of a invalid step value type\n   * @private\n   */\n  _validateStep(step) {\n    if (step === 0) {\n      console.warn(\"The 'step' property must be a positive float number\"); // eslint-disable-line\n    }\n    if (step < 0) {\n      console.warn(\"The 'step' property must be a positive float number. The provided negative number has been converted to its positve equivalent\"); // eslint-disable-line\n    }\n    if (Number.isNaN(step)) {\n      console.warn(\"The 'step' property must be a positive float number. It has been set to its default value of 1\"); // eslint-disable-line\n    }\n  }\n  get _labels() {\n    return this._labelValues || [];\n  }\n  /**\n   * Normalizes a new `step` property value.\n   * If tickmarks are enabled recreates them according to it.\n   * @private\n   */\n  get _effectiveStep() {\n    let step = this.step;\n    if (step < 0) {\n      step = Math.abs(step);\n    }\n    if (Number.isNaN(step)) {\n      step = 1;\n    }\n    return step;\n  }\n  get _effectiveMin() {\n    return Math.min(this.min, this.max);\n  }\n  get _effectiveMax() {\n    return Math.max(this.min, this.max);\n  }\n  get _tabIndex() {\n    return this.disabled ? \"-1\" : \"0\";\n  }\n  get _ariaLabelledByHandleRefs() {\n    return [`${this._id}-accName`, `${this._id}-sliderDesc`].join(\" \").trim();\n  }\n};\n__decorate([property({\n  type: Number\n})], SliderBase.prototype, \"min\", void 0);\n__decorate([property({\n  type: Number\n})], SliderBase.prototype, \"max\", void 0);\n__decorate([property()], SliderBase.prototype, \"name\", void 0);\n__decorate([property({\n  type: Number\n})], SliderBase.prototype, \"step\", void 0);\n__decorate([property({\n  type: Number\n})], SliderBase.prototype, \"labelInterval\", void 0);\n__decorate([property({\n  type: Boolean\n})], SliderBase.prototype, \"showTickmarks\", void 0);\n__decorate([property({\n  type: Boolean\n})], SliderBase.prototype, \"showTooltip\", void 0);\n__decorate([property({\n  type: Boolean\n})], SliderBase.prototype, \"disabled\", void 0);\n__decorate([property()], SliderBase.prototype, \"accessibleName\", void 0);\n__decorate([property()], SliderBase.prototype, \"_tooltipVisibility\", void 0);\n__decorate([property({\n  type: Boolean\n})], SliderBase.prototype, \"_labelsOverlapping\", void 0);\n__decorate([property({\n  type: Boolean\n})], SliderBase.prototype, \"_hiddenTickmarks\", void 0);\nSliderBase = SliderBase_1 = __decorate([event(\"change\")\n/**\n * Fired when the value changes due to user interaction that is not yet finished - during mouse/touch dragging.\n * @public\n */, event(\"input\")\n/**\n * @class\n *\n * ### Overview\n * @constructor\n * @extends UI5Element\n * @public\n */], SliderBase);\nexport default SliderBase;","map":{"version":3,"names":["UI5Element","property","event","litRender","ResizeHandler","isPhone","supportsTouch","isEscape","isHome","isEnd","isUp","isDown","isRight","isLeft","isUpCtrl","isDownCtrl","isRightCtrl","isLeftCtrl","isPlus","isMinus","isPageUp","isPageDown","sliderBaseStyles","SliderBase","SliderBase_1","formElementAnchor","getFocusDomRefAsync","constructor","min","max","step","labelInterval","showTickmarks","showTooltip","disabled","_tooltipVisibility","_labelsOverlapping","_hiddenTickmarks","notResized","_isUserInteraction","_isInnerElementFocusing","_labelWidth","_resizeHandler","_handleResize","bind","_moveHandler","_handleMove","_upHandler","_handleUp","_stateStorage","undefined","handleTouchStartEvent","e","_onmousedown","_ontouchstart","handleEvent","passive","_handleActionKeyPress","ACTION_KEYS","MIN_SPACE_BETWEEN_TICKMARKS","TOOLTIP_VISIBILITY","VISIBLE","HIDDEN","renderer","styles","classes","root","labelContainer","onEnterDOM","register","onExitDOM","deregister","onAfterRendering","_onmouseover","_onmouseout","shadowRoot","activeElement","_onkeydown","_effectiveStep","_isActionKey","preventDefault","_onkeyup","_preserveFocus","isFocusing","_isFocusing","_preventFocusOut","focusInnerElement","focus","spaceBetweenTickmarks","_spaceBetweenTickmarks","labelItems","querySelectorAll","some","label","scrollWidth","clientWidth","handleDownBase","_effectiveMin","_effectiveMax","domRect","getBoundingClientRect","directionStart","newValue","getValueFromInteraction","window","addEventListener","TouchEvent","_handleFocusOnMouseDown","focusedElement","target","handleUpBase","removeEventListener","updateStateStorageAndFireInputEvent","valueType","storePropertyState","fireEvent","actionKey","clipValue","value","Math","stepSize","boundingClientRect","pageX","getPageXValueFromEvent","computedValueFromPageX","steppedValue","getSteppedValue","stepModuloValue","abs","stepPrecision","_getDecimalPrecisionOfNumber","Number","toFixed","targetTouches","length","xRelativePosition","percentageComplete","width","isInteger","match","String","isCurrentStateOutdated","Object","entries","_ref","propName","propValue","getStoredPropertyState","prop","isPropertyUpdated","_len","arguments","props","Array","_key","_len2","_key2","forEach","effectiveDir","_createLabels","newNumberOfLabels","_oldNumberOfLabels","_oldMin","_oldMax","_labelValues","i","labelItemNumber","push","_handleActionKeyPressBase","affectedPropName","isUpAction","_isIncreaseValueAction","isBigStep","_isBigStepAction","currentValue","_isDecreaseValueAction","_tickmarksCount","_validateStep","console","warn","isNaN","_labels","_tabIndex","_ariaLabelledByHandleRefs","_id","join","trim","__decorate","type","Boolean"],"sources":["/home/user/projects/reactproj/node_modules/@ui5/webcomponents/src/SliderBase.ts"],"sourcesContent":["import UI5Element from \"@ui5/webcomponents-base/dist/UI5Element.js\";\nimport property from \"@ui5/webcomponents-base/dist/decorators/property.js\";\nimport event from \"@ui5/webcomponents-base/dist/decorators/event.js\";\nimport litRender from \"@ui5/webcomponents-base/dist/renderer/LitRenderer.js\";\nimport ResizeHandler from \"@ui5/webcomponents-base/dist/delegate/ResizeHandler.js\";\nimport { isPhone, supportsTouch } from \"@ui5/webcomponents-base/dist/Device.js\";\nimport type { ResizeObserverCallback } from \"@ui5/webcomponents-base/dist/delegate/ResizeHandler.js\";\nimport type { PassiveEventListenerObject } from \"@ui5/webcomponents-base/dist/types.js\";\nimport \"@ui5/webcomponents-icons/dist/direction-arrows.js\";\nimport {\n\tisEscape, isHome, isEnd, isUp, isDown, isRight, isLeft, isUpCtrl, isDownCtrl, isRightCtrl, isLeftCtrl, isPlus, isMinus, isPageUp, isPageDown,\n} from \"@ui5/webcomponents-base/dist/Keys.js\";\n\n// Styles\nimport sliderBaseStyles from \"./generated/themes/SliderBase.css.js\";\n\ntype StateStorage = {\n\t[key: string]: number | undefined,\n}\n\ntype DirectionStart = \"left\" | \"right\";\n\n/**\n * Fired when the value changes and the user has finished interacting with the slider.\n * @public\n */\n@event(\"change\")\n\n/**\n * Fired when the value changes due to user interaction that is not yet finished - during mouse/touch dragging.\n * @public\n */\n@event(\"input\")\n\n/**\n * @class\n *\n * ### Overview\n * @constructor\n * @extends UI5Element\n * @public\n */\nabstract class SliderBase extends UI5Element {\n\t/**\n\t * Defines the minimum value of the slider.\n\t * @default 0\n\t * @public\n\t */\n\t@property({ type: Number })\n\tmin = 0;\n\n\t/**\n\t * Defines the maximum value of the slider.\n\t * @default 100\n\t * @public\n\t */\n\t@property({ type: Number })\n\tmax = 100;\n\n\t/**\n\t * Determines the name by which the component will be identified upon submission in an HTML form.\n\t *\n\t * **Note:** This property is only applicable within the context of an HTML Form element.\n\t * @default undefined\n\t * @public\n\t * @since 2.0.0\n\t */\n\t@property()\n\tname?: string;\n\n\t/**\n\t * Defines the size of the slider's selection intervals (e.g. min = 0, max = 10, step = 5 would result in possible selection of the values 0, 5, 10).\n\t *\n\t * **Note:** If set to 0 the slider handle movement is disabled. When negative number or value other than a number, the component fallbacks to its default value.\n\t * @default 1\n\t * @public\n\t */\n\t@property({ type: Number })\n\tstep = 1;\n\n\t/**\n\t * Displays a label with a value on every N-th step.\n\t *\n\t * **Note:** The step and tickmarks properties must be enabled.\n\t * Example - if the step value is set to 2 and the label interval is also specified to 2 - then every second\n\t * tickmark will be labelled, which means every 4th value number.\n\t * @default 0\n\t * @public\n\t */\n\t@property({ type: Number })\n\tlabelInterval = 0;\n\n\t/**\n\t * Enables tickmarks visualization for each step.\n\t *\n\t * **Note:** The step must be a positive number.\n\t * @default false\n\t * @public\n\t */\n\t@property({ type: Boolean })\n\tshowTickmarks = false;\n\n\t/**\n\t * Enables handle tooltip displaying the current value.\n\t * @default false\n\t * @public\n\t */\n\t@property({ type: Boolean })\n\tshowTooltip = false;\n\n\t/**\n\t * Defines whether the slider is in disabled state.\n\t * @default false\n\t * @public\n\t */\n\t@property({ type: Boolean })\n\tdisabled = false;\n\n\t/**\n\t * Defines the accessible ARIA name of the component.\n\t * @default undefined\n\t * @public\n\t * @since 1.4.0\n\t */\n\t@property()\n\taccessibleName?: string;\n\n\t/**\n\t * @private\n\t */\n\t@property()\n\t_tooltipVisibility = \"hidden\";\n\n\t@property({ type: Boolean })\n\t_labelsOverlapping = false;\n\n\t@property({ type: Boolean })\n\t_hiddenTickmarks = false;\n\n\t_resizeHandler: ResizeObserverCallback;\n\t_moveHandler: (e: TouchEvent | MouseEvent) => void;\n\t_upHandler: () => void;\n\t_stateStorage: StateStorage;\n\t_ontouchstart: PassiveEventListenerObject;\n\tnotResized = false;\n\t_isUserInteraction = false;\n\t_isInnerElementFocusing = false;\n\t_oldNumberOfLabels?: number;\n\t_oldMin?: number;\n\t_oldMax?: number;\n\t_labelWidth = 0;\n\t_labelValues?: Array<string>;\n\n\tasync formElementAnchor() {\n\t\treturn this.getFocusDomRefAsync();\n\t}\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._resizeHandler = this._handleResize.bind(this);\n\t\tthis._moveHandler = this._handleMove.bind(this);\n\t\tthis._upHandler = this._handleUp.bind(this);\n\n\t\tthis._stateStorage = {\n\t\t\tstep: undefined,\n\t\t\tmin: undefined,\n\t\t\tmax: undefined,\n\t\t\tlabelInterval: undefined,\n\t\t};\n\n\t\tconst handleTouchStartEvent = (e: TouchEvent) => {\n\t\t\tthis._onmousedown(e);\n\t\t};\n\n\t\tthis._ontouchstart = {\n\t\t\thandleEvent: handleTouchStartEvent,\n\t\t\tpassive: true,\n\t\t};\n\t}\n\n\t_handleMove(e: TouchEvent | MouseEvent) {} // eslint-disable-line\n\n\t_handleUp() {}\n\n\t_onmousedown(e: TouchEvent | MouseEvent) {} // eslint-disable-line\n\n\t_handleActionKeyPress(e: Event) {} // eslint-disable-line\n\n\t// used in base template, but implemented in subclasses\n\tabstract styles: {\n\t\tlabel: object,\n\t\tlabelContainer: object,\n\t};\n\n\tabstract tickmarksObject: any;\n\tabstract _ariaLabelledByText: string;\n\n\tstatic get ACTION_KEYS() {\n\t\treturn [\n\t\t\tisLeft,\n\t\t\tisRight,\n\t\t\tisUp,\n\t\t\tisDown,\n\t\t\tisLeftCtrl,\n\t\t\tisRightCtrl,\n\t\t\tisUpCtrl,\n\t\t\tisDownCtrl,\n\t\t\tisPlus,\n\t\t\tisMinus,\n\t\t\tisHome,\n\t\t\tisEnd,\n\t\t\tisPageUp,\n\t\t\tisPageDown,\n\t\t\tisEscape,\n\t\t];\n\t}\n\n\tstatic get MIN_SPACE_BETWEEN_TICKMARKS() {\n\t\treturn 8;\n\t}\n\n\tstatic get TOOLTIP_VISIBILITY() {\n\t\treturn {\n\t\t\tVISIBLE: \"visible\",\n\t\t\tHIDDEN: \"hidden\",\n\t\t};\n\t}\n\n\tstatic get renderer() {\n\t\treturn litRender;\n\t}\n\n\tstatic get styles() {\n\t\treturn sliderBaseStyles;\n\t}\n\n\tget classes() {\n\t\treturn {\n\t\t\troot: {\n\t\t\t\t\"ui5-slider-root-phone\": isPhone(),\n\t\t\t},\n\t\t\tlabelContainer: {\n\t\t\t\t\"ui5-slider-hidden-labels\": this._labelsOverlapping,\n\t\t\t},\n\t\t};\n\t}\n\n\tonEnterDOM() {\n\t\tResizeHandler.register(this, this._resizeHandler);\n\t}\n\n\tonExitDOM() {\n\t\tResizeHandler.deregister(this, this._resizeHandler);\n\t}\n\n\tonAfterRendering() {\n\t\t// Only call if the resize is triggered by a state changes other than\n\t\t// the ones that occured on the previous resize and those caused by user interaction.\n\t\tif (this.notResized) {\n\t\t\tthis._resizeHandler();\n\t\t}\n\t}\n\n\t/** Shows the tooltip(s) if the `showTooltip` property is set to true\n\t * @private\n\t */\n\t_onmouseover() {\n\t\tif (this.showTooltip) {\n\t\t\tthis._tooltipVisibility = SliderBase.TOOLTIP_VISIBILITY.VISIBLE;\n\t\t}\n\t}\n\n\t/**\n\t * Hides the tooltip(s) if the `showTooltip` property is set to true\n\t * @private\n\t */\n\t_onmouseout() {\n\t\tif (this.showTooltip && !this.shadowRoot!.activeElement) {\n\t\t\tthis._tooltipVisibility = SliderBase.TOOLTIP_VISIBILITY.HIDDEN;\n\t\t}\n\t}\n\n\t_onkeydown(e: KeyboardEvent) {\n\t\tif (this.disabled || this._effectiveStep === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (SliderBase._isActionKey(e)) {\n\t\t\te.preventDefault();\n\n\t\t\tthis._isUserInteraction = true;\n\t\t\tthis._handleActionKeyPress(e);\n\t\t}\n\t}\n\n\t_onkeyup() {\n\t\tif (this.disabled) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._isUserInteraction = false;\n\t}\n\n\t/**\n\t * Flags if an inner element is currently being focused\n\t * @private\n\t */\n\t_preserveFocus(isFocusing: boolean) {\n\t\tthis._isInnerElementFocusing = isFocusing;\n\t}\n\n\t/**\n\t * Return if an inside element within the component is currently being focused\n\t * @private\n\t */\n\t_isFocusing() {\n\t\treturn this._isInnerElementFocusing;\n\t}\n\n\t/**\n\t * Prevent focus out when inner element within the component is currently being in process of focusing in.\n\t * @private\n\t */\n\t_preventFocusOut() {\n\t\tthis.focusInnerElement();\n\t}\n\n\t/**\n\t * Manages the focus between the component's inner elements\n\t * @protected\n\t */\n\tfocusInnerElement() {\n\t\tthis.focus();\n\t}\n\n\t/**\n\t * Handle the responsiveness of the Slider's UI elements when resizing\n\t * @private\n\t */\n\t_handleResize() {\n\t\tif (!this.showTickmarks) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Mark resizing to avoid unneccessary calls to that function after rendering\n\t\tthis.notResized = false;\n\n\t\t// Convert the string represented calculation expression to a normal one\n\t\t// Check the distance  in pixels exist between every tickmark\n\t\tconst spaceBetweenTickmarks = this._spaceBetweenTickmarks();\n\n\t\t// If the pixels between the tickmarks are less than 8 only the first and the last one should be visible\n\t\t// In such case the labels must correspond to the tickmarks, only the first and the last one should exist.\n\t\tif (spaceBetweenTickmarks < SliderBase.MIN_SPACE_BETWEEN_TICKMARKS) {\n\t\t\tthis._hiddenTickmarks = true;\n\t\t\tthis._labelsOverlapping = true;\n\t\t} else {\n\t\t\tthis._hiddenTickmarks = false;\n\t\t}\n\n\t\tif (this.labelInterval <= 0 || this._hiddenTickmarks) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if there are any overlapping labels.\n\t\t// If so - only the first and the last one should be visible\n\t\tconst labelItems = this.shadowRoot!.querySelectorAll(\".ui5-slider-labels li\");\n\t\tthis._labelsOverlapping = [...labelItems].some(label => label.scrollWidth > label.clientWidth);\n\t}\n\n\t/**\n\t * Called when the user starts interacting with the slider.\n\t * After a down event on the slider root, listen for move events on window, so the slider value\n\t * is updated even if the user drags the pointer outside the slider root.\n\t * @protected\n\t */\n\thandleDownBase(e: TouchEvent | MouseEvent) {\n\t\tconst min = this._effectiveMin;\n\t\tconst max = this._effectiveMax;\n\t\tconst domRect = this.getBoundingClientRect();\n\t\tconst directionStart = this.directionStart;\n\t\tconst step = this._effectiveStep;\n\t\tconst newValue = SliderBase.getValueFromInteraction(e, step, min, max, domRect, directionStart);\n\n\t\t// Mark start of a user interaction\n\t\tthis._isUserInteraction = true;\n\n\t\twindow.addEventListener(\"mouseup\", this._upHandler);\n\t\twindow.addEventListener(\"touchend\", this._upHandler);\n\t\t// Only allow one type of move event to be listened to (the first one registered after the down event)\n\t\tif (supportsTouch() && e instanceof TouchEvent) {\n\t\t\twindow.addEventListener(\"touchmove\", this._moveHandler);\n\t\t} else {\n\t\t\twindow.addEventListener(\"mousemove\", this._moveHandler);\n\t\t}\n\n\t\tthis._handleFocusOnMouseDown(e);\n\t\treturn newValue;\n\t}\n\n\t/**\n\t * Forward the focus to an inner inner part within the component on press\n\t * @private\n\t */\n\t_handleFocusOnMouseDown(e: TouchEvent | MouseEvent) {\n\t\tconst focusedElement = this.shadowRoot!.activeElement;\n\n\t\tif (!focusedElement || focusedElement !== e.target) {\n\t\t\tthis._preserveFocus(true);\n\t\t\tthis.focusInnerElement();\n\t\t}\n\t}\n\n\t/**\n\t * Called when the user finish interacting with the slider\n\t * Fires an `change` event indicating a final value change, after user interaction is finished.\n\t * @protected\n\t */\n\thandleUpBase() {\n\t\twindow.removeEventListener(\"mouseup\", this._upHandler);\n\t\twindow.removeEventListener(\"touchend\", this._upHandler);\n\t\t// Only one of the following was attached, but it's ok to remove both as there is no error\n\t\twindow.removeEventListener(\"mousemove\", this._moveHandler);\n\t\twindow.removeEventListener(\"touchmove\", this._moveHandler);\n\n\t\tthis._isUserInteraction = false;\n\t\tthis._preserveFocus(false);\n\t}\n\n\t/**\n\t * Updates state storage for the value-related property\n\t * Fires an `input` event indicating a value change via interaction that is not yet finished.\n\t * @protected\n\t */\n\tupdateStateStorageAndFireInputEvent(valueType: string) {\n\t\tthis.storePropertyState(valueType);\n\t\tif (this._isUserInteraction) {\n\t\t\tthis.fireEvent(\"input\");\n\t\t}\n\t}\n\n\t/**\n\t * Goes through the key shortcuts available for the component and returns 'true' if the event is triggered by one.\n\t * @private\n\t */\n\tstatic _isActionKey(e: KeyboardEvent) {\n\t\treturn this.ACTION_KEYS.some(actionKey => actionKey(e));\n\t}\n\n\t/**\n\t * Locks the given value between min and max boundaries based on slider properties\n\t * @protected\n\t */\n\tstatic clipValue(value: number, min: number, max: number): number {\n\t\tvalue = Math.min(Math.max(value, min), max);\n\t\treturn value;\n\t}\n\n\t/**\n\t * Sets the slider value from an event\n\t * @protected\n\t */\n\tstatic getValueFromInteraction(e: TouchEvent | MouseEvent, stepSize: number, min: number, max: number, boundingClientRect: DOMRect, directionStart: DirectionStart): number {\n\t\tconst pageX = this.getPageXValueFromEvent(e);\n\t\tconst value = this.computedValueFromPageX(pageX, min, max, boundingClientRect, directionStart);\n\t\tconst steppedValue = this.getSteppedValue(value, stepSize, min);\n\n\t\treturn this.clipValue(steppedValue, min, max);\n\t}\n\n\t/**\n\t * \"Stepify\" the raw value - calculate the new value depending on the specified step property\n\t * @protected\n\t */\n\tstatic getSteppedValue(value: number, stepSize: number, min: number): number {\n\t\tconst stepModuloValue = Math.abs((value - min) % stepSize);\n\n\t\tif (stepSize === 0 || stepModuloValue === 0) {\n\t\t\treturn value;\n\t\t}\n\n\t\t// Clip (snap) the new value to the nearest step\n\t\tvalue = (stepModuloValue * 2 >= stepSize) ? (value + stepSize) - stepModuloValue : value - stepModuloValue;\n\n\t\t// If the step value is not a round number get its precision\n\t\tconst stepPrecision = SliderBase._getDecimalPrecisionOfNumber(stepSize);\n\t\treturn Number(value.toFixed(stepPrecision));\n\t}\n\n\t/**\n\t * Gets pageX value from event on user interaction with the Slider\n\t * @protected\n\t */\n\tstatic getPageXValueFromEvent(e: TouchEvent | MouseEvent): number {\n\t\tif (supportsTouch() && e instanceof TouchEvent) {\n\t\t\tif (e.targetTouches && e.targetTouches.length > 0) {\n\t\t\t\treturn e.targetTouches[0].pageX;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn (e as MouseEvent).pageX; // MouseEvent\n\t}\n\n\t/**\n\t * Computes the new value (in %) from the pageX position of the cursor.\n\t * Returns the value rounded to a precision of at most 2 digits after decimal point.\n\t * @protected\n\t */\n\tstatic computedValueFromPageX(pageX: number, min: number, max: number, boundingClientRect: DOMRect, directionStart: DirectionStart) {\n\t\t// Determine pageX position relative to the Slider DOM\n\t\tconst xRelativePosition = directionStart === \"left\" ? pageX - boundingClientRect[directionStart] : boundingClientRect[directionStart] - pageX;\n\t\t// Calculate the percentage complete (the \"progress\")\n\t\tconst percentageComplete = xRelativePosition / boundingClientRect.width;\n\t\t// Fit (map) the complete percentage between the min/max value range\n\t\treturn min + percentageComplete * (max - min);\n\t}\n\n\t/**\n\t * Calculates the precision (decimal places) of a number, returns 0 if integer\n\t * Handles scientific notation cases.\n\t * @private\n\t */\n\tstatic _getDecimalPrecisionOfNumber(value: number) {\n\t\tif (Number.isInteger(value)) {\n\t\t\treturn 0;\n\t\t}\n\t\tconst match = (String(value)).match(/(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/);\n\t\tif (!match || match.length < 2) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn Math.max(0, (match[1] ? match[1].length : 0) - (match[2] ? Number(match[2]) : 0));\n\t}\n\n\t/**\n\t * In order to always keep the visual UI representation and the internal\n\t * state in sync, the component has a 'state storage' that is updated when the\n\t * current state is changed due to a user action.\n\t *\n\t * Check if the previously saved state is outdated. That would mean\n\t * a property has been changed programmatically because the previous state\n\t * is always updated in the interaction handlers.\n\t *\n\t * Will return true if any of the properties is not equal to its previously\n\t * stored value.\n\t * @protected\n\t */\n\tisCurrentStateOutdated() {\n\t\treturn Object.entries(this._stateStorage).some(([propName, propValue]) => this[propName as keyof SliderBase] !== propValue);\n\t}\n\n\t/**\n\t * Returns the last stored value of a property\n\t * @protected\n\t */\n\tgetStoredPropertyState(prop: string) {\n\t\treturn this._stateStorage[prop as keyof StateStorage];\n\t}\n\n\t/**\n\t * Check if one or more properties have been updated compared to their last\n\t * saved values in the state storage.\n\t * @protected\n\t */\n\tisPropertyUpdated(...props: Array<string>) {\n\t\treturn props.some(prop => this.getStoredPropertyState(prop) !== this[prop as keyof SliderBase]);\n\t}\n\n\t/**\n\t * Updates the previously saved in the _stateStorage values of one or more properties.\n\t * @protected\n\t */\n\tstorePropertyState(...props: Array<string>) {\n\t\tprops.forEach(prop => {\n\t\t\tthis._stateStorage[prop as keyof StateStorage] = this[prop as keyof SliderBase] as number;\n\t\t});\n\t}\n\n\t/**\n\t * Returns the start side of a direction - left for LTR, right for RTL\n\t */\n\tget directionStart() {\n\t\treturn this.effectiveDir === \"rtl\" ? \"right\" : \"left\";\n\t}\n\n\t/**\n\t * Calculates the labels amount, width and text and creates them\n\t * @private\n\t */\n\t_createLabels() {\n\t\tif (!this.labelInterval || !this.showTickmarks) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst labelInterval = this.labelInterval;\n\t\tconst step = this._effectiveStep;\n\t\tconst newNumberOfLabels = (this._effectiveMax - this._effectiveMin) / (step * labelInterval);\n\n\t\t// If the required labels are already rendered\n\t\tif (newNumberOfLabels === this._oldNumberOfLabels && this._oldMin === this._effectiveMin && this._oldMax === this._effectiveMax) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._oldMin = this._effectiveMin;\n\t\tthis._oldMax = this._effectiveMax;\n\t\tthis._oldNumberOfLabels = newNumberOfLabels;\n\t\tthis._labelWidth = 100 / newNumberOfLabels;\n\t\tthis._labelValues = [];\n\n\t\t// If the step value is not a round number get its precision\n\t\tconst stepPrecision = SliderBase._getDecimalPrecisionOfNumber(step);\n\n\t\t// numberOfLabels below can be float so that the \"distance betweenlabels labels\"\n\t\t// calculation to be precize (exactly the same as the distance between the tickmarks).\n\t\t// That's ok as the loop stop condition is set to an integer, so it will practically\n\t\t// \"floor\" the number of labels anyway.\n\t\tfor (let i = 0; i <= newNumberOfLabels; i++) {\n\t\t\t// Format the label numbers with the same decimal precision as the value of the step property\n\t\t\tconst labelItemNumber = ((i * step * labelInterval) + this._effectiveMin).toFixed(stepPrecision);\n\t\t\tthis._labelValues.push(labelItemNumber);\n\t\t}\n\t}\n\n\t_handleActionKeyPressBase(e: KeyboardEvent, affectedPropName: string) {\n\t\tconst isUpAction = SliderBase._isIncreaseValueAction(e);\n\t\tconst isBigStep = SliderBase._isBigStepAction(e);\n\n\t\tconst currentValue = this[affectedPropName as keyof SliderBase] as number;\n\t\tconst min = this._effectiveMin;\n\t\tconst max = this._effectiveMax;\n\n\t\t// We need to take into consideration the effective direction of the slider - rtl or ltr.\n\t\t// While in ltr, the left arrow key decreases the value, in rtl it should actually increase it.\n\t\tlet step = this.effectiveDir === \"rtl\" ? -this._effectiveStep : this._effectiveStep;\n\n\t\t// If the action key corresponds to a long step and the slider has more than 10 normal steps,\n\t\t// make a jump of 1/10th of the Slider's length, otherwise just use the normal step property.\n\t\tstep = isBigStep && ((max - min) / step > 10) ? (max - min) / 10 : step;\n\n\t\tif (isEnd(e)) {\n\t\t\treturn max - currentValue;\n\t\t}\n\n\t\tif (isHome(e)) {\n\t\t\treturn (currentValue - min) * -1;\n\t\t}\n\n\t\treturn isUpAction ? step : step * -1;\n\t}\n\n\tstatic _isDecreaseValueAction(e: KeyboardEvent) {\n\t\treturn isDown(e) || isDownCtrl(e) || isLeft(e) || isLeftCtrl(e) || isMinus(e) || isPageDown(e);\n\t}\n\n\tstatic _isIncreaseValueAction(e: KeyboardEvent) {\n\t\treturn isUp(e) || isUpCtrl(e) || isRight(e) || isRightCtrl(e) || isPlus(e) || isPageUp(e);\n\t}\n\n\tstatic _isBigStepAction(e: KeyboardEvent) {\n\t\treturn isDownCtrl(e) || isUpCtrl(e) || isLeftCtrl(e) || isRightCtrl(e) || isPageUp(e) || isPageDown(e);\n\t}\n\n\tget _tickmarksCount() {\n\t\treturn (this._effectiveMax - this._effectiveMin) / this._effectiveStep;\n\t}\n\n\t/**\n\t * Calculates space between tickmarks\n\t * @private\n\t */\n\t_spaceBetweenTickmarks() {\n\t\treturn this.getBoundingClientRect().width / this._tickmarksCount;\n\t}\n\n\t/**\n\t * Notify in case of a invalid step value type\n\t * @private\n\t */\n\t_validateStep(step: number) {\n\t\tif (step === 0) {\n\t\t\tconsole.warn(\"The 'step' property must be a positive float number\"); // eslint-disable-line\n\t\t}\n\n\t\tif (step < 0) {\n\t\t\tconsole.warn(\"The 'step' property must be a positive float number. The provided negative number has been converted to its positve equivalent\"); // eslint-disable-line\n\t\t}\n\n\t\tif (Number.isNaN(step)) {\n\t\t\tconsole.warn(\"The 'step' property must be a positive float number. It has been set to its default value of 1\"); // eslint-disable-line\n\t\t}\n\t}\n\n\tget _labels() {\n\t\treturn this._labelValues || [];\n\t}\n\n\t/**\n\t * Normalizes a new `step` property value.\n\t * If tickmarks are enabled recreates them according to it.\n\t * @private\n\t */\n\tget _effectiveStep() {\n\t\tlet step = this.step;\n\n\t\tif (step < 0) {\n\t\t\tstep = Math.abs(step);\n\t\t}\n\n\t\tif (Number.isNaN(step)) {\n\t\t\tstep = 1;\n\t\t}\n\n\t\treturn step;\n\t}\n\n\tget _effectiveMin() {\n\t\treturn Math.min(this.min, this.max);\n\t}\n\n\tget _effectiveMax() {\n\t\treturn Math.max(this.min, this.max);\n\t}\n\n\tget _tabIndex() {\n\t\treturn this.disabled ? \"-1\" : \"0\";\n\t}\n\n\tget _ariaLabelledByHandleRefs() {\n\t\treturn [`${this._id}-accName`, `${this._id}-sliderDesc`].join(\" \").trim();\n\t}\n}\n\nexport default SliderBase;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
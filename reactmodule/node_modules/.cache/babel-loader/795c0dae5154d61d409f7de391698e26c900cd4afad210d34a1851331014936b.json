{"ast":null,"code":"'use client';\n\nimport { useEffect } from 'react';\nimport { AnalyticalTableSelectionBehavior, AnalyticalTableSelectionMode } from '../../../enums/index.js';\nconst getParentRow = (id, rowsById) => {\n  let lastDotIndex = id.lastIndexOf('.');\n  if (lastDotIndex === -1) {\n    lastDotIndex = Infinity;\n  }\n  const parentRowId = id.slice(0, lastDotIndex);\n  return [rowsById[parentRowId], lastDotIndex];\n};\nconst getIndeterminateRowIds = id => {\n  const indeterminateRowsById = {};\n  const lastDotIndex = id.lastIndexOf('.');\n  indeterminateRowsById[id] = true;\n  if (lastDotIndex !== -1) {\n    // set all parent rows to indeterminate\n    Object.assign(indeterminateRowsById, getIndeterminateRowIds(id.slice(0, lastDotIndex)));\n  }\n  return indeterminateRowsById;\n};\nconst getIndeterminate = (rows, rowsById, state) => {\n  const indeterminateRowsById = {};\n  let usedParentIndex = '';\n  const getIndeterminateRecursive = function (subRows) {\n    let rowIdScope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    for (const row of subRows) {\n      if (row.subRows.length > 0) {\n        // find leaf nodes\n        getIndeterminateRecursive(row.subRows, row.id);\n      } else if (rowIdScope !== null && usedParentIndex !== rowIdScope) {\n        usedParentIndex = rowIdScope;\n        const checkIndeterminate = rowId => {\n          const [parentRow, dotIndex] = getParentRow(rowId, rowsById);\n          const selectedRows = parentRow.subRows.filter(item => state.selectedRowIds[item.id]);\n          const areAllSelected = parentRow.subRows.length === selectedRows.length;\n          const isOneSelected = selectedRows.length > 0;\n\n          // if not all, but at least one subRow is selected, set the parent row's state to indeterminate\n          if (isOneSelected && !areAllSelected) {\n            const parentRowId = parentRow.id;\n            Object.assign(indeterminateRowsById, getIndeterminateRowIds(parentRowId));\n            return;\n          }\n          if (dotIndex !== Infinity) {\n            // recursively check indeterminate state until root nodes are reached\n            checkIndeterminate(parentRow.id);\n          }\n          return;\n        };\n        checkIndeterminate(row.id);\n      }\n    }\n  };\n  getIndeterminateRecursive(rows);\n  return indeterminateRowsById;\n};\n\n/**\n * A plugin hook that marks parent rows as indeterminate if a child row is selected in `Multiple` mode.\n * When using this hook, it is recommended to also select all sub-rows when selecting a row. (`reactTableOptions={{ selectSubRows: true }}`)\n *\n * __Note:__ The `indeterminate` state has a higher priority than the `selected` state. Therefore, a row can be selected and indeterminate at the same time. This can for example happen, if `selectSubRows: true` is set and a row with sub-rows is selected and then a sub-row is unselected.\n *\n * __Note:__ This hook has to traverse the whole data tree on each selection, which can lead to performance degradation with large datasets. Please use with caution!\n *\n * @param {event} onIndeterminateChange Fired when the indeterminate state of rows is changed.\n */\nexport const useIndeterminateRowSelection = onIndeterminateChange => {\n  const toggleRowProps = (rowProps, _ref) => {\n    let {\n      row,\n      instance\n    } = _ref;\n    let indeterminate;\n    if (instance.isAllRowsSelected) {\n      indeterminate = false;\n    } else {\n      indeterminate = instance?.state?.indeterminateRows?.[row.id] ?? false;\n    }\n    if (rowProps.checked && !instance.state.selectedRowIds[row.id]) {\n      row.toggleRowSelected(true);\n    }\n    return [rowProps, {\n      indeterminate: indeterminate,\n      checked: indeterminate ? true : rowProps.checked\n    }];\n  };\n  const stateReducer = (newState, action, prevState, instance) => {\n    const {\n      rowsById,\n      state,\n      rows\n    } = instance;\n    if (action.type === 'INDETERMINATE_ROW_IDS') {\n      if (action.payload === 'reset') {\n        return {\n          ...newState,\n          indeterminateRows: {}\n        };\n      }\n      const indeterminateRowsById = getIndeterminate(rows, rowsById, state);\n      return {\n        ...newState,\n        indeterminateRows: indeterminateRowsById\n      };\n    }\n  };\n  const useInstanceAfterData = instance => {\n    const {\n      data,\n      dispatch,\n      rowsById,\n      state: {\n        selectedRowIds,\n        indeterminateRows\n      },\n      webComponentsReactProperties: {\n        selectionMode,\n        selectionBehavior,\n        isTreeTable\n      }\n    } = instance;\n    useEffect(() => {\n      if (isTreeTable && selectionMode === AnalyticalTableSelectionMode.Multiple && selectionBehavior !== AnalyticalTableSelectionBehavior.RowOnly && Object.keys(selectedRowIds).length && Object.keys(rowsById).length !== Object.keys(selectedRowIds).length) {\n        dispatch({\n          type: 'INDETERMINATE_ROW_IDS'\n        });\n      } else if (typeof indeterminateRows === 'object' && Object.keys(indeterminateRows).length) {\n        dispatch({\n          type: 'INDETERMINATE_ROW_IDS',\n          payload: 'reset'\n        });\n      }\n    }, [data, selectedRowIds, isTreeTable, selectionMode, selectionBehavior]);\n    useEffect(() => {\n      if (typeof onIndeterminateChange === 'function' && indeterminateRows) {\n        onIndeterminateChange({\n          indeterminateRowsById: indeterminateRows,\n          tableInstance: instance\n        });\n      }\n    }, [indeterminateRows]);\n  };\n  const useIndeterminate = hooks => {\n    hooks.getToggleRowSelectedProps.push(toggleRowProps);\n    hooks.stateReducers.push(stateReducer);\n    hooks.useInstanceAfterData.push(useInstanceAfterData);\n  };\n  useIndeterminate.pluginName = 'useIndeterminate';\n  return useIndeterminate;\n};","map":{"version":3,"names":["useEffect","AnalyticalTableSelectionBehavior","AnalyticalTableSelectionMode","getParentRow","id","rowsById","lastDotIndex","lastIndexOf","Infinity","parentRowId","slice","getIndeterminateRowIds","indeterminateRowsById","Object","assign","getIndeterminate","rows","state","usedParentIndex","getIndeterminateRecursive","subRows","rowIdScope","arguments","length","undefined","row","checkIndeterminate","rowId","parentRow","dotIndex","selectedRows","filter","item","selectedRowIds","areAllSelected","isOneSelected","useIndeterminateRowSelection","onIndeterminateChange","toggleRowProps","rowProps","_ref","instance","indeterminate","isAllRowsSelected","indeterminateRows","checked","toggleRowSelected","stateReducer","newState","action","prevState","type","payload","useInstanceAfterData","data","dispatch","webComponentsReactProperties","selectionMode","selectionBehavior","isTreeTable","Multiple","RowOnly","keys","tableInstance","useIndeterminate","hooks","getToggleRowSelectedProps","push","stateReducers","pluginName"],"sources":["/home/user/projects/reactproj/node_modules/@ui5/webcomponents-react/dist/components/AnalyticalTable/pluginHooks/useIndeterminateRowSelection.js"],"sourcesContent":["'use client';\n\nimport { useEffect } from 'react';\nimport { AnalyticalTableSelectionBehavior, AnalyticalTableSelectionMode } from '../../../enums/index.js';\nconst getParentRow = (id, rowsById) => {\n  let lastDotIndex = id.lastIndexOf('.');\n  if (lastDotIndex === -1) {\n    lastDotIndex = Infinity;\n  }\n  const parentRowId = id.slice(0, lastDotIndex);\n  return [rowsById[parentRowId], lastDotIndex];\n};\nconst getIndeterminateRowIds = id => {\n  const indeterminateRowsById = {};\n  const lastDotIndex = id.lastIndexOf('.');\n  indeterminateRowsById[id] = true;\n  if (lastDotIndex !== -1) {\n    // set all parent rows to indeterminate\n    Object.assign(indeterminateRowsById, getIndeterminateRowIds(id.slice(0, lastDotIndex)));\n  }\n  return indeterminateRowsById;\n};\nconst getIndeterminate = (rows, rowsById, state) => {\n  const indeterminateRowsById = {};\n  let usedParentIndex = '';\n  const getIndeterminateRecursive = (subRows, rowIdScope = null) => {\n    for (const row of subRows) {\n      if (row.subRows.length > 0) {\n        // find leaf nodes\n        getIndeterminateRecursive(row.subRows, row.id);\n      } else if (rowIdScope !== null && usedParentIndex !== rowIdScope) {\n        usedParentIndex = rowIdScope;\n        const checkIndeterminate = rowId => {\n          const [parentRow, dotIndex] = getParentRow(rowId, rowsById);\n          const selectedRows = parentRow.subRows.filter(item => state.selectedRowIds[item.id]);\n          const areAllSelected = parentRow.subRows.length === selectedRows.length;\n          const isOneSelected = selectedRows.length > 0;\n\n          // if not all, but at least one subRow is selected, set the parent row's state to indeterminate\n          if (isOneSelected && !areAllSelected) {\n            const parentRowId = parentRow.id;\n            Object.assign(indeterminateRowsById, getIndeterminateRowIds(parentRowId));\n            return;\n          }\n          if (dotIndex !== Infinity) {\n            // recursively check indeterminate state until root nodes are reached\n            checkIndeterminate(parentRow.id);\n          }\n          return;\n        };\n        checkIndeterminate(row.id);\n      }\n    }\n  };\n  getIndeterminateRecursive(rows);\n  return indeterminateRowsById;\n};\n\n/**\n * A plugin hook that marks parent rows as indeterminate if a child row is selected in `Multiple` mode.\n * When using this hook, it is recommended to also select all sub-rows when selecting a row. (`reactTableOptions={{ selectSubRows: true }}`)\n *\n * __Note:__ The `indeterminate` state has a higher priority than the `selected` state. Therefore, a row can be selected and indeterminate at the same time. This can for example happen, if `selectSubRows: true` is set and a row with sub-rows is selected and then a sub-row is unselected.\n *\n * __Note:__ This hook has to traverse the whole data tree on each selection, which can lead to performance degradation with large datasets. Please use with caution!\n *\n * @param {event} onIndeterminateChange Fired when the indeterminate state of rows is changed.\n */\nexport const useIndeterminateRowSelection = onIndeterminateChange => {\n  const toggleRowProps = (rowProps, {\n    row,\n    instance\n  }) => {\n    let indeterminate;\n    if (instance.isAllRowsSelected) {\n      indeterminate = false;\n    } else {\n      indeterminate = instance?.state?.indeterminateRows?.[row.id] ?? false;\n    }\n    if (rowProps.checked && !instance.state.selectedRowIds[row.id]) {\n      row.toggleRowSelected(true);\n    }\n    return [rowProps, {\n      indeterminate: indeterminate,\n      checked: indeterminate ? true : rowProps.checked\n    }];\n  };\n  const stateReducer = (newState, action, prevState, instance) => {\n    const {\n      rowsById,\n      state,\n      rows\n    } = instance;\n    if (action.type === 'INDETERMINATE_ROW_IDS') {\n      if (action.payload === 'reset') {\n        return {\n          ...newState,\n          indeterminateRows: {}\n        };\n      }\n      const indeterminateRowsById = getIndeterminate(rows, rowsById, state);\n      return {\n        ...newState,\n        indeterminateRows: indeterminateRowsById\n      };\n    }\n  };\n  const useInstanceAfterData = instance => {\n    const {\n      data,\n      dispatch,\n      rowsById,\n      state: {\n        selectedRowIds,\n        indeterminateRows\n      },\n      webComponentsReactProperties: {\n        selectionMode,\n        selectionBehavior,\n        isTreeTable\n      }\n    } = instance;\n    useEffect(() => {\n      if (isTreeTable && selectionMode === AnalyticalTableSelectionMode.Multiple && selectionBehavior !== AnalyticalTableSelectionBehavior.RowOnly && Object.keys(selectedRowIds).length && Object.keys(rowsById).length !== Object.keys(selectedRowIds).length) {\n        dispatch({\n          type: 'INDETERMINATE_ROW_IDS'\n        });\n      } else if (typeof indeterminateRows === 'object' && Object.keys(indeterminateRows).length) {\n        dispatch({\n          type: 'INDETERMINATE_ROW_IDS',\n          payload: 'reset'\n        });\n      }\n    }, [data, selectedRowIds, isTreeTable, selectionMode, selectionBehavior]);\n    useEffect(() => {\n      if (typeof onIndeterminateChange === 'function' && indeterminateRows) {\n        onIndeterminateChange({\n          indeterminateRowsById: indeterminateRows,\n          tableInstance: instance\n        });\n      }\n    }, [indeterminateRows]);\n  };\n  const useIndeterminate = hooks => {\n    hooks.getToggleRowSelectedProps.push(toggleRowProps);\n    hooks.stateReducers.push(stateReducer);\n    hooks.useInstanceAfterData.push(useInstanceAfterData);\n  };\n  useIndeterminate.pluginName = 'useIndeterminate';\n  return useIndeterminate;\n};"],"mappings":"AAAA,YAAY;;AAEZ,SAASA,SAAS,QAAQ,OAAO;AACjC,SAASC,gCAAgC,EAAEC,4BAA4B,QAAQ,yBAAyB;AACxG,MAAMC,YAAY,GAAGA,CAACC,EAAE,EAAEC,QAAQ,KAAK;EACrC,IAAIC,YAAY,GAAGF,EAAE,CAACG,WAAW,CAAC,GAAG,CAAC;EACtC,IAAID,YAAY,KAAK,CAAC,CAAC,EAAE;IACvBA,YAAY,GAAGE,QAAQ;EACzB;EACA,MAAMC,WAAW,GAAGL,EAAE,CAACM,KAAK,CAAC,CAAC,EAAEJ,YAAY,CAAC;EAC7C,OAAO,CAACD,QAAQ,CAACI,WAAW,CAAC,EAAEH,YAAY,CAAC;AAC9C,CAAC;AACD,MAAMK,sBAAsB,GAAGP,EAAE,IAAI;EACnC,MAAMQ,qBAAqB,GAAG,CAAC,CAAC;EAChC,MAAMN,YAAY,GAAGF,EAAE,CAACG,WAAW,CAAC,GAAG,CAAC;EACxCK,qBAAqB,CAACR,EAAE,CAAC,GAAG,IAAI;EAChC,IAAIE,YAAY,KAAK,CAAC,CAAC,EAAE;IACvB;IACAO,MAAM,CAACC,MAAM,CAACF,qBAAqB,EAAED,sBAAsB,CAACP,EAAE,CAACM,KAAK,CAAC,CAAC,EAAEJ,YAAY,CAAC,CAAC,CAAC;EACzF;EACA,OAAOM,qBAAqB;AAC9B,CAAC;AACD,MAAMG,gBAAgB,GAAGA,CAACC,IAAI,EAAEX,QAAQ,EAAEY,KAAK,KAAK;EAClD,MAAML,qBAAqB,GAAG,CAAC,CAAC;EAChC,IAAIM,eAAe,GAAG,EAAE;EACxB,MAAMC,yBAAyB,GAAG,SAAAA,CAACC,OAAO,EAAwB;IAAA,IAAtBC,UAAU,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;IAC3D,KAAK,MAAMG,GAAG,IAAIL,OAAO,EAAE;MACzB,IAAIK,GAAG,CAACL,OAAO,CAACG,MAAM,GAAG,CAAC,EAAE;QAC1B;QACAJ,yBAAyB,CAACM,GAAG,CAACL,OAAO,EAAEK,GAAG,CAACrB,EAAE,CAAC;MAChD,CAAC,MAAM,IAAIiB,UAAU,KAAK,IAAI,IAAIH,eAAe,KAAKG,UAAU,EAAE;QAChEH,eAAe,GAAGG,UAAU;QAC5B,MAAMK,kBAAkB,GAAGC,KAAK,IAAI;UAClC,MAAM,CAACC,SAAS,EAAEC,QAAQ,CAAC,GAAG1B,YAAY,CAACwB,KAAK,EAAEtB,QAAQ,CAAC;UAC3D,MAAMyB,YAAY,GAAGF,SAAS,CAACR,OAAO,CAACW,MAAM,CAACC,IAAI,IAAIf,KAAK,CAACgB,cAAc,CAACD,IAAI,CAAC5B,EAAE,CAAC,CAAC;UACpF,MAAM8B,cAAc,GAAGN,SAAS,CAACR,OAAO,CAACG,MAAM,KAAKO,YAAY,CAACP,MAAM;UACvE,MAAMY,aAAa,GAAGL,YAAY,CAACP,MAAM,GAAG,CAAC;;UAE7C;UACA,IAAIY,aAAa,IAAI,CAACD,cAAc,EAAE;YACpC,MAAMzB,WAAW,GAAGmB,SAAS,CAACxB,EAAE;YAChCS,MAAM,CAACC,MAAM,CAACF,qBAAqB,EAAED,sBAAsB,CAACF,WAAW,CAAC,CAAC;YACzE;UACF;UACA,IAAIoB,QAAQ,KAAKrB,QAAQ,EAAE;YACzB;YACAkB,kBAAkB,CAACE,SAAS,CAACxB,EAAE,CAAC;UAClC;UACA;QACF,CAAC;QACDsB,kBAAkB,CAACD,GAAG,CAACrB,EAAE,CAAC;MAC5B;IACF;EACF,CAAC;EACDe,yBAAyB,CAACH,IAAI,CAAC;EAC/B,OAAOJ,qBAAqB;AAC9B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMwB,4BAA4B,GAAGC,qBAAqB,IAAI;EACnE,MAAMC,cAAc,GAAGA,CAACC,QAAQ,EAAAC,IAAA,KAG1B;IAAA,IAH4B;MAChCf,GAAG;MACHgB;IACF,CAAC,GAAAD,IAAA;IACC,IAAIE,aAAa;IACjB,IAAID,QAAQ,CAACE,iBAAiB,EAAE;MAC9BD,aAAa,GAAG,KAAK;IACvB,CAAC,MAAM;MACLA,aAAa,GAAGD,QAAQ,EAAExB,KAAK,EAAE2B,iBAAiB,GAAGnB,GAAG,CAACrB,EAAE,CAAC,IAAI,KAAK;IACvE;IACA,IAAImC,QAAQ,CAACM,OAAO,IAAI,CAACJ,QAAQ,CAACxB,KAAK,CAACgB,cAAc,CAACR,GAAG,CAACrB,EAAE,CAAC,EAAE;MAC9DqB,GAAG,CAACqB,iBAAiB,CAAC,IAAI,CAAC;IAC7B;IACA,OAAO,CAACP,QAAQ,EAAE;MAChBG,aAAa,EAAEA,aAAa;MAC5BG,OAAO,EAAEH,aAAa,GAAG,IAAI,GAAGH,QAAQ,CAACM;IAC3C,CAAC,CAAC;EACJ,CAAC;EACD,MAAME,YAAY,GAAGA,CAACC,QAAQ,EAAEC,MAAM,EAAEC,SAAS,EAAET,QAAQ,KAAK;IAC9D,MAAM;MACJpC,QAAQ;MACRY,KAAK;MACLD;IACF,CAAC,GAAGyB,QAAQ;IACZ,IAAIQ,MAAM,CAACE,IAAI,KAAK,uBAAuB,EAAE;MAC3C,IAAIF,MAAM,CAACG,OAAO,KAAK,OAAO,EAAE;QAC9B,OAAO;UACL,GAAGJ,QAAQ;UACXJ,iBAAiB,EAAE,CAAC;QACtB,CAAC;MACH;MACA,MAAMhC,qBAAqB,GAAGG,gBAAgB,CAACC,IAAI,EAAEX,QAAQ,EAAEY,KAAK,CAAC;MACrE,OAAO;QACL,GAAG+B,QAAQ;QACXJ,iBAAiB,EAAEhC;MACrB,CAAC;IACH;EACF,CAAC;EACD,MAAMyC,oBAAoB,GAAGZ,QAAQ,IAAI;IACvC,MAAM;MACJa,IAAI;MACJC,QAAQ;MACRlD,QAAQ;MACRY,KAAK,EAAE;QACLgB,cAAc;QACdW;MACF,CAAC;MACDY,4BAA4B,EAAE;QAC5BC,aAAa;QACbC,iBAAiB;QACjBC;MACF;IACF,CAAC,GAAGlB,QAAQ;IACZzC,SAAS,CAAC,MAAM;MACd,IAAI2D,WAAW,IAAIF,aAAa,KAAKvD,4BAA4B,CAAC0D,QAAQ,IAAIF,iBAAiB,KAAKzD,gCAAgC,CAAC4D,OAAO,IAAIhD,MAAM,CAACiD,IAAI,CAAC7B,cAAc,CAAC,CAACV,MAAM,IAAIV,MAAM,CAACiD,IAAI,CAACzD,QAAQ,CAAC,CAACkB,MAAM,KAAKV,MAAM,CAACiD,IAAI,CAAC7B,cAAc,CAAC,CAACV,MAAM,EAAE;QACzPgC,QAAQ,CAAC;UACPJ,IAAI,EAAE;QACR,CAAC,CAAC;MACJ,CAAC,MAAM,IAAI,OAAOP,iBAAiB,KAAK,QAAQ,IAAI/B,MAAM,CAACiD,IAAI,CAAClB,iBAAiB,CAAC,CAACrB,MAAM,EAAE;QACzFgC,QAAQ,CAAC;UACPJ,IAAI,EAAE,uBAAuB;UAC7BC,OAAO,EAAE;QACX,CAAC,CAAC;MACJ;IACF,CAAC,EAAE,CAACE,IAAI,EAAErB,cAAc,EAAE0B,WAAW,EAAEF,aAAa,EAAEC,iBAAiB,CAAC,CAAC;IACzE1D,SAAS,CAAC,MAAM;MACd,IAAI,OAAOqC,qBAAqB,KAAK,UAAU,IAAIO,iBAAiB,EAAE;QACpEP,qBAAqB,CAAC;UACpBzB,qBAAqB,EAAEgC,iBAAiB;UACxCmB,aAAa,EAAEtB;QACjB,CAAC,CAAC;MACJ;IACF,CAAC,EAAE,CAACG,iBAAiB,CAAC,CAAC;EACzB,CAAC;EACD,MAAMoB,gBAAgB,GAAGC,KAAK,IAAI;IAChCA,KAAK,CAACC,yBAAyB,CAACC,IAAI,CAAC7B,cAAc,CAAC;IACpD2B,KAAK,CAACG,aAAa,CAACD,IAAI,CAACpB,YAAY,CAAC;IACtCkB,KAAK,CAACZ,oBAAoB,CAACc,IAAI,CAACd,oBAAoB,CAAC;EACvD,CAAC;EACDW,gBAAgB,CAACK,UAAU,GAAG,kBAAkB;EAChD,OAAOL,gBAAgB;AACzB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
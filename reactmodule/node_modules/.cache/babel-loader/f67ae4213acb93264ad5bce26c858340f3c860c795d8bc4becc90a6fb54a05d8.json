{"ast":null,"code":"import { enrichEventWithDetails } from '@ui5/webcomponents-react-base';\nimport { DEFAULT_COLUMN_WIDTH } from '../defaults/Column/index.js';\nimport { CELL_PADDING_PX } from './useDynamicColumnWidths.js';\nfunction setResizerProps(props, _ref) {\n  let {\n    instance,\n    header\n  } = _ref;\n  const {\n    dispatch,\n    virtualRowsRange,\n    rows,\n    webComponentsReactProperties\n  } = instance;\n  const {\n    onAutoResize,\n    tableRef,\n    isTreeTable\n  } = webComponentsReactProperties;\n  const {\n    autoResizable,\n    id: accessor\n  } = header;\n  if (!document || !tableRef.current || !autoResizable || !rows.length || !virtualRowsRange) {\n    return props;\n  }\n  return {\n    ...props,\n    onDoubleClick: e => {\n      let largest = getMeasureMax(accessor, virtualRowsRange, tableRef.current, isTreeTable);\n      if (largest === -1) {\n        return;\n      }\n      largest = largest > DEFAULT_COLUMN_WIDTH ? largest : DEFAULT_COLUMN_WIDTH;\n      if (typeof onAutoResize === 'function') {\n        onAutoResize(enrichEventWithDetails(e, {\n          columnId: accessor,\n          width: largest\n        }));\n      }\n      if (e.defaultPrevented) {\n        return;\n      }\n      dispatch({\n        type: 'AUTO_RESIZE',\n        payload: {\n          [accessor]: largest\n        }\n      });\n    }\n  };\n}\nfunction calculateContentWidth(cell) {\n  let contentWidth = 0;\n  Array.from(cell.children).forEach(child => {\n    contentWidth += child.scrollWidth;\n  });\n  return contentWidth;\n}\nfunction getMeasureMax(accessor, virtualRowsRange, tableNode, isTreeTable) {\n  let maxWidth = 0;\n  let cellWithMaxWidthContent = null;\n\n  /**\n   * recursively find the largest visible cell of the current column\n   */\n  function recursiveFindMaxWidth(row, accessor, remainingRows) {\n    if (!row || remainingRows === 0) {\n      return;\n    }\n    const cellNode = row.querySelector(`[data-column-id-cell=\"${accessor}\"]`);\n    const cellTextElement = cellNode?.querySelector(`[data-column-id-cell-text=\"${accessor}\"]`);\n    if (cellTextElement) {\n      // for tree tables the indent (margin) has to be taken into account\n      if (isTreeTable && cellNode?.dataset.isFirstColumn) {\n        const cellWidth = calculateContentWidth(cellNode);\n        if (maxWidth < cellWidth) {\n          maxWidth = cellWidth;\n          cellWithMaxWidthContent = false;\n        }\n      } else {\n        const currWidth = cellTextElement.scrollWidth;\n        if (maxWidth < currWidth) {\n          maxWidth = currWidth;\n          // only use the cell with the largest content for measuring\n          cellWithMaxWidthContent = cellNode;\n        }\n      }\n    }\n    // if custom content (`Cell`) is rendered, the `cellTextElement` is not available.\n    // In this case only the content of the first visible cell is used for measuring\n    if (cellWithMaxWidthContent === null) {\n      cellWithMaxWidthContent = cellNode;\n    }\n    recursiveFindMaxWidth(row.nextElementSibling, accessor, remainingRows - 1);\n  }\n  const firstRow = tableNode.querySelector(`[data-virtual-row-index=\"${virtualRowsRange.startIndex}\"]`);\n  recursiveFindMaxWidth(firstRow, accessor, virtualRowsRange.endIndex - virtualRowsRange.startIndex);\n  if (cellWithMaxWidthContent === false) {\n    return Math.ceil(maxWidth + CELL_PADDING_PX + 2 /* account for rounding error and border */);\n  }\n  if (!cellWithMaxWidthContent) {\n    return -1;\n  }\n  return Math.ceil(calculateContentWidth(cellWithMaxWidthContent) + CELL_PADDING_PX + 2 /* account for rounding error and border */);\n}\nconst setCellProps = (props, _ref2) => {\n  let {\n    cell: {\n      column: {\n        id\n      }\n    }\n  } = _ref2;\n  return [props, {\n    ['data-column-id-cell']: id\n  }];\n};\nexport const useAutoResize = hooks => {\n  hooks.getResizerProps.push(setResizerProps);\n  hooks.getCellProps.push(setCellProps);\n};\nuseAutoResize.pluginName = 'useAutoResize';","map":{"version":3,"names":["enrichEventWithDetails","DEFAULT_COLUMN_WIDTH","CELL_PADDING_PX","setResizerProps","props","_ref","instance","header","dispatch","virtualRowsRange","rows","webComponentsReactProperties","onAutoResize","tableRef","isTreeTable","autoResizable","id","accessor","document","current","length","onDoubleClick","e","largest","getMeasureMax","columnId","width","defaultPrevented","type","payload","calculateContentWidth","cell","contentWidth","Array","from","children","forEach","child","scrollWidth","tableNode","maxWidth","cellWithMaxWidthContent","recursiveFindMaxWidth","row","remainingRows","cellNode","querySelector","cellTextElement","dataset","isFirstColumn","cellWidth","currWidth","nextElementSibling","firstRow","startIndex","endIndex","Math","ceil","setCellProps","_ref2","column","useAutoResize","hooks","getResizerProps","push","getCellProps","pluginName"],"sources":["/home/user/projects/reactproj/node_modules/@ui5/webcomponents-react/dist/components/AnalyticalTable/hooks/useAutoResize.js"],"sourcesContent":["import { enrichEventWithDetails } from '@ui5/webcomponents-react-base';\nimport { DEFAULT_COLUMN_WIDTH } from '../defaults/Column/index.js';\nimport { CELL_PADDING_PX } from './useDynamicColumnWidths.js';\nfunction setResizerProps(props, {\n  instance,\n  header\n}) {\n  const {\n    dispatch,\n    virtualRowsRange,\n    rows,\n    webComponentsReactProperties\n  } = instance;\n  const {\n    onAutoResize,\n    tableRef,\n    isTreeTable\n  } = webComponentsReactProperties;\n  const {\n    autoResizable,\n    id: accessor\n  } = header;\n  if (!document || !tableRef.current || !autoResizable || !rows.length || !virtualRowsRange) {\n    return props;\n  }\n  return {\n    ...props,\n    onDoubleClick: e => {\n      let largest = getMeasureMax(accessor, virtualRowsRange, tableRef.current, isTreeTable);\n      if (largest === -1) {\n        return;\n      }\n      largest = largest > DEFAULT_COLUMN_WIDTH ? largest : DEFAULT_COLUMN_WIDTH;\n      if (typeof onAutoResize === 'function') {\n        onAutoResize(enrichEventWithDetails(e, {\n          columnId: accessor,\n          width: largest\n        }));\n      }\n      if (e.defaultPrevented) {\n        return;\n      }\n      dispatch({\n        type: 'AUTO_RESIZE',\n        payload: {\n          [accessor]: largest\n        }\n      });\n    }\n  };\n}\nfunction calculateContentWidth(cell) {\n  let contentWidth = 0;\n  Array.from(cell.children).forEach(child => {\n    contentWidth += child.scrollWidth;\n  });\n  return contentWidth;\n}\nfunction getMeasureMax(accessor, virtualRowsRange, tableNode, isTreeTable) {\n  let maxWidth = 0;\n  let cellWithMaxWidthContent = null;\n\n  /**\n   * recursively find the largest visible cell of the current column\n   */\n  function recursiveFindMaxWidth(row, accessor, remainingRows) {\n    if (!row || remainingRows === 0) {\n      return;\n    }\n    const cellNode = row.querySelector(`[data-column-id-cell=\"${accessor}\"]`);\n    const cellTextElement = cellNode?.querySelector(`[data-column-id-cell-text=\"${accessor}\"]`);\n    if (cellTextElement) {\n      // for tree tables the indent (margin) has to be taken into account\n      if (isTreeTable && cellNode?.dataset.isFirstColumn) {\n        const cellWidth = calculateContentWidth(cellNode);\n        if (maxWidth < cellWidth) {\n          maxWidth = cellWidth;\n          cellWithMaxWidthContent = false;\n        }\n      } else {\n        const currWidth = cellTextElement.scrollWidth;\n        if (maxWidth < currWidth) {\n          maxWidth = currWidth;\n          // only use the cell with the largest content for measuring\n          cellWithMaxWidthContent = cellNode;\n        }\n      }\n    }\n    // if custom content (`Cell`) is rendered, the `cellTextElement` is not available.\n    // In this case only the content of the first visible cell is used for measuring\n    if (cellWithMaxWidthContent === null) {\n      cellWithMaxWidthContent = cellNode;\n    }\n    recursiveFindMaxWidth(row.nextElementSibling, accessor, remainingRows - 1);\n  }\n  const firstRow = tableNode.querySelector(`[data-virtual-row-index=\"${virtualRowsRange.startIndex}\"]`);\n  recursiveFindMaxWidth(firstRow, accessor, virtualRowsRange.endIndex - virtualRowsRange.startIndex);\n  if (cellWithMaxWidthContent === false) {\n    return Math.ceil(maxWidth + CELL_PADDING_PX + 2 /* account for rounding error and border */);\n  }\n  if (!cellWithMaxWidthContent) {\n    return -1;\n  }\n  return Math.ceil(calculateContentWidth(cellWithMaxWidthContent) + CELL_PADDING_PX + 2 /* account for rounding error and border */);\n}\nconst setCellProps = (props, {\n  cell: {\n    column: {\n      id\n    }\n  }\n}) => {\n  return [props, {\n    ['data-column-id-cell']: id\n  }];\n};\nexport const useAutoResize = hooks => {\n  hooks.getResizerProps.push(setResizerProps);\n  hooks.getCellProps.push(setCellProps);\n};\nuseAutoResize.pluginName = 'useAutoResize';"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}